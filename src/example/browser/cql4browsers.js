(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Code, CodeService, ValueSet, ref;

  ref = require('./datatypes/datatypes'), Code = ref.Code, ValueSet = ref.ValueSet;

  CodeService = (function() {
    function CodeService(valueSetsJson) {
      var code, codes, oid, version;
      if (valueSetsJson == null) {
        valueSetsJson = {};
      }
      this.valueSets = {};
      for (oid in valueSetsJson) {
        this.valueSets[oid] = {};
        for (version in valueSetsJson[oid]) {
          codes = (function() {
            var i, len, ref1, results1;
            ref1 = valueSetsJson[oid][version];
            results1 = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              code = ref1[i];
              results1.push(new Code(code.code, code.system, code.version));
            }
            return results1;
          })();
          this.valueSets[oid][version] = new ValueSet(oid, version, codes);
        }
      }
    }

    CodeService.prototype.findValueSetsByOid = function(oid) {
      var ref1, results1, valueSet, version;
      ref1 = this.valueSets[oid];
      results1 = [];
      for (version in ref1) {
        valueSet = ref1[version];
        results1.push(valueSet);
      }
      return results1;
    };

    CodeService.prototype.findValueSet = function(oid, version) {
      var ref1, results;
      if (version != null) {
        return (ref1 = this.valueSets[oid]) != null ? ref1[version] : void 0;
      } else {
        results = this.findValueSetsByOid(oid);
        if (results.length === 0) {
          return null;
        } else {
          return results.reduce(function(a, b) {
            if (a.version > b.version) {
              return a;
            } else {
              return b;
            }
          });
        }
      }
    };

    return CodeService;

  })();

  module.exports.CodeService = CodeService;

}).call(this);



},{"./datatypes/datatypes":5}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var DT, Patient, PatientSource, Record, toDate, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('./datatypes/datatypes');

  typeIsArray = require('./util/util').typeIsArray;

  toDate = function(str) {
    if (typeof str === 'string') {
      return new Date(str);
    } else {
      return null;
    }
  };

  Record = (function() {
    function Record(json1) {
      this.json = json1;
      this.id = this.json.id;
    }

    Record.prototype._recursiveGet = function(field) {
      var ref, rest, root;
      if ((field != null) && field.indexOf('.') >= 0) {
        ref = field.split('.', 2), root = ref[0], rest = ref[1];
        return (new Record(this._recursiveGet(root)))._recursiveGet(rest);
      }
      return this.json[field];
    };

    Record.prototype.get = function(field) {
      var value;
      value = this._recursiveGet(field);
      if (typeof value === 'string' && /\d{4}-\d{2}-\d{2}(T[\d\-.]+)?/.test(value)) {
        return this.getDate(field);
      }
      if ((value != null) && typeof value === 'object' && (value.code != null) && (value.system != null)) {
        return this.getCode(field);
      }
      if ((value != null) && typeof value === 'object' && ((value.low != null) || (value.high != null))) {
        return this.getInterval(field);
      }
      return value;
    };

    Record.prototype.getId = function() {
      return this.id;
    };

    Record.prototype.getDate = function(field) {
      var val;
      val = this._recursiveGet(field);
      if (val != null) {
        return DT.DateTime.parse(val);
      } else {
        return null;
      }
    };

    Record.prototype.getInterval = function(field) {
      var high, low, val;
      val = this._recursiveGet(field);
      if ((val != null) && typeof val === 'object') {
        low = val.low != null ? DT.DateTime.parse(val.low) : null;
        high = val.high != null ? DT.DateTime.parse(val.high) : null;
        return new DT.Interval(low, high);
      }
    };

    Record.prototype.getDateOrInterval = function(field) {
      var val;
      val = this._recursiveGet(field);
      if ((val != null) && typeof val === 'object') {
        return this.getInterval(field);
      } else {
        return this.getDate(field);
      }
    };

    Record.prototype.getCode = function(field) {
      var val;
      val = this._recursiveGet(field);
      if ((val != null) && typeof val === 'object') {
        return new DT.Code(val.code, val.system, val.version);
      }
    };

    return Record;

  })();

  Patient = (function(superClass) {
    extend(Patient, superClass);

    function Patient(json) {
      var base, i, len, name, r, ref, ref1;
      Patient.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.gender = json.gender;
      this.birthDate = json.birthDate != null ? DT.DateTime.parse(json.birthDate) : void 0;
      this.records = {};
      ref1 = (ref = json.records) != null ? ref : [];
      for (i = 0, len = ref1.length; i < len; i++) {
        r = ref1[i];
        if ((base = this.records)[name = r.recordType] == null) {
          base[name] = [];
        }
        this.records[r.recordType].push(new Record(r));
      }
    }

    Patient.prototype.findRecords = function(profile) {
      var recordType, ref;
      recordType = profile != null ? profile.match(/(\{https:\/\/github\.com\/cqframework\/cql-execution\/simple\})?(.*)/)[2] : void 0;
      if (recordType === 'Patient') {
        return [this];
      } else {
        return (ref = this.records[recordType]) != null ? ref : [];
      }
    };

    return Patient;

  })(Record);

  PatientSource = (function() {
    function PatientSource(patients) {
      this.patients = patients;
      this.nextPatient();
    }

    PatientSource.prototype.currentPatient = function() {
      return this.current;
    };

    PatientSource.prototype.nextPatient = function() {
      var currentJSON;
      currentJSON = this.patients.shift();
      return this.current = currentJSON ? new Patient(currentJSON) : void 0;
    };

    return PatientSource;

  })();

  module.exports.Patient = Patient;

  module.exports.PatientSource = PatientSource;

}).call(this);



},{"./datatypes/datatypes":5,"./util/util":47}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var codeservice, context, datatypes, exec, expression, library, patient, quantity, repository, results;

  library = require('./elm/library');

  quantity = require('./elm/quantity');

  expression = require('./elm/expression');

  repository = require('./runtime/repository');

  context = require('./runtime/context');

  exec = require('./runtime/executor');

  results = require('./runtime/results');

  datatypes = require('./datatypes/datatypes');

  patient = require('./cql-patient');

  codeservice = require('./cql-code-service');

  module.exports.Library = library.Library;

  module.exports.Repository = repository.Repository;

  module.exports.Expression = expression.Expression;

  module.exports.Context = context.Context;

  module.exports.Executor = exec.Executor;

  module.exports.PatientContext = context.PatientContext;

  module.exports.UnfilteredContext = context.UnfilteredContext;

  module.exports.Results = results.Results;

  module.exports.Patient = patient.Patient;

  module.exports.PatientSource = patient.PatientSource;

  module.exports.CodeService = codeservice.CodeService;

  module.exports.Code = datatypes.Code;

  module.exports.CodeSystem = datatypes.CodeSystem;

  module.exports.Concept = datatypes.Concept;

  module.exports.Date = datatypes.Date;

  module.exports.DateTime = datatypes.DateTime;

  module.exports.Interval = datatypes.Interval;

  module.exports.Quantity = datatypes.Quantity;

  module.exports.Ratio = datatypes.Ratio;

  module.exports.ValueSet = datatypes.ValueSet;

}).call(this);



},{"./cql-code-service":1,"./cql-patient":2,"./datatypes/datatypes":5,"./elm/expression":21,"./elm/library":26,"./elm/quantity":33,"./runtime/context":41,"./runtime/executor":42,"./runtime/repository":43,"./runtime/results":44}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Code, CodeSystem, Concept, ValueSet, codesInList, codesMatch, toCodeList, typeIsArray;

  typeIsArray = require('../util/util').typeIsArray;

  module.exports.Code = Code = (function() {
    function Code(code3, system, version, display) {
      this.code = code3;
      this.system = system;
      this.version = version;
      this.display = display;
    }

    Object.defineProperties(Code.prototype, {
      isCode: {
        get: function() {
          return true;
        }
      }
    });

    Code.prototype.hasMatch = function(code) {
      if (typeof code === 'string') {
        return code === this.code;
      } else {
        return codesInList(toCodeList(code), [this]);
      }
    };

    return Code;

  })();

  module.exports.Concept = Concept = (function() {
    function Concept(codes, display) {
      this.codes = codes != null ? codes : [];
      this.display = display;
    }

    Object.defineProperties(Concept.prototype, {
      isConcept: {
        get: function() {
          return true;
        }
      }
    });

    Concept.prototype.hasMatch = function(code) {
      return codesInList(toCodeList(code), this.codes);
    };

    return Concept;

  })();

  module.exports.ValueSet = ValueSet = (function() {
    function ValueSet(oid, version, codes) {
      this.oid = oid;
      this.version = version;
      this.codes = codes != null ? codes : [];
    }

    Object.defineProperties(ValueSet.prototype, {
      isValueSet: {
        get: function() {
          return true;
        }
      }
    });

    ValueSet.prototype.hasMatch = function(code) {
      var codeItem, codesList, i, len, matchFound, multipleCodeSystemsExist, ref;
      codesList = toCodeList(code);
      if (codesList.length === 1 && typeof codesList[0] === 'string') {
        matchFound = false;
        multipleCodeSystemsExist = false;
        ref = this.codes;
        for (i = 0, len = ref.length; i < len; i++) {
          codeItem = ref[i];
          if (codeItem.system !== this.codes[0].system) {
            multipleCodeSystemsExist = true;
          }
          if (codeItem.code === codesList[0]) {
            matchFound = true;
          }
          if (multipleCodeSystemsExist && matchFound) {
            throw new Error('In (valueset) is ambiguous -- multiple codes with multiple code systems exist in value set.');
          }
        }
        return matchFound;
      } else {
        return codesInList(codesList, this.codes);
      }
    };

    return ValueSet;

  })();

  toCodeList = function(c) {
    var c2, i, len, list;
    if (c == null) {
      return [];
    } else if (typeIsArray(c)) {
      list = [];
      for (i = 0, len = c.length; i < len; i++) {
        c2 = c[i];
        list = list.concat(toCodeList(c2));
      }
      return list;
    } else if (typeIsArray(c.codes)) {
      return c.codes;
    } else {
      return [c];
    }
  };

  codesInList = function(cl1, cl2) {
    return cl1.some(function(c1) {
      return cl2.some(function(c2) {
        if (typeof c1 === 'string') {
          return c1 === c2.code;
        } else {
          return codesMatch(c1, c2);
        }
      });
    });
  };

  codesMatch = function(code1, code2) {
    return code1.code === code2.code && code1.system === code2.system;
  };

  module.exports.CodeSystem = CodeSystem = (function() {
    function CodeSystem(id, version) {
      this.id = id;
      this.version = version;
    }

    return CodeSystem;

  })();

}).call(this);



},{"../util/util":47}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var clinical, datetime, element, i, interval, j, len, len1, lib, libs, logic, quantity, ratio, ref, uncertainty;

  logic = require('./logic');

  clinical = require('./clinical');

  uncertainty = require('./uncertainty');

  datetime = require('./datetime');

  interval = require('./interval');

  quantity = require('./quantity');

  ratio = require('./ratio');

  libs = [logic, clinical, uncertainty, datetime, interval, quantity, ratio];

  for (i = 0, len = libs.length; i < len; i++) {
    lib = libs[i];
    ref = Object.keys(lib);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      element = ref[j];
      module.exports[element] = lib[element];
    }
  }

}).call(this);



},{"./clinical":4,"./datetime":6,"./interval":8,"./logic":9,"./quantity":10,"./ratio":11,"./uncertainty":12}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Date, DateTime, MAX_DATETIME_VALUE, MIN_DATETIME_VALUE, Uncertainty, compareWithDefaultResult, cqlFormatStringToMomentFormatString, daysInMonth, getTimezoneSeparatorFromString, isValidDateStringFormat, isValidDateTimeStringFormat, jsDate, moment, normalizeMillisecondsField, normalizeMillisecondsFieldInString, ref,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Uncertainty = require('./uncertainty').Uncertainty;

  ref = require('../util/util'), jsDate = ref.jsDate, normalizeMillisecondsField = ref.normalizeMillisecondsField, normalizeMillisecondsFieldInString = ref.normalizeMillisecondsFieldInString, getTimezoneSeparatorFromString = ref.getTimezoneSeparatorFromString;

  moment = require('moment');

  DateTime = (function() {
    Object.defineProperties(DateTime.prototype, {
      isDateTime: {
        get: function() {
          return true;
        }
      }
    });

    DateTime.Unit = {
      YEAR: 'year',
      MONTH: 'month',
      WEEK: 'week',
      DAY: 'day',
      HOUR: 'hour',
      MINUTE: 'minute',
      SECOND: 'second',
      MILLISECOND: 'millisecond'
    };

    DateTime.FIELDS = [DateTime.Unit.YEAR, DateTime.Unit.MONTH, DateTime.Unit.DAY, DateTime.Unit.HOUR, DateTime.Unit.MINUTE, DateTime.Unit.SECOND, DateTime.Unit.MILLISECOND];

    DateTime.parse = function(string) {
      var arg, args, days, hours, matches, milliseconds, minutes, months, num, seconds, years;
      if (string === null) {
        return null;
      }
      matches = /(\d{4})(-(\d{2}))?(-(\d{2}))?(T((\d{2})(\:(\d{2})(\:(\d{2})(\.(\d+))?)?)?)?(Z|(([+-])(\d{2})(\:?(\d{2}))?))?)?/.exec(string);
      if (matches == null) {
        return null;
      }
      years = matches[1];
      months = matches[3];
      days = matches[5];
      hours = matches[8];
      minutes = matches[10];
      seconds = matches[12];
      milliseconds = matches[14];
      if (milliseconds != null) {
        milliseconds = normalizeMillisecondsField(milliseconds);
      }
      if (milliseconds != null) {
        string = normalizeMillisecondsFieldInString(string, matches[14]);
      }
      if (!isValidDateTimeStringFormat(string)) {
        return null;
      }
      args = [years, months, days, hours, minutes, seconds, milliseconds];
      args = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          results.push(arg != null ? parseInt(arg, 10) : void 0);
        }
        return results;
      })();
      if (matches[18] != null) {
        num = parseInt(matches[18], 10) + (matches[20] != null ? parseInt(matches[20], 10) / 60 : 0);
        args.push(matches[17] === '+' ? num : num * -1);
      } else if (matches[15] === 'Z') {
        args.push(0);
      }
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(DateTime, args, function(){});
    };

    DateTime.fromJSDate = function(date, timezoneOffset) {
      if (date instanceof DateTime) {
        return date;
      }
      if (timezoneOffset != null) {
        date = new jsDate(date.getTime() + (timezoneOffset * 60 * 60 * 1000));
        return new DateTime(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds(), timezoneOffset);
      } else {
        return new DateTime(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
      }
    };

    function DateTime(year1, month1, day, hour, minute, second, millisecond, timezoneOffset1) {
      this.year = year1 != null ? year1 : null;
      this.month = month1 != null ? month1 : null;
      this.day = day != null ? day : null;
      this.hour = hour != null ? hour : null;
      this.minute = minute != null ? minute : null;
      this.second = second != null ? second : null;
      this.millisecond = millisecond != null ? millisecond : null;
      this.timezoneOffset = timezoneOffset1;
      if (typeof this.timezoneOffset === 'undefined') {
        this.timezoneOffset = (new jsDate()).getTimezoneOffset() / 60 * -1;
      }
    }

    DateTime.prototype.copy = function() {
      return new DateTime(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond, this.timezoneOffset);
    };

    DateTime.prototype.successor = function() {
      if (this.millisecond != null) {
        return this.add(1, DateTime.Unit.MILLISECOND);
      } else if (this.second != null) {
        return this.add(1, DateTime.Unit.SECOND);
      } else if (this.minute != null) {
        return this.add(1, DateTime.Unit.MINUTE);
      } else if (this.hour != null) {
        return this.add(1, DateTime.Unit.HOUR);
      } else if (this.day != null) {
        return this.add(1, DateTime.Unit.DAY);
      } else if (this.month != null) {
        return this.add(1, DateTime.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(1, DateTime.Unit.YEAR);
      }
    };

    DateTime.prototype.predecessor = function() {
      if (this.millisecond != null) {
        return this.add(-1, DateTime.Unit.MILLISECOND);
      } else if (this.second != null) {
        return this.add(-1, DateTime.Unit.SECOND);
      } else if (this.minute != null) {
        return this.add(-1, DateTime.Unit.MINUTE);
      } else if (this.hour != null) {
        return this.add(-1, DateTime.Unit.HOUR);
      } else if (this.day != null) {
        return this.add(-1, DateTime.Unit.DAY);
      } else if (this.month != null) {
        return this.add(-1, DateTime.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(-1, DateTime.Unit.YEAR);
      }
    };

    DateTime.prototype.convertToTimezoneOffset = function(timezoneOffset) {
      var d;
      if (timezoneOffset == null) {
        timezoneOffset = 0;
      }
      d = DateTime.fromJSDate(this.toJSDate(), timezoneOffset);
      return d.reducedPrecision(this.getPrecision());
    };

    DateTime.prototype.differenceBetween = function(other, unitField) {
      var a, aHighMoment, aJS, aLowMoment, aUncertainty, b, bHighMoment, bJS, bLowMoment, bUncertainty, tzDiff;
      other = this._implicitlyConvert(other);
      if (!(other != null ? other.isDateTime : void 0)) {
        return null;
      }
      a = this.copy();
      b = other.copy();
      if (unitField === DateTime.Unit.MONTH || unitField === DateTime.Unit.YEAR || unitField === DateTime.Unit.WEEK || unitField === DateTime.Unit.DAY) {
        if (a.timezoneOffset !== b.timezoneOffset) {
          b = b.convertToTimezoneOffset(a.timezoneOffset);
        }
        if (!a.isUTC() || !b.isUTC()) {
          aJS = a.toJSDate(true);
          bJS = b.toJSDate(true);
          tzDiff = aJS.getTimezoneOffset() - bJS.getTimezoneOffset();
          if (tzDiff !== 0) {
            if ((b.year != null) && (b.month != null) && (b.day != null) && (b.hour != null) && (b.minute != null)) {
              b = b.add(tzDiff, DateTime.Unit.MINUTE);
            } else if ((b.year != null) && (b.month != null) && (b.day != null) && (b.hour != null)) {
              b = b.add(tzDiff / 60, DateTime.Unit.HOUR);
            } else {
              b.timezoneOffset = b.timezoneOffset + (tzDiff / 60);
            }
          }
        }
      }
      if (unitField === DateTime.Unit.YEAR) {
        a = new DateTime(a.year, 1, 1, 12, 0, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, 1, 1, 12, 0, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.MONTH) {
        a = new DateTime(a.year, a.month, 1, 12, 0, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, 1, 12, 0, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.WEEK) {
        a = this._floorWeek(a);
        b = this._floorWeek(b);
      } else if (unitField === DateTime.Unit.DAY) {
        a = new DateTime(a.year, a.month, a.day, 12, 0, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, b.day, 12, 0, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.HOUR) {
        a = new DateTime(a.year, a.month, a.day, a.hour, 30, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, b.day, b.hour, 30, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.MINUTE) {
        a = new DateTime(a.year, a.month, a.day, a.hour, a.minute, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, b.day, b.hour, b.minute, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.SECOND) {
        a = new DateTime(a.year, a.month, a.day, a.hour, a.minute, a.second, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, b.day, b.hour, b.minute, b.second, 0, b.timezoneOffset);
      }
      if (unitField === DateTime.Unit.YEAR || unitField === DateTime.Unit.MONTH) {
        return a.durationBetween(b, unitField);
      } else {
        aUncertainty = a.toUncertainty();
        bUncertainty = b.toUncertainty();
        aLowMoment = moment(aUncertainty.low).utc();
        aHighMoment = moment(aUncertainty.high).utc();
        bLowMoment = moment(bUncertainty.low).utc();
        bHighMoment = moment(bUncertainty.high).utc();
        return new Uncertainty(bLowMoment.diff(aHighMoment, unitField + 's'), bHighMoment.diff(aLowMoment, unitField + 's'));
      }
    };

    DateTime.prototype._floorWeek = function(d) {
      var floored;
      if (d.day == null) {
        return d;
      }
      floored = new jsDate(d.year, d.month - 1, d.day);
      while (floored.getDay() > 0) {
        floored.setDate(floored.getDate() - 1);
      }
      return new DateTime(floored.getFullYear(), floored.getMonth() + 1, floored.getDate(), 12, 0, 0, 0, d.timezoneOffset);
    };

    DateTime.prototype.durationBetween = function(other, unitField) {
      var a, b;
      other = this._implicitlyConvert(other);
      if (!(other != null ? other.isDateTime : void 0)) {
        return null;
      }
      a = this.toUncertainty();
      b = other.toUncertainty();
      return new Uncertainty(this._durationBetweenDates(a.high, b.low, unitField), this._durationBetweenDates(a.low, b.high, unitField));
    };

    DateTime.prototype._durationBetweenDates = function(a, b, unitField) {
      var aInMonth, aInMonthOriginalOffset, months, msDiff, truncFunc;
      msDiff = b.getTime() - a.getTime();
      if (msDiff === 0) {
        return 0;
      }
      truncFunc = msDiff > 0 ? Math.floor : Math.ceil;
      if (unitField === DateTime.Unit.MILLISECOND) {
        return msDiff;
      } else if (unitField === DateTime.Unit.SECOND) {
        return truncFunc(msDiff / 1000);
      } else if (unitField === DateTime.Unit.MINUTE) {
        return truncFunc(msDiff / (60 * 1000));
      } else if (unitField === DateTime.Unit.HOUR) {
        return truncFunc(msDiff / (60 * 60 * 1000));
      } else if (unitField === DateTime.Unit.DAY) {
        return truncFunc(msDiff / (24 * 60 * 60 * 1000));
      } else if (unitField === DateTime.Unit.WEEK) {
        return truncFunc(msDiff / (7 * 24 * 60 * 60 * 1000));
      } else if (unitField === DateTime.Unit.MONTH || unitField === DateTime.Unit.YEAR) {
        months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
        aInMonth = new jsDate(a.getTime());
        aInMonthOriginalOffset = aInMonth.getTimezoneOffset();
        aInMonth.setMonth(a.getMonth() + months);
        if (aInMonthOriginalOffset !== aInMonth.getTimezoneOffset()) {
          aInMonth.setMinutes(aInMonth.getMinutes() + (aInMonthOriginalOffset - aInMonth.getTimezoneOffset()));
        }
        if (msDiff > 0 && aInMonth > b) {
          months = months - 1;
        } else if (msDiff < 0 && aInMonth < b) {
          months = months + 1;
        }
        if (unitField === DateTime.Unit.MONTH) {
          return months;
        } else {
          return truncFunc(months / 12);
        }
      } else {
        return null;
      }
    };

    DateTime.prototype.isUTC = function() {
      return !this.timezoneOffset;
    };

    DateTime.prototype.getPrecision = function() {
      var result;
      result = null;
      if (this.year != null) {
        result = DateTime.Unit.YEAR;
      } else {
        return result;
      }
      if (this.month != null) {
        result = DateTime.Unit.MONTH;
      } else {
        return result;
      }
      if (this.day != null) {
        result = DateTime.Unit.DAY;
      } else {
        return result;
      }
      if (this.hour != null) {
        result = DateTime.Unit.HOUR;
      } else {
        return result;
      }
      if (this.minute != null) {
        result = DateTime.Unit.MINUTE;
      } else {
        return result;
      }
      if (this.second != null) {
        result = DateTime.Unit.SECOND;
      } else {
        return result;
      }
      if (this.millisecond != null) {
        result = DateTime.Unit.MILLISECOND;
      }
      return result;
    };

    DateTime.prototype.toUncertainty = function(ignoreTimezone) {
      var high, low, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      if (ignoreTimezone == null) {
        ignoreTimezone = false;
      }
      low = this.toJSDate(ignoreTimezone);
      high = (new DateTime(this.year, (ref1 = this.month) != null ? ref1 : 12, (ref2 = this.day) != null ? ref2 : (new jsDate(this.year, (ref3 = this.month) != null ? ref3 : 12, 0)).getDate(), (ref4 = this.hour) != null ? ref4 : 23, (ref5 = this.minute) != null ? ref5 : 59, (ref6 = this.second) != null ? ref6 : 59, (ref7 = this.millisecond) != null ? ref7 : 999, this.timezoneOffset)).toJSDate(ignoreTimezone);
      return new Uncertainty(low, high);
    };

    DateTime.prototype.toJSDate = function(ignoreTimezone) {
      var d, date, h, mi, mo, ms, ref1, ref2, ref3, ref4, ref5, ref6, s, y;
      if (ignoreTimezone == null) {
        ignoreTimezone = false;
      }
      ref6 = [this.year, (this.month != null ? this.month - 1 : 0), (ref1 = this.day) != null ? ref1 : 1, (ref2 = this.hour) != null ? ref2 : 0, (ref3 = this.minute) != null ? ref3 : 0, (ref4 = this.second) != null ? ref4 : 0, (ref5 = this.millisecond) != null ? ref5 : 0], y = ref6[0], mo = ref6[1], d = ref6[2], h = ref6[3], mi = ref6[4], s = ref6[5], ms = ref6[6];
      if ((this.timezoneOffset != null) && !ignoreTimezone) {
        date = new jsDate(jsDate.UTC(y, mo, d, h, mi, s, ms) - (this.timezoneOffset * 60 * 60 * 1000));
        if (y < 100) {
          date.setUTCFullYear(y);
        }
        return date;
      } else {
        date = new jsDate(y, mo, d, h, mi, s, ms);
        if (y < 100) {
          date.setFullYear(y);
        }
        return date;
      }
    };

    DateTime.prototype.toJSON = function() {
      return this.toString();
    };

    DateTime.prototype._pad = function(num) {
      return String("0" + num).slice(-2);
    };

    DateTime.prototype.toString = function() {
      if (this.isTime()) {
        return this.toStringTime();
      } else {
        return this.toStringDateTime();
      }
    };

    DateTime.prototype.toStringTime = function() {
      var str;
      str = '';
      if (this.hour != null) {
        str += +this._pad(this.hour);
        if (this.minute != null) {
          str += ':' + this._pad(this.minute);
          if (this.second != null) {
            str += ':' + this._pad(this.second);
            if (this.millisecond != null) {
              str += '.' + String("00" + this.millisecond).slice(-3);
            }
          }
        }
      }
      return str;
    };

    DateTime.prototype.toStringDateTime = function() {
      var offsetHours, offsetMin, str;
      str = '';
      if (this.year != null) {
        str += this.year;
        if (this.month != null) {
          str += '-' + this._pad(this.month);
          if (this.day != null) {
            str += '-' + this._pad(this.day);
            if (this.hour != null) {
              str += 'T' + this._pad(this.hour);
              if (this.minute != null) {
                str += ':' + this._pad(this.minute);
                if (this.second != null) {
                  str += ':' + this._pad(this.second);
                  if (this.millisecond != null) {
                    str += '.' + String("00" + this.millisecond).slice(-3);
                  }
                }
              }
            }
          }
        }
      }
      if (str.indexOf('T') !== -1 && (this.timezoneOffset != null)) {
        str += this.timezoneOffset < 0 ? '-' : '+';
        offsetHours = Math.floor(Math.abs(this.timezoneOffset));
        str += this._pad(offsetHours);
        offsetMin = (Math.abs(this.timezoneOffset) - offsetHours) * 60;
        str += ':' + this._pad(offsetMin);
      }
      return str;
    };

    DateTime.prototype.getDateTime = function() {
      return this;
    };

    DateTime.prototype.getDate = function() {
      return new Date(this.year, this.month, this.day);
    };

    DateTime.prototype.getTime = function() {
      return new DateTime(0, 1, 1, this.hour, this.minute, this.second, this.millisecond, null);
    };

    DateTime.prototype.isTime = function() {
      return this.year === 0 && this.month === 1 && this.day === 1;
    };

    DateTime.prototype._implicitlyConvert = function(other) {
      if ((other != null ? other.isDate : void 0)) {
        return other.getDateTime();
      }
      return other;
    };

    DateTime.prototype.reducedPrecision = function(unitField) {
      var field, fieldIndex, fieldsToRemove, i, len, reduced;
      if (unitField == null) {
        unitField = DateTime.Unit.MILLISECOND;
      }
      reduced = this.copy();
      if (unitField !== DateTime.Unit.MILLISECOND) {
        fieldIndex = DateTime.FIELDS.indexOf(unitField);
        fieldsToRemove = DateTime.FIELDS.slice(fieldIndex + 1);
        for (i = 0, len = fieldsToRemove.length; i < len; i++) {
          field = fieldsToRemove[i];
          reduced[field] = null;
        }
      }
      return reduced;
    };

    return DateTime;

  })();

  Date = (function() {
    Object.defineProperties(Date.prototype, {
      isDate: {
        get: function() {
          return true;
        }
      }
    });

    Date.Unit = {
      YEAR: 'year',
      MONTH: 'month',
      WEEK: 'week',
      DAY: 'day'
    };

    Date.FIELDS = [Date.Unit.YEAR, Date.Unit.MONTH, Date.Unit.DAY];

    Date.parse = function(string) {
      var arg, args, days, matches, months, years;
      if (string === null) {
        return null;
      }
      matches = /(\d{4})(-(\d{2}))?(-(\d{2}))?/.exec(string);
      if (matches == null) {
        return null;
      }
      years = matches[1];
      months = matches[3];
      days = matches[5];
      if (!isValidDateStringFormat(string)) {
        return null;
      }
      args = [years, months, days];
      args = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          results.push(arg != null ? parseInt(arg, 10) : void 0);
        }
        return results;
      })();
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Date, args, function(){});
    };

    function Date(year1, month1, day) {
      this.year = year1 != null ? year1 : null;
      this.month = month1 != null ? month1 : null;
      this.day = day != null ? day : null;
      return;
    }

    Date.prototype.copy = function() {
      return new Date(this.year, this.month, this.day);
    };

    Date.prototype.successor = function() {
      if (this.day != null) {
        return this.add(1, Date.Unit.DAY);
      } else if (this.month != null) {
        return this.add(1, Date.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(1, Date.Unit.YEAR);
      }
    };

    Date.prototype.predecessor = function() {
      if (this.day != null) {
        return this.add(-1, Date.Unit.DAY);
      } else if (this.month != null) {
        return this.add(-1, Date.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(-1, Date.Unit.YEAR);
      }
    };

    Date.prototype.differenceBetween = function(other, unitField) {
      var a, b;
      if ((other != null ? other.isDateTime : void 0)) {
        return this.getDateTime().differenceBetween(other, unitField);
      }
      if (!(other != null ? other.isDate : void 0)) {
        return null;
      }
      a = this;
      b = other;
      if (unitField === Date.Unit.YEAR) {
        a = new Date(a.year, 1, 1);
        b = new Date(b.year, 1, 1);
      } else if (unitField === Date.Unit.MONTH) {
        a = new Date(a.year, a.month, 1);
        b = new Date(b.year, b.month, 1);
      } else if (unitField === Date.Unit.WEEK) {
        a = this._floorWeek(a);
        b = this._floorWeek(b);
      }
      return a.durationBetween(b, unitField);
    };

    Date.prototype._floorWeek = function(d) {
      var floored;
      if (d.day == null) {
        return d;
      }
      floored = new jsDate(d.year, d.month - 1, d.day);
      while (floored.getDay() > 0) {
        floored.setDate(floored.getDate() - 1);
      }
      return new Date(floored.getFullYear(), floored.getMonth() + 1, floored.getDate());
    };

    Date.prototype.durationBetween = function(other, unitField) {
      var a, b;
      if ((other != null ? other.isDateTime : void 0)) {
        return this.getDateTime().durationBetween(other, unitField);
      }
      if (!(other != null ? other.isDate : void 0)) {
        return null;
      }
      a = this.toUncertainty();
      b = other.toUncertainty();
      return new Uncertainty(this._durationBetweenDates(a.high, b.low, unitField), this._durationBetweenDates(a.low, b.high, unitField));
    };

    Date.prototype._durationBetweenDates = function(a, b, unitField) {
      var aInMonth, aInMonthOriginalOffset, months, msDiff, truncFunc, tzdiff;
      a.setTime(a.getTime() + (12 * 60 * 60 * 1000));
      b.setTime(b.getTime() + (12 * 60 * 60 * 1000));
      tzdiff = a.getTimezoneOffset() - b.getTimezoneOffset();
      b.setTime(b.getTime() + (tzdiff * 60 * 1000));
      msDiff = b.getTime() - a.getTime();
      if (msDiff === 0) {
        return 0;
      }
      truncFunc = msDiff > 0 ? Math.floor : Math.ceil;
      if (unitField === Date.Unit.DAY) {
        return truncFunc(msDiff / (24 * 60 * 60 * 1000));
      } else if (unitField === Date.Unit.WEEK) {
        return truncFunc(msDiff / (7 * 24 * 60 * 60 * 1000));
      } else if (unitField === Date.Unit.MONTH || unitField === Date.Unit.YEAR) {
        months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
        aInMonth = new jsDate(a.getTime());
        aInMonthOriginalOffset = aInMonth.getTimezoneOffset();
        aInMonth.setMonth(a.getMonth() + months);
        if (aInMonthOriginalOffset !== aInMonth.getTimezoneOffset()) {
          aInMonth.setMinutes(aInMonth.getMinutes() + (aInMonthOriginalOffset - aInMonth.getTimezoneOffset()));
        }
        if (msDiff > 0 && aInMonth > b) {
          months = months - 1;
        } else if (msDiff < 0 && aInMonth < b) {
          months = months + 1;
        }
        if (unitField === Date.Unit.MONTH) {
          return months;
        } else {
          return truncFunc(months / 12);
        }
      } else {
        return null;
      }
    };

    Date.prototype.getPrecision = function() {
      var result;
      result = null;
      if (this.year != null) {
        result = Date.Unit.YEAR;
      } else {
        return result;
      }
      if (this.month != null) {
        result = Date.Unit.MONTH;
      } else {
        return result;
      }
      if (this.day != null) {
        result = Date.Unit.DAY;
      } else {
        return result;
      }
      return result;
    };

    Date.prototype.toUncertainty = function() {
      var high, low, ref1, ref2, ref3;
      low = this.toJSDate();
      high = new Date(this.year, (ref1 = this.month) != null ? ref1 : 12, (ref2 = this.day) != null ? ref2 : (new jsDate(this.year, (ref3 = this.month) != null ? ref3 : 12, 0)).getDate()).toJSDate();
      return new Uncertainty(low, high);
    };

    Date.prototype.toJSDate = function() {
      var d, mo, ref1, ref2, y;
      ref2 = [this.year, (this.month != null ? this.month - 1 : 0), (ref1 = this.day) != null ? ref1 : 1], y = ref2[0], mo = ref2[1], d = ref2[2];
      return new jsDate(y, mo, d);
    };

    Date.fromJSDate = function(date) {
      if (date instanceof Date) {
        return date;
      }
      return new Date(date.getFullYear(), date.getMonth() + 1, date.getDate());
    };

    Date.prototype.toJSON = function() {
      return this.toString();
    };

    Date.prototype.toString = function() {
      var str;
      str = '';
      if (this.year != null) {
        str += this.year.toString();
        if (this.month != null) {
          str += '-' + this.month.toString().padStart(2, "0");
          if (this.day != null) {
            str += '-' + this.day.toString().padStart(2, "0");
          }
        }
      }
      return str;
    };

    Date.prototype.getDateTime = function() {
      if ((this.year != null) && (this.month != null) && (this.day != null)) {
        return new DateTime(this.year, this.month, this.day, 0, 0, 0, 0);
      } else {
        return new DateTime(this.year, this.month, this.day);
      }
    };

    Date.prototype.reducedPrecision = function(unitField) {
      var field, fieldIndex, fieldsToRemove, i, len, reduced;
      if (unitField == null) {
        unitField = Date.Unit.DAY;
      }
      reduced = this.copy();
      if (unitField !== Date.Unit.DAY) {
        fieldIndex = Date.FIELDS.indexOf(unitField);
        fieldsToRemove = Date.FIELDS.slice(fieldIndex + 1);
        for (i = 0, len = fieldsToRemove.length; i < len; i++) {
          field = fieldsToRemove[i];
          reduced[field] = null;
        }
      }
      return reduced;
    };

    return Date;

  })();

  DateTime.prototype.isPrecise = Date.prototype.isPrecise = function() {
    return this.constructor.FIELDS.every((function(_this) {
      return function(field) {
        return _this[field] != null;
      };
    })(this));
  };

  DateTime.prototype.isImprecise = Date.prototype.isImprecise = function() {
    return !this.isPrecise();
  };

  DateTime.prototype.isMorePrecise = Date.prototype.isMorePrecise = function(other) {
    var field, i, len, ref1;
    if (typeof other === 'string' && indexOf.call(this.constructor.FIELDS, other) >= 0) {
      if (this[other] == null) {
        return false;
      }
    } else {
      ref1 = this.constructor.FIELDS;
      for (i = 0, len = ref1.length; i < len; i++) {
        field = ref1[i];
        if ((other[field] != null) && (this[field] == null)) {
          return false;
        }
      }
    }
    return !this.isSamePrecision(other);
  };

  DateTime.prototype.isLessPrecise = Date.prototype.isLessPrecise = function(other) {
    return !this.isSamePrecision(other) && !this.isMorePrecise(other);
  };

  DateTime.prototype.isSamePrecision = Date.prototype.isSamePrecision = function(other) {
    var field, i, len, ref1;
    if (typeof other === 'string' && indexOf.call(this.constructor.FIELDS, other) >= 0) {
      return other === this.getPrecision();
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] == null)) {
        return false;
      }
      if ((this[field] == null) && (other[field] != null)) {
        return false;
      }
    }
    return true;
  };

  DateTime.prototype.equals = Date.prototype.equals = function(other) {
    return compareWithDefaultResult(this, other, null);
  };

  DateTime.prototype.equivalent = Date.prototype.equivalent = function(other) {
    return compareWithDefaultResult(this, other, false);
  };

  DateTime.prototype.sameAs = Date.prototype.sameAs = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().sameAs(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] !== other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return true;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return true;
  };

  DateTime.prototype.sameOrBefore = Date.prototype.sameOrBefore = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().sameOrBefore(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] < other[field]) {
          return true;
        } else if (this[field] > other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return true;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return true;
  };

  DateTime.prototype.sameOrAfter = Date.prototype.sameOrAfter = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().sameOrAfter(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] > other[field]) {
          return true;
        } else if (this[field] < other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return true;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return true;
  };

  DateTime.prototype.before = Date.prototype.before = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().before(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] < other[field]) {
          return true;
        } else if (this[field] > other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return false;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return false;
  };

  DateTime.prototype.after = Date.prototype.after = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().after(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] > other[field]) {
          return true;
        } else if (this[field] < other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return false;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return false;
  };

  DateTime.prototype.add = Date.prototype.add = function(offset, field) {
    var f, fieldFloorOrCiel, i, j, k, len, len1, len2, normalized, offsetIsMorePrecise, ref1, ref2, ref3, ref4, result;
    result = this.copy();
    if (offset === 0) {
      return result;
    }
    if (field === this.constructor.Unit.WEEK) {
      offset = offset * 7;
      field = this.constructor.Unit.DAY;
    }
    offsetIsMorePrecise = result[field] == null;
    if (offsetIsMorePrecise) {
      if (this.year == null) {
        result.year = new jsDate().getFullYear();
      }
      fieldFloorOrCiel = offset >= 0 ? this.getFieldFloor : this.getFieldCieling;
      ref1 = this.constructor.FIELDS;
      for (i = 0, len = ref1.length; i < len; i++) {
        f = ref1[i];
        result[f] = (ref2 = result[f]) != null ? ref2 : fieldFloorOrCiel.call(result, f);
        if (result[field] != null) {
          break;
        }
      }
    }
    result[field] = result[field] + offset;
    normalized = this.constructor.fromJSDate(result.toJSDate(), this.timezoneOffset);
    ref3 = this.constructor.FIELDS;
    for (j = 0, len1 = ref3.length; j < len1; j++) {
      field = ref3[j];
      if (result[field] != null) {
        result[field] = normalized[field];
      }
    }
    if (offsetIsMorePrecise) {
      ref4 = this.constructor.FIELDS;
      for (k = 0, len2 = ref4.length; k < len2; k++) {
        f = ref4[k];
        if (this[f] == null) {
          result[f] = null;
        }
      }
    }
    if (result.after(MAX_DATETIME_VALUE || result.before(MIN_DATETIME_VALUE))) {
      return null;
    } else {
      return result;
    }
  };

  DateTime.prototype.getFieldFloor = Date.prototype.getFieldFloor = function(field) {
    if (field === 'month') {
      return 1;
    }
    if (field === 'day') {
      return 1;
    }
    if (field === 'hour') {
      return 0;
    }
    if (field === 'minute') {
      return 0;
    }
    if (field === 'second') {
      return 0;
    }
    if (field === 'millisecond') {
      return 0;
    }
    throw new Error('Tried to floor a field that has no floor value: ' + field);
  };

  DateTime.prototype.getFieldCieling = Date.prototype.getFieldCieling = function(field) {
    if (field === 'month') {
      return 12;
    }
    if (field === 'day') {
      return daysInMonth(this.year, this.month);
    }
    if (field === 'hour') {
      return 23;
    }
    if (field === 'minute') {
      return 59;
    }
    if (field === 'second') {
      return 59;
    }
    if (field === 'millisecond') {
      return 999;
    }
    throw new Error('Tried to clieling a field that has no cieling value: ' + field);
  };

  compareWithDefaultResult = function(a, b, defaultResult) {
    var aMillisecond, aSecondAndMillisecond, bMillisecond, bSecondAndMillisecond, field, i, len, ref1;
    if (!((a.isDate && b.isDate) || (a.isDateTime && b.isDateTime))) {
      return false;
    }
    if (a.timezoneOffset !== b.timezoneOffset) {
      b = b.convertToTimezoneOffset(a.timezoneOffset);
    }
    ref1 = a.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((a[field] != null) && (b[field] != null)) {
        if (field === 'second') {
          aMillisecond = a['millisecond'] != null ? a['millisecond'] : 0;
          aSecondAndMillisecond = a[field] + aMillisecond / 1000;
          bMillisecond = b['millisecond'] != null ? b['millisecond'] : 0;
          bSecondAndMillisecond = b[field] + bMillisecond / 1000;
          return aSecondAndMillisecond === bSecondAndMillisecond;
        }
        if (a[field] !== b[field]) {
          return false;
        }
      } else if ((a[field] == null) && (b[field] == null)) {
        return true;
      } else {
        return defaultResult;
      }
    }
    return true;
  };

  daysInMonth = function(year, month) {
    if (!((year != null) && (month != null))) {
      throw new Error('daysInMonth requires year and month as arguments');
    }
    return new jsDate(year, month, 0).getDate();
  };

  normalizeMillisecondsField = function(msString) {
    return msString = (msString + "00").substring(0, 3);
  };

  isValidDateStringFormat = function(string) {
    var cqlFormatStringWithLength, cqlFormats, format, i, len, strict;
    if (typeof string !== 'string') {
      return false;
    }
    cqlFormats = ['YYYY', 'YYYY-MM', 'YYYY-MM-DD'];
    cqlFormatStringWithLength = {};
    for (i = 0, len = cqlFormats.length; i < len; i++) {
      format = cqlFormats[i];
      cqlFormatStringWithLength[format.length] = format;
    }
    if (cqlFormatStringWithLength[string.length] == null) {
      return false;
    }
    strict = true;
    return moment(string, cqlFormatStringWithLength[string.length], strict).isValid();
  };

  isValidDateTimeStringFormat = function(string) {
    var cqlFormatStringWithLength, cqlFormats, format, i, len, strict;
    if (typeof string !== 'string') {
      return false;
    }
    cqlFormats = ['YYYY', 'YYYY-MM', 'YYYY-MM-DD', 'YYYY-MM-DDTZ', 'YYYY-MM-DDT+hh', 'YYYY-MM-DDT+hh:mm', 'YYYY-MM-DDT-hh', 'YYYY-MM-DDT-hh:mm', 'YYYY-MM-DDThh', 'YYYY-MM-DDThhZ', 'YYYY-MM-DDThh+hh', 'YYYY-MM-DDThh+hh:mm', 'YYYY-MM-DDThh-hh', 'YYYY-MM-DDThh-hh:mm', 'YYYY-MM-DDThh:mm', 'YYYY-MM-DDThh:mmZ', 'YYYY-MM-DDThh:mm+hh', 'YYYY-MM-DDThh:mm+hh:mm', 'YYYY-MM-DDThh:mm-hh', 'YYYY-MM-DDThh:mm-hh:mm', 'YYYY-MM-DDThh:mm:ss', 'YYYY-MM-DDThh:mm:ssZ', 'YYYY-MM-DDThh:mm:ss+hh', 'YYYY-MM-DDThh:mm:ss+hh:mm', 'YYYY-MM-DDThh:mm:ss-hh', 'YYYY-MM-DDThh:mm:ss-hh:mm', 'YYYY-MM-DDThh:mm:ss.fff', 'YYYY-MM-DDThh:mm:ss.fffZ', 'YYYY-MM-DDThh:mm:ss.fff+hh', 'YYYY-MM-DDThh:mm:ss.fff+hh:mm', 'YYYY-MM-DDThh:mm:ss.fff-hh', 'YYYY-MM-DDThh:mm:ss.fff-hh:mm'];
    cqlFormatStringWithLength = {};
    for (i = 0, len = cqlFormats.length; i < len; i++) {
      format = cqlFormats[i];
      cqlFormatStringWithLength[format.length] = format;
    }
    if (cqlFormatStringWithLength[string.length] == null) {
      return false;
    }
    strict = false;
    return moment(string, cqlFormatStringToMomentFormatString(cqlFormatStringWithLength[string.length]), strict).isValid();
  };

  cqlFormatStringToMomentFormatString = function(string) {
    var momentString, ref1, timeAndTimeZoneOffset, timezoneSeparator, yearMonthDay;
    ref1 = string.split('T'), yearMonthDay = ref1[0], timeAndTimeZoneOffset = ref1[1];
    if (timeAndTimeZoneOffset != null) {
      timezoneSeparator = getTimezoneSeparatorFromString(timeAndTimeZoneOffset);
    }
    momentString = yearMonthDay;
    if (string.match(/T/) != null) {
      momentString += '[T]';
    }
    if (!!timezoneSeparator) {
      momentString += timeAndTimeZoneOffset.substring(0, timeAndTimeZoneOffset.search(timezoneSeparator)) + '[Z]';
    } else {
      momentString += timeAndTimeZoneOffset;
    }
    return momentString = momentString.replace(/f/g, 'S');
  };

  MIN_DATETIME_VALUE = DateTime.parse("0001-01-01T00:00:00.000");

  MAX_DATETIME_VALUE = DateTime.parse("9999-12-31T23:59:59.999");

  module.exports.DateTime = DateTime;

  module.exports.Date = Date;

}).call(this);



},{"../util/util":47,"./uncertainty":12,"moment":48}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Exception;

  module.exports.Exception = Exception = (function() {
    function Exception(message, wrapped) {
      this.message = message;
      this.wrapped = wrapped;
    }

    return Exception;

  })();

}).call(this);



},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var DateTime, Interval, Quantity, ThreeValuedLogic, Uncertainty, cmp, doSubtraction, maxValueForInstance, minValueForInstance, predecessor, ref, ref1, successor;

  DateTime = require('./datetime').DateTime;

  Uncertainty = require('./uncertainty').Uncertainty;

  ref = require('../datatypes/quantity'), Quantity = ref.Quantity, doSubtraction = ref.doSubtraction;

  ThreeValuedLogic = require('./logic').ThreeValuedLogic;

  ref1 = require('../util/math'), successor = ref1.successor, predecessor = ref1.predecessor, maxValueForInstance = ref1.maxValueForInstance, minValueForInstance = ref1.minValueForInstance;

  cmp = require('../util/comparison');

  module.exports.Interval = Interval = (function() {
    var areDateTimes, areNumeric, highestNumericUncertainty, lowestNumericUncertainty;

    function Interval(low1, high1, lowClosed, highClosed) {
      this.low = low1;
      this.high = high1;
      this.lowClosed = lowClosed != null ? lowClosed : true;
      this.highClosed = highClosed != null ? highClosed : true;
    }

    Object.defineProperties(Interval.prototype, {
      isInterval: {
        get: function() {
          return true;
        }
      }
    });

    Interval.prototype.copy = function() {
      var newHigh, newLow;
      newLow = this.low;
      newHigh = this.high;
      if ((this.low != null) && typeof this.low.copy === 'function') {
        newLow = this.low.copy();
      }
      if ((this.high != null) && typeof this.high.copy === 'function') {
        newHigh = this.high.copy();
      }
      return new Interval(newLow, newHigh, this.lowClosed, this.highClosed);
    };

    Interval.prototype.contains = function(item, precision) {
      var highFn, lowFn;
      if (this.lowClosed && (this.low != null) && cmp.equals(this.low, item)) {
        return true;
      }
      if (this.highClosed && (this.high != null) && cmp.equals(this.high, item)) {
        return true;
      }
      if (item != null ? item.isInterval : void 0) {
        throw new Error("Argument to contains must be a point");
      }
      lowFn = (function() {
        switch (false) {
          case !(this.lowClosed && (this.low == null)):
            return function() {
              return true;
            };
          case !this.lowClosed:
            return cmp.lessThanOrEquals;
          default:
            return cmp.lessThan;
        }
      }).call(this);
      highFn = (function() {
        switch (false) {
          case !(this.highClosed && (this.high == null)):
            return function() {
              return true;
            };
          case !this.highClosed:
            return cmp.greaterThanOrEquals;
          default:
            return cmp.greaterThan;
        }
      }).call(this);
      return ThreeValuedLogic.and(lowFn(this.low, item, precision), highFn(this.high, item, precision));
    };

    Interval.prototype.properlyIncludes = function(other, precision) {
      if (!(other != null ? other.isInterval : void 0)) {
        throw new Error("Argument to properlyIncludes must be an interval");
      }
      return ThreeValuedLogic.and(this.includes(other, precision), ThreeValuedLogic.not(other.includes(this, precision)));
    };

    Interval.prototype.includes = function(other, precision) {
      var a, b;
      if (!(other != null ? other.isInterval : void 0)) {
        return this.contains(other, precision);
      }
      a = this.toClosed();
      b = other.toClosed();
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(a.low, b.low, precision), cmp.greaterThanOrEquals(a.high, b.high, precision));
    };

    Interval.prototype.includedIn = function(other, precision) {
      if (!(other != null ? other.isInterval : void 0)) {
        return this.contains(other, precision);
      } else {
        return other.includes(this);
      }
    };

    Interval.prototype.overlaps = function(item, precision) {
      var closed, high, itemClosed, low, ref2;
      closed = this.toClosed();
      ref2 = (item != null ? item.isInterval : void 0) ? (itemClosed = item.toClosed(), [itemClosed.low, itemClosed.high]) : [item, item], low = ref2[0], high = ref2[1];
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(closed.low, high, precision), cmp.greaterThanOrEquals(closed.high, low, precision));
    };

    Interval.prototype.overlapsAfter = function(item, precision) {
      var closed, high;
      closed = this.toClosed();
      high = (item != null ? item.isInterval : void 0) ? item.toClosed().high : item;
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(closed.low, high, precision), cmp.greaterThan(closed.high, high, precision));
    };

    Interval.prototype.overlapsBefore = function(item, precision) {
      var closed, low;
      closed = this.toClosed();
      low = (item != null ? item.isInterval : void 0) ? item.toClosed().low : item;
      return ThreeValuedLogic.and(cmp.lessThan(closed.low, low, precision), cmp.greaterThanOrEquals(closed.high, low, precision));
    };

    areDateTimes = function(x, y) {
      return [x, y].every(function(z) {
        return z != null ? z.isDateTime : void 0;
      });
    };

    areNumeric = function(x, y) {
      return [x, y].every(function(z) {
        return typeof z === 'number' || ((z != null ? z.isUncertainty : void 0) && typeof z.low === 'number');
      });
    };

    lowestNumericUncertainty = function(x, y) {
      var high, low;
      if (!(x != null ? x.isUncertainty : void 0)) {
        x = new Uncertainty(x);
      }
      if (!(y != null ? y.isUncertainty : void 0)) {
        y = new Uncertainty(y);
      }
      low = x.low < y.low ? x.low : y.low;
      high = x.high < y.high ? x.high : y.high;
      if (low !== high) {
        return new Uncertainty(low, high);
      } else {
        return low;
      }
    };

    highestNumericUncertainty = function(x, y) {
      var high, low;
      if (!(x != null ? x.isUncertainty : void 0)) {
        x = new Uncertainty(x);
      }
      if (!(y != null ? y.isUncertainty : void 0)) {
        y = new Uncertainty(y);
      }
      low = x.low > y.low ? x.low : y.low;
      high = x.high > y.high ? x.high : y.high;
      if (low !== high) {
        return new Uncertainty(low, high);
      } else {
        return low;
      }
    };

    Interval.prototype.union = function(other) {
      var a, b, h, hc, l, lc, ref2, ref3, ref4;
      if (!(other != null ? other.isInterval : void 0)) {
        throw new Error("Argument to union must be an interval");
      }
      if (this.overlaps(other) || this.meets(other)) {
        ref2 = [this.toClosed(), other.toClosed()], a = ref2[0], b = ref2[1];
        ref3 = (function() {
          switch (false) {
            case !cmp.lessThanOrEquals(a.low, b.low):
              return [this.low, this.lowClosed];
            case !cmp.greaterThanOrEquals(a.low, b.low):
              return [other.low, other.lowClosed];
            case !areNumeric(a.low, b.low):
              return [lowestNumericUncertainty(a.low, b.low), true];
            case !(areDateTimes(a.low, b.low) && a.low.isMorePrecise(b.low)):
              return [other.low, other.lowClosed];
            default:
              return [this.low, this.lowClosed];
          }
        }).call(this), l = ref3[0], lc = ref3[1];
        ref4 = (function() {
          switch (false) {
            case !cmp.greaterThanOrEquals(a.high, b.high):
              return [this.high, this.highClosed];
            case !cmp.lessThanOrEquals(a.high, b.high):
              return [other.high, other.highClosed];
            case !areNumeric(a.high, b.high):
              return [highestNumericUncertainty(a.high, b.high), true];
            case !(areDateTimes(a.high, b.high) && a.high.isMorePrecise(b.high)):
              return [other.high, other.highClosed];
            default:
              return [this.high, this.highClosed];
          }
        }).call(this), h = ref4[0], hc = ref4[1];
        return new Interval(l, h, lc, hc);
      } else {
        return null;
      }
    };

    Interval.prototype.intersect = function(other) {
      var a, b, h, hc, l, lc, ref2, ref3, ref4;
      if (!(other != null ? other.isInterval : void 0)) {
        throw new Error("Argument to union must be an interval");
      }
      if (this.overlaps(other)) {
        ref2 = [this.toClosed(), other.toClosed()], a = ref2[0], b = ref2[1];
        ref3 = (function() {
          switch (false) {
            case !cmp.greaterThanOrEquals(a.low, b.low):
              return [this.low, this.lowClosed];
            case !cmp.lessThanOrEquals(a.low, b.low):
              return [other.low, other.lowClosed];
            case !areNumeric(a.low, b.low):
              return [highestNumericUncertainty(a.low, b.low), true];
            case !(areDateTimes(a.low, b.low) && b.low.isMorePrecise(a.low)):
              return [other.low, other.lowClosed];
            default:
              return [this.low, this.lowClosed];
          }
        }).call(this), l = ref3[0], lc = ref3[1];
        ref4 = (function() {
          switch (false) {
            case !cmp.lessThanOrEquals(a.high, b.high):
              return [this.high, this.highClosed];
            case !cmp.greaterThanOrEquals(a.high, b.high):
              return [other.high, other.highClosed];
            case !areNumeric(a.high, b.high):
              return [lowestNumericUncertainty(a.high, b.high), true];
            case !(areDateTimes(a.high, b.high) && b.high.isMorePrecise(a.high)):
              return [other.high, other.highClosed];
            default:
              return [this.high, this.highClosed];
          }
        }).call(this), h = ref4[0], hc = ref4[1];
        return new Interval(l, h, lc, hc);
      } else {
        return null;
      }
    };

    Interval.prototype.except = function(other) {
      var ol, ola, olb;
      if (other === null) {
        return null;
      }
      if (!(other != null ? other.isInterval : void 0)) {
        throw new Error("Argument to except must be an interval");
      }
      ol = this.overlaps(other);
      if (ol === true) {
        olb = this.overlapsBefore(other);
        ola = this.overlapsAfter(other);
        if (olb === true && ola === false) {
          return new Interval(this.low, other.low, this.lowClosed, !other.lowClosed);
        } else if (ola === true && olb === false) {
          return new Interval(other.high, this.high, !other.highClosed, this.highClosed);
        } else {
          return null;
        }
      } else if (ol === false) {
        return this;
      } else {
        return null;
      }
    };

    Interval.prototype.sameAs = function(other, precision) {
      if (((this.low != null) && (other.low != null) && (this.high == null) && (other.high != null) && !this.highClosed) || ((this.low != null) && (other.low != null) && (this.high != null) && (other.high == null) && !other.highClosed) || ((this.low != null) && (other.low != null) && (this.high == null) && (other.high == null) && !other.highClosed && !this.highClosed)) {
        if (typeof this.low === 'number') {
          if (!(this.start() === other.start())) {
            return false;
          }
        } else {
          if (!(this.start().sameAs(other.start(), precision))) {
            return false;
          }
        }
      } else if (((this.low != null) && (other.low == null) && (this.high != null) && (other.high != null)) || ((this.low == null) && (other.low != null) && (this.high != null) && (other.high != null)) || ((this.low == null) && (other.low == null) && (this.high != null) && (other.high != null))) {
        if (typeof this.high === 'number') {
          if (!(this.end() === other.end())) {
            return false;
          }
        } else {
          if (!(this.end().sameAs(other.end(), precision))) {
            return false;
          }
        }
      }
      if (((this.low == null) && !this.lowClosed) || ((this.high == null) && !this.highClosed) || ((other.low == null) && !other.lowClosed) || ((other.high == null) && !other.highClosed)) {
        return null;
      }
      if (this.lowClosed && (this.low == null) && this.highClosed && (this.high == null)) {
        return other.lowClosed && (other.low == null) && other.highClosed && (other.high == null);
      }
      if (other.lowClosed && (other.low == null) && other.highClosed && (other.high == null)) {
        return false;
      }
      if (typeof this.low === 'number') {
        return this.start() === other.start() && this.end() === other.end();
      } else {
        return this.start().sameAs(other.start(), precision) && this.end().sameAs(other.end(), precision);
      }
    };

    Interval.prototype.sameOrBefore = function(other, precision) {
      if ((this.end() == null) || ((other != null ? other.start() : void 0) == null)) {
        return null;
      } else {
        return this.end().sameOrBefore(other.start(), precision);
      }
    };

    Interval.prototype.sameOrAfter = function(other, precision) {
      if ((this.start() == null) || ((other != null ? other.end() : void 0) == null)) {
        return null;
      } else {
        return this.start().sameOrAfter(other.end(), precision);
      }
    };

    Interval.prototype.equals = function(other) {
      var a, b, ref2;
      if (other != null ? other.isInterval : void 0) {
        ref2 = [this.toClosed(), other.toClosed()], a = ref2[0], b = ref2[1];
        return ThreeValuedLogic.and(cmp.equals(a.low, b.low), cmp.equals(a.high, b.high));
      } else {
        return false;
      }
    };

    Interval.prototype.after = function(other, precision) {
      var closed;
      closed = this.toClosed();
      if (!!other.toClosed) {
        return cmp.greaterThan(closed.low, other.toClosed().high, precision);
      } else {
        return cmp.greaterThan(closed.low, other, precision);
      }
    };

    Interval.prototype.before = function(other, precision) {
      var closed;
      closed = this.toClosed();
      if (!!other.toClosed) {
        return cmp.lessThan(closed.high, other.toClosed().low, precision);
      } else {
        return cmp.lessThan(closed.high, other, precision);
      }
    };

    Interval.prototype.meets = function(other, precision) {
      return ThreeValuedLogic.or(this.meetsBefore(other, precision), this.meetsAfter(other, precision));
    };

    Interval.prototype.meetsAfter = function(other, precision) {
      var ref2, ref3;
      try {
        if ((precision != null) && ((ref2 = this.low) != null ? ref2.isDateTime : void 0)) {
          return this.toClosed().low.sameAs((ref3 = other.toClosed().high) != null ? ref3.add(1, precision) : void 0, precision);
        } else {
          return cmp.equals(this.toClosed().low, successor(other.toClosed().high));
        }
      } catch (error) {
        return false;
      }
    };

    Interval.prototype.meetsBefore = function(other, precision) {
      var ref2, ref3;
      try {
        if ((precision != null) && ((ref2 = this.high) != null ? ref2.isDateTime : void 0)) {
          return this.toClosed().high.sameAs((ref3 = other.toClosed().low) != null ? ref3.add(-1, precision) : void 0, precision);
        } else {
          return cmp.equals(this.toClosed().high, predecessor(other.toClosed().low));
        }
      } catch (error) {
        return false;
      }
    };

    Interval.prototype.start = function() {
      if (this.low == null) {
        if (this.lowClosed) {
          return minValueForInstance(this.high);
        } else {
          return this.low;
        }
      }
      return this.toClosed().low;
    };

    Interval.prototype.end = function() {
      if (this.high == null) {
        if (this.highClosed) {
          return maxValueForInstance(this.low);
        } else {
          return this.high;
        }
      }
      return this.toClosed().high;
    };

    Interval.prototype.starts = function(other, precision) {
      var endLessThanOrEqual, ref2, startEqual;
      if ((precision != null) && ((ref2 = this.low) != null ? ref2.isDateTime : void 0)) {
        startEqual = this.low.sameAs(other.low, precision);
      } else {
        startEqual = cmp.equals(this.low, other.low);
      }
      endLessThanOrEqual = cmp.lessThanOrEquals(this.high, other.high, precision);
      return startEqual && endLessThanOrEqual;
    };

    Interval.prototype.ends = function(other, precision) {
      var endEqual, ref2, startGreaterThanOrEqual;
      startGreaterThanOrEqual = cmp.greaterThanOrEquals(this.low, other.low, precision);
      if ((precision != null) && ((ref2 = this.low) != null ? ref2.isDateTime : void 0)) {
        endEqual = this.high.sameAs(other.high, precision);
      } else {
        endEqual = cmp.equals(this.high, other.high);
      }
      return startGreaterThanOrEqual && endEqual;
    };

    Interval.prototype.width = function() {
      var closed, diff, highValue, lowValue, ref2, ref3;
      if (((this.low != null) && (this.low.isDateTime || this.low.isDate || this.low.isTime)) || ((this.high != null) && (this.high.isDateTime || this.high.isDate || this.high.isTime))) {
        throw new Error("Width of Date, DateTime, and Time intervals is not supported");
      }
      closed = this.toClosed();
      if (((ref2 = closed.low) != null ? ref2.isUncertainty : void 0) || ((ref3 = closed.high) != null ? ref3.isUncertainty : void 0)) {
        return null;
      } else if (closed.low.isQuantity) {
        if (closed.low.unit !== closed.high.unit) {
          throw new Error("Cannot calculate width of Quantity Interval with different units");
        }
        lowValue = closed.low.value;
        highValue = closed.high.value;
        diff = Math.abs(highValue - lowValue);
        Math.round(diff * Math.pow(10, 8)) / Math.pow(10, 8);
        return new Quantity(diff, closed.low.unit);
      } else {
        diff = Math.abs(closed.high - closed.low);
        return Math.round(diff * Math.pow(10, 8)) / Math.pow(10, 8);
      }
    };

    Interval.prototype.size = function() {
      var closed, diff, highValue, lowValue, pointSize, ref2, ref3;
      pointSize = this.getPointSize();
      if (((this.low != null) && (this.low.isDateTime || this.low.isDate || this.low.isTime)) || ((this.high != null) && (this.high.isDateTime || this.high.isDate || this.high.isTime))) {
        throw new Error("Size of Date, DateTime, and Time intervals is not supported");
      }
      closed = this.toClosed();
      if (((ref2 = closed.low) != null ? ref2.isUncertainty : void 0) || ((ref3 = closed.high) != null ? ref3.isUncertainty : void 0)) {
        return null;
      } else if (closed.low.isQuantity) {
        if (closed.low.unit !== closed.high.unit) {
          throw new Error("Cannot calculate size of Quantity Interval with different units");
        }
        lowValue = closed.low.value;
        highValue = closed.high.value;
        diff = Math.abs(highValue - lowValue) + pointSize.value;
        Math.round(diff * Math.pow(10, 8)) / Math.pow(10, 8);
        return new Quantity(diff, closed.low.unit);
      } else {
        diff = Math.abs(closed.high - closed.low) + pointSize.value;
        return Math.round(diff * Math.pow(10, 8)) / Math.pow(10, 8);
      }
    };

    Interval.prototype.getPointSize = function() {
      var pointSize, precisionUnits;
      if (this.low != null) {
        if (this.low.isDateTime) {
          precisionUnits = this.low.getPrecision();
          pointSize = new Quantity(1, precisionUnits);
        } else if (this.low.isQuantity) {
          pointSize = doSubtraction(successor(this.low), this.low);
        } else {
          pointSize = successor(this.low) - this.low;
        }
      } else if (this.high != null) {
        if (this.high.isDateTime) {
          precisionUnits = this.high.getPrecision();
          pointSize = new Quantity(1, precisionUnits);
        } else if (this.high.isQuantity) {
          pointSize = doSubtraction(successor(this.high), this.high);
        } else {
          pointSize = successor(this.high) - this.high;
        }
      } else {
        throw new Error("Point type of intervals cannot be determined.");
      }
      if (typeof pointSize === 'number') {
        pointSize = new Quantity(pointSize, '1');
      }
      return pointSize;
    };

    Interval.prototype.toClosed = function() {
      var high, low, point, ref2;
      point = (ref2 = this.low) != null ? ref2 : this.high;
      if (typeof point === 'number' || (point != null ? point.isDateTime : void 0) || (point != null ? point.isQuantity : void 0) || (point != null ? point.isDate : void 0)) {
        low = (function() {
          switch (false) {
            case !(this.lowClosed && (this.low == null)):
              return minValueForInstance(point);
            case !(!this.lowClosed && (this.low != null)):
              return successor(this.low);
            default:
              return this.low;
          }
        }).call(this);
        high = (function() {
          switch (false) {
            case !(this.highClosed && (this.high == null)):
              return maxValueForInstance(point);
            case !(!this.highClosed && (this.high != null)):
              return predecessor(this.high);
            default:
              return this.high;
          }
        }).call(this);
        if (low == null) {
          low = new Uncertainty(minValueForInstance(point), high);
        }
        if (high == null) {
          high = new Uncertainty(low, maxValueForInstance(point));
        }
        return new Interval(low, high, true, true);
      } else {
        return new Interval(this.low, this.high, true, true);
      }
    };

    Interval.prototype.toString = function() {
      var end, start;
      start = this.lowClosed ? '[' : '(';
      end = this.highClosed ? ']' : ')';
      return start + this.low.toString() + ', ' + this.high.toString() + end;
    };

    return Interval;

  })();

}).call(this);



},{"../datatypes/quantity":10,"../util/comparison":45,"../util/math":46,"./datetime":6,"./logic":9,"./uncertainty":12}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var ThreeValuedLogic,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module.exports.ThreeValuedLogic = ThreeValuedLogic = (function() {
    function ThreeValuedLogic() {}

    ThreeValuedLogic.and = function() {
      var val;
      val = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (indexOf.call(val, false) >= 0) {
        return false;
      } else if (indexOf.call(val, null) >= 0) {
        return null;
      } else {
        return true;
      }
    };

    ThreeValuedLogic.or = function() {
      var val;
      val = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (indexOf.call(val, true) >= 0) {
        return true;
      } else if (indexOf.call(val, null) >= 0) {
        return null;
      } else {
        return false;
      }
    };

    ThreeValuedLogic.xor = function() {
      var val;
      val = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (indexOf.call(val, null) >= 0) {
        return null;
      } else {
        return val.reduce(function(a, b) {
          return (!a ^ !b) === 1;
        });
      }
    };

    ThreeValuedLogic.not = function(val) {
      if (val != null) {
        return !val;
      } else {
        return null;
      }
    };

    return ThreeValuedLogic;

  })();

}).call(this);



},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Quantity, clean_unit, coalesceToOne, convert_value, decimalAdjust, doScaledAddition, isValidDecimal, is_valid_ucum_unit, overflowsOrUnderflows, ref, ucum, ucum_multiply, ucum_time_units, ucum_to_cql_units, ucum_unit, unitValidityCache, units_to_string;

  ref = require('../util/math'), decimalAdjust = ref.decimalAdjust, isValidDecimal = ref.isValidDecimal, overflowsOrUnderflows = ref.overflowsOrUnderflows;

  ucum = require('ucum');

  module.exports.Quantity = Quantity = (function() {
    Object.defineProperties(Quantity.prototype, {
      isQuantity: {
        get: function() {
          return true;
        }
      }
    });

    function Quantity(value1, unit1) {
      this.value = value1;
      this.unit = unit1;
      if ((this.value == null) || isNaN(this.value)) {
        throw new Error("Cannot create a quantity with an undefined value");
      } else {
        if (!isValidDecimal(this.value)) {
          throw new Error("Cannot create a quantity with an invalid decimal value");
        }
      }
      if ((this.unit != null) && !is_valid_ucum_unit(this.unit)) {
        throw new Error("\'" + this.unit + "\' is not a valid UCUM unit.");
      }
    }

    Quantity.prototype.clone = function() {
      return new Quantity(this.value, this.unit);
    };

    Quantity.prototype.toString = function() {
      return this.value + " '" + this.unit + "'";
    };

    Quantity.prototype.sameOrBefore = function(other) {
      var other_v;
      if (other != null ? other.isQuantity : void 0) {
        other_v = convert_value(other.value, ucum_unit(other.unit), ucum_unit(this.unit));
        if (other_v == null) {
          return null;
        } else {
          return this.value <= other_v;
        }
      }
    };

    Quantity.prototype.sameOrAfter = function(other) {
      var other_v;
      if (other != null ? other.isQuantity : void 0) {
        other_v = convert_value(other.value, ucum_unit(other.unit), ucum_unit(this.unit));
        if (other_v == null) {
          return null;
        } else {
          return this.value >= other_v;
        }
      }
    };

    Quantity.prototype.after = function(other) {
      var other_v;
      if (other != null ? other.isQuantity : void 0) {
        other_v = convert_value(other.value, ucum_unit(other.unit), ucum_unit(this.unit));
        if (other_v == null) {
          return null;
        } else {
          return this.value > other_v;
        }
      }
    };

    Quantity.prototype.before = function(other) {
      var other_v;
      if (other != null ? other.isQuantity : void 0) {
        other_v = convert_value(other.value, ucum_unit(other.unit), ucum_unit(this.unit));
        if (other_v == null) {
          return null;
        } else {
          return this.value < other_v;
        }
      }
    };

    Quantity.prototype.equals = function(other) {
      var other_v;
      if (other != null ? other.isQuantity : void 0) {
        if ((!this.unit && other.unit) || (this.unit && !other.unit)) {
          return false;
        } else if (!this.unit && !other.unit) {
          return this.value === other.value;
        } else {
          other_v = convert_value(other.value, ucum_unit(other.unit), ucum_unit(this.unit));
          if (other_v == null) {
            return null;
          } else {
            return decimalAdjust("round", this.value, -8) === decimalAdjust("round", other_v, -8);
          }
        }
      }
    };

    Quantity.prototype.convertUnit = function(to_unit) {
      var unit, value;
      value = convert_value(this.value, this.unit, to_unit);
      unit = to_unit;
      return new Quantity(value, unit);
    };

    Quantity.prototype.dividedBy = function(other) {
      return this.multiplyDivide(other, "/");
    };

    Quantity.prototype.multiplyBy = function(other) {
      return this.multiplyDivide(other, ".");
    };

    Quantity.prototype.multiplyDivide = function(other, operator) {
      var a, b, can_val, other_can_value, ucum_value, value;
      if (other != null ? other.isQuantity : void 0) {
        a = this.unit != null ? this : new Quantity(this.value, '1');
        b = other.unit != null ? other : new Quantity(other.value, {
          unit: '1'
        });
        can_val = a.to_ucum();
        other_can_value = b.to_ucum();
        ucum_value = ucum_multiply(can_val, [[operator, other_can_value]]);
        if (overflowsOrUnderflows(ucum_value.value)) {
          return null;
        }
        try {
          return new Quantity(ucum_value.value, units_to_string(ucum_value.units));
        } catch (error) {
          return null;
        }
      } else {
        value = operator === "/" ? this.value / other : this.value * other;
        if (overflowsOrUnderflows(value)) {
          return null;
        }
        try {
          return new Quantity(decimalAdjust("round", value, -8), coalesceToOne(this.unit));
        } catch (error) {
          return null;
        }
      }
    };

    Quantity.prototype.to_ucum = function() {
      var u;
      u = ucum.parse(ucum_unit(this.unit));
      u.value *= this.value;
      return u;
    };

    return Quantity;

  })();

  clean_unit = function(units) {
    if (ucum_time_units[units]) {
      return ucum_to_cql_units[ucum_time_units[units]];
    } else {
      return units;
    }
  };

  ucum_time_units = {
    'years': 'a_g',
    'year': 'a_g',
    'YEARS': 'a_g',
    'YEAR': 'a_g',
    'a_g': 'a_g',
    'a': 'a_j',
    'ANN': 'a_j',
    'ann': 'a_j',
    'A': 'a_j',
    'a_j': 'a_j',
    'months': 'mo_g',
    'month': 'mo_g',
    'mo_g': 'mo_g',
    'mo': 'mo_j',
    'MO': 'mo_j',
    'mo_j': 'mo_j',
    'weeks': 'wk',
    'week': 'wk',
    'wk': 'wk',
    'WK': 'wk',
    'days': 'd',
    'day': 'd',
    'd': 'd',
    'D': 'd',
    'hours': 'h',
    'hour': 'h',
    'h': 'h',
    'H': 'h',
    'minutes': 'min',
    'minute': 'min',
    'min': 'min',
    'MIN': 'min',
    'seconds': 's',
    'second': 's',
    's': 's',
    'S': 's',
    'milliseconds': 'ms',
    'millisecond': 'ms',
    'ms': 'ms',
    'MS': 'ms'
  };

  ucum_to_cql_units = {
    'a_j': 'year',
    'a_g': 'year',
    'mo_j': 'month',
    'mo_g': 'month',
    'wk': 'week',
    'd': 'day',
    'h': 'hour',
    'min': 'minute',
    's': 'second',
    'ms': 'millisecond'
  };

  ucum_unit = function(unit) {
    return ucum_time_units[unit] || unit || '';
  };

  convert_value = function(value, from, to) {
    var e;
    try {
      if (from === to) {
        return value;
      } else {
        return decimalAdjust("round", ucum.convert(value, ucum_unit(from), ucum_unit(to)), -8);
      }
    } catch (error) {
      e = error;
      return null;
    }
  };

  unitValidityCache = {};

  is_valid_ucum_unit = function(unit) {
    if (unitValidityCache.hasOwnProperty(unit)) {
      return unitValidityCache[unit];
    } else {
      try {
        ucum.parse(ucum_unit(unit));
        unitValidityCache[unit] = true;
        return true;
      } catch (error) {
        unitValidityCache[unit] = false;
        return false;
      }
    }
  };

  module.exports.convert_value = convert_value;

  units_to_string = function(units) {
    var denom, i, key, len, numer, pow, ref1, str, unit_string, v;
    if (units == null) {
      units = {};
    }
    numer = [];
    denom = [];
    ref1 = Object.keys(units);
    for (i = 0, len = ref1.length; i < len; i++) {
      key = ref1[i];
      v = units[key];
      pow = Math.abs(v);
      str = pow === 1 ? key : key + pow;
      if (v < 0) {
        denom.push(str);
      } else {
        numer.push(str);
      }
    }
    unit_string = "";
    unit_string += numer.join(".");
    if (denom.length > 0) {
      unit_string += "/" + denom.join("/");
    }
    if (unit_string === "") {
      return "1";
    } else {
      return unit_string;
    }
  };

  ucum_multiply = function(t, ms) {
    var b, i, k, len, mterm, ref1, ret, sign, v;
    if (ms == null) {
      ms = [];
    }
    if (ms.length === 0) {
      return t;
    }
    ret = t;
    for (i = 0, len = ms.length; i < len; i++) {
      mterm = ms[i];
      sign = mterm[0] === '.' ? 1 : -1;
      b = mterm[1];
      ret.value *= Math.pow(b.value, sign);
      ref1 = b.units;
      for (k in ref1) {
        v = ref1[k];
        ret.units[k] = ret.units[k] || 0;
        ret.units[k] = ret.units[k] + sign * v;
        if (ret.units[k] === 0) {
          delete ret.units[k];
        }
      }
    }
    return ret;
  };

  module.exports.parseQuantity = function(str) {
    var components, unit, value;
    components = /([+|-]?\d+\.?\d*)\s*('(.+)')?/.exec(str);
    if ((components != null) && (components[1] != null)) {
      value = parseFloat(components[1]);
      if (!isValidDecimal(value)) {
        return null;
      }
      if (components[3] != null) {
        unit = components[3].trim();
      } else {
        unit = "";
      }
      return new Quantity(value, unit);
    } else {
      return null;
    }
  };

  doScaledAddition = function(a, b, scaleForB) {
    var a_unit, b_unit, ref1, sum, val;
    if ((a != null ? a.isQuantity : void 0) && (b != null ? b.isQuantity : void 0)) {
      ref1 = [coalesceToOne(a.unit), coalesceToOne(b.unit)], a_unit = ref1[0], b_unit = ref1[1];
      val = convert_value(b.value * scaleForB, b_unit, a_unit);
      if (val == null) {
        return null;
      }
      sum = a.value + val;
      if (overflowsOrUnderflows(sum)) {
        return null;
      } else {
        return new Quantity(sum, a_unit);
      }
    } else if (a.copy && a.add) {
      b_unit = (b != null ? b.isQuantity : void 0) ? coalesceToOne(b.unit) : b.unit;
      return a.copy().add(b.value * scaleForB, clean_unit(b_unit));
    } else {
      throw new Error("Unsupported argument types.");
    }
  };

  module.exports.doAddition = function(a, b) {
    return doScaledAddition(a, b, 1);
  };

  module.exports.doSubtraction = function(a, b) {
    return doScaledAddition(a, b, -1);
  };

  module.exports.doDivision = function(a, b) {
    if (a != null ? a.isQuantity : void 0) {
      return a.dividedBy(b);
    }
  };

  module.exports.doMultiplication = function(a, b) {
    if (a != null ? a.isQuantity : void 0) {
      return a.multiplyBy(b);
    } else {
      return b.multiplyBy(a);
    }
  };

  coalesceToOne = function(o) {
    if ((o == null) || ((o.trim != null) && !o.trim())) {
      return '1';
    } else {
      return o;
    }
  };

  module.exports.compare_units = function(unit_a, unit_b) {
    var c, e;
    try {
      c = ucum.convert(1, ucum_unit(unit_a), ucum_unit(unit_b));
      if (c > 1) {
        return 1;
      }
      if (c < 1) {
        return -1;
      }
      return 0;
    } catch (error) {
      e = error;
      return null;
    }
  };

}).call(this);



},{"../util/math":46,"ucum":57}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Ratio;

  module.exports.Ratio = Ratio = (function() {
    function Ratio(numerator, denominator) {
      this.numerator = numerator;
      this.denominator = denominator;
      if (this.numerator == null) {
        throw new Error("Cannot create a ratio with an undefined numerator");
      }
      if (this.denominator == null) {
        throw new Error("Cannot create a ratio with an undefined denominator");
      }
    }

    Object.defineProperties(Ratio.prototype, {
      isRatio: {
        get: function() {
          return true;
        }
      }
    });

    Ratio.prototype.clone = function() {
      return new Ratio(this.numerator.clone(), this.denominator.clone());
    };

    Ratio.prototype.toString = function() {
      return (this.numerator.toString()) + " : " + (this.denominator.toString());
    };

    Ratio.prototype.equals = function(other) {
      var divided_other, divided_this;
      if (other != null ? other.isRatio : void 0) {
        divided_this = this.numerator.dividedBy(this.denominator);
        divided_other = other.numerator.dividedBy(other.denominator);
        return divided_this.equals(divided_other);
      } else {
        return false;
      }
    };

    Ratio.prototype.equivalent = function(other) {
      var equal;
      equal = this.equals(other);
      if (equal == null) {
        return false;
      }
      return equal;
    };

    return Ratio;

  })();

}).call(this);



},{}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var ThreeValuedLogic, Uncertainty;

  ThreeValuedLogic = require('./logic').ThreeValuedLogic;

  module.exports.Uncertainty = Uncertainty = (function() {
    Uncertainty.from = function(obj) {
      if (obj != null ? obj.isUncertainty : void 0) {
        return obj;
      } else {
        return new Uncertainty(obj);
      }
    };

    function Uncertainty(low, high) {
      var gt, isNonEnumerable, ref;
      this.low = low != null ? low : null;
      this.high = high;
      gt = function(a, b) {
        if (typeof a !== typeof b) {
          return false;
        }
        if (typeof a.after === 'function') {
          return a.after(b);
        } else {
          return a > b;
        }
      };
      isNonEnumerable = function(val) {
        return (val != null) && (val.isCode || val.isConcept || val.isValueSet);
      };
      if (typeof this.high === 'undefined') {
        this.high = this.low;
      }
      if (isNonEnumerable(this.low) || isNonEnumerable(this.high)) {
        this.low = this.high = null;
      }
      if ((this.low != null) && (this.high != null) && gt(this.low, this.high)) {
        ref = [this.high, this.low], this.low = ref[0], this.high = ref[1];
      }
    }

    Object.defineProperties(Uncertainty.prototype, {
      isUncertainty: {
        get: function() {
          return true;
        }
      }
    });

    Uncertainty.prototype.copy = function() {
      var newHigh, newLow;
      newLow = this.low;
      newHigh = this.high;
      if (typeof this.low.copy === 'function') {
        newLow = this.low.copy();
      }
      if (typeof this.high.copy === 'function') {
        newHigh = this.high.copy();
      }
      return new Uncertainty(newLow, newHigh);
    };

    Uncertainty.prototype.isPoint = function() {
      var gte, lte;
      lte = function(a, b) {
        if (typeof a !== typeof b) {
          return false;
        }
        if (typeof a.sameOrBefore === 'function') {
          return a.sameOrBefore(b);
        } else {
          return a <= b;
        }
      };
      gte = function(a, b) {
        if (typeof a !== typeof b) {
          return false;
        }
        if (typeof a.sameOrBefore === 'function') {
          return a.sameOrAfter(b);
        } else {
          return a >= b;
        }
      };
      return (this.low != null) && (this.high != null) && lte(this.low, this.high) && gte(this.low, this.high);
    };

    Uncertainty.prototype.equals = function(other) {
      other = Uncertainty.from(other);
      return ThreeValuedLogic.not(ThreeValuedLogic.or(this.lessThan(other), this.greaterThan(other)));
    };

    Uncertainty.prototype.lessThan = function(other) {
      var bestCase, lt, worstCase;
      lt = function(a, b) {
        if (typeof a !== typeof b) {
          return false;
        }
        if (typeof a.before === 'function') {
          return a.before(b);
        } else {
          return a < b;
        }
      };
      other = Uncertainty.from(other);
      bestCase = (this.low == null) || (other.high == null) || lt(this.low, other.high);
      worstCase = (this.high != null) && (other.low != null) && lt(this.high, other.low);
      if (bestCase === worstCase) {
        return bestCase;
      } else {
        return null;
      }
    };

    Uncertainty.prototype.greaterThan = function(other) {
      other = Uncertainty.from(other);
      return other.lessThan(this);
    };

    Uncertainty.prototype.lessThanOrEquals = function(other) {
      other = Uncertainty.from(other);
      return ThreeValuedLogic.not(this.greaterThan(other));
    };

    Uncertainty.prototype.greaterThanOrEquals = function(other) {
      other = Uncertainty.from(other);
      return ThreeValuedLogic.not(this.lessThan(other));
    };

    return Uncertainty;

  })();

}).call(this);



},{"./logic":9}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var AggregateExpression, AllTrue, AnyTrue, Avg, Count, Exception, Expression, GeometricMean, Max, Median, Min, Mode, PopulationStdDev, PopulationVariance, Product, Quantity, StdDev, Sum, Variance, allTrue, anyTrue, build, convertAllUnits, doAddition, doMultiplication, getValuesFromQuantities, greaterThan, hasOnlyQuantities, hasSomeQuantities, lessThan, medianOfNumbers, numerical_sort, processQuantities, ref, ref1, ref2, removeNulls, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Expression = require('./expression').Expression;

  ref = require('../util/util'), typeIsArray = ref.typeIsArray, allTrue = ref.allTrue, anyTrue = ref.anyTrue, removeNulls = ref.removeNulls, numerical_sort = ref.numerical_sort;

  build = require('./builder').build;

  Exception = require('../datatypes/exception').Exception;

  ref1 = require('../util/comparison'), greaterThan = ref1.greaterThan, lessThan = ref1.lessThan;

  ref2 = require('../datatypes/quantity'), Quantity = ref2.Quantity, doAddition = ref2.doAddition, doMultiplication = ref2.doMultiplication;

  AggregateExpression = (function(superClass) {
    extend(AggregateExpression, superClass);

    function AggregateExpression(json) {
      AggregateExpression.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
    }

    return AggregateExpression;

  })(Expression);

  module.exports.Count = Count = (function(superClass) {
    extend(Count, superClass);

    function Count(json) {
      Count.__super__.constructor.apply(this, arguments);
    }

    Count.prototype.exec = function(ctx) {
      var items;
      items = this.source.execute(ctx);
      if (!typeIsArray(items)) {
        return null;
      }
      return removeNulls(items).length;
    };

    return Count;

  })(AggregateExpression);

  module.exports.Sum = Sum = (function(superClass) {
    extend(Sum, superClass);

    function Sum(json) {
      Sum.__super__.constructor.apply(this, arguments);
    }

    Sum.prototype.exec = function(ctx) {
      var e, items, sum, values;
      items = this.source.execute(ctx);
      if (!typeIsArray(items)) {
        return null;
      }
      try {
        items = processQuantities(items);
      } catch (error) {
        e = error;
        return null;
      }
      if (!(items.length > 0)) {
        return null;
      }
      if (hasOnlyQuantities(items)) {
        values = getValuesFromQuantities(items);
        sum = values.reduce(function(x, y) {
          return x + y;
        });
        return new Quantity(sum, items[0].unit);
      } else {
        return items.reduce(function(x, y) {
          return x + y;
        });
      }
    };

    return Sum;

  })(AggregateExpression);

  module.exports.Min = Min = (function(superClass) {
    extend(Min, superClass);

    function Min(json) {
      Min.__super__.constructor.apply(this, arguments);
    }

    Min.prototype.exec = function(ctx) {
      var e, element, i, len, list, listWithoutNulls, minimum;
      list = this.source.execute(ctx);
      if (list == null) {
        return null;
      }
      listWithoutNulls = removeNulls(list);
      try {
        processQuantities(list);
      } catch (error) {
        e = error;
        return null;
      }
      if (!(listWithoutNulls.length > 0)) {
        return null;
      }
      minimum = listWithoutNulls[0];
      for (i = 0, len = listWithoutNulls.length; i < len; i++) {
        element = listWithoutNulls[i];
        if (lessThan(element, minimum)) {
          minimum = element;
        }
      }
      return minimum;
    };

    return Min;

  })(AggregateExpression);

  module.exports.Max = Max = (function(superClass) {
    extend(Max, superClass);

    function Max(json) {
      Max.__super__.constructor.apply(this, arguments);
    }

    Max.prototype.exec = function(ctx) {
      var e, element, i, items, len, listWithoutNulls, maximum;
      items = this.source.execute(ctx);
      if (items == null) {
        return null;
      }
      listWithoutNulls = removeNulls(items);
      try {
        processQuantities(items);
      } catch (error) {
        e = error;
        return null;
      }
      if (!(listWithoutNulls.length > 0)) {
        return null;
      }
      maximum = listWithoutNulls[0];
      for (i = 0, len = listWithoutNulls.length; i < len; i++) {
        element = listWithoutNulls[i];
        if (greaterThan(element, maximum)) {
          maximum = element;
        }
      }
      return maximum;
    };

    return Max;

  })(AggregateExpression);

  module.exports.Avg = Avg = (function(superClass) {
    extend(Avg, superClass);

    function Avg(json) {
      Avg.__super__.constructor.apply(this, arguments);
    }

    Avg.prototype.exec = function(ctx) {
      var e, items, sum, values;
      items = this.source.execute(ctx);
      if (!typeIsArray(items)) {
        return null;
      }
      try {
        items = processQuantities(items);
      } catch (error) {
        e = error;
        return null;
      }
      if (items.length === 0) {
        return null;
      }
      if (hasOnlyQuantities(items)) {
        values = getValuesFromQuantities(items);
        sum = values.reduce(function(x, y) {
          return x + y;
        });
        return new Quantity(sum / values.length, items[0].unit);
      } else {
        sum = items.reduce(function(x, y) {
          return x + y;
        });
        return sum / items.length;
      }
    };

    return Avg;

  })(AggregateExpression);

  module.exports.Median = Median = (function(superClass) {
    extend(Median, superClass);

    function Median(json) {
      Median.__super__.constructor.apply(this, arguments);
    }

    Median.prototype.exec = function(ctx) {
      var e, items, median, values;
      items = this.source.execute(ctx);
      if (!typeIsArray(items)) {
        return null;
      }
      if (!(items.length > 0)) {
        return null;
      }
      try {
        items = processQuantities(items);
      } catch (error) {
        e = error;
        return null;
      }
      if (!hasOnlyQuantities(items)) {
        return medianOfNumbers(items);
      }
      values = getValuesFromQuantities(items);
      median = medianOfNumbers(values);
      return new Quantity(median, items[0].unit);
    };

    return Median;

  })(AggregateExpression);

  module.exports.Mode = Mode = (function(superClass) {
    extend(Mode, superClass);

    function Mode(json) {
      Mode.__super__.constructor.apply(this, arguments);
    }

    Mode.prototype.exec = function(ctx) {
      var e, filtered, items, mode, values;
      items = this.source.execute(ctx);
      if (!typeIsArray(items)) {
        return null;
      }
      if (!(items.length > 0)) {
        return null;
      }
      try {
        filtered = processQuantities(items);
      } catch (error) {
        e = error;
        return null;
      }
      if (hasOnlyQuantities(filtered)) {
        values = getValuesFromQuantities(filtered);
        mode = this.mode(values);
        if (mode.length === 1) {
          mode = mode[0];
        }
        return new Quantity(mode, items[0].unit);
      } else {
        mode = this.mode(filtered);
        if (mode.length === 1) {
          return mode[0];
        } else {
          return mode;
        }
      }
    };

    Mode.prototype.mode = function(arr) {
      var cnt, counts, elem, i, len, max, ref3, results;
      max = 0;
      counts = {};
      results = [];
      for (i = 0, len = arr.length; i < len; i++) {
        elem = arr[i];
        cnt = counts[elem] = ((ref3 = counts[elem]) != null ? ref3 : 0) + 1;
        if (cnt === max && indexOf.call(results, elem) < 0) {
          results.push(elem);
        } else if (cnt > max) {
          results = [elem];
          max = cnt;
        }
      }
      return results;
    };

    return Mode;

  })(AggregateExpression);

  module.exports.StdDev = StdDev = (function(superClass) {
    extend(StdDev, superClass);

    function StdDev(json) {
      StdDev.__super__.constructor.apply(this, arguments);
      this.type = "standard_deviation";
    }

    StdDev.prototype.exec = function(ctx) {
      var e, items, stdDev, values;
      items = this.source.execute(ctx);
      if (!typeIsArray(items)) {
        return null;
      }
      try {
        items = processQuantities(items);
      } catch (error) {
        e = error;
        return null;
      }
      if (!(items.length > 0)) {
        return null;
      }
      if (hasOnlyQuantities(items)) {
        values = getValuesFromQuantities(items);
        stdDev = this.standardDeviation(values);
        return new Quantity(stdDev, items[0].unit);
      } else {
        return this.standardDeviation(items);
      }
    };

    StdDev.prototype.standardDeviation = function(list) {
      var val;
      val = this.stats(list);
      if (val) {
        return val[this.type];
      }
    };

    StdDev.prototype.stats = function(list) {
      var i, len, mean, pop_dev, pop_var, sq, std_dev, std_var, sum, sumOfSquares;
      sum = list.reduce(function(x, y) {
        return x + y;
      });
      mean = sum / list.length;
      sumOfSquares = 0;
      for (i = 0, len = list.length; i < len; i++) {
        sq = list[i];
        sumOfSquares += Math.pow(sq - mean, 2);
      }
      std_var = (1 / list.length) * sumOfSquares;
      pop_var = (1 / (list.length - 1)) * sumOfSquares;
      std_dev = Math.sqrt(std_var);
      pop_dev = Math.sqrt(pop_var);
      return {
        standard_variance: std_var,
        population_variance: pop_var,
        standard_deviation: std_dev,
        population_deviation: pop_dev
      };
    };

    return StdDev;

  })(AggregateExpression);

  module.exports.Product = Product = (function(superClass) {
    extend(Product, superClass);

    function Product(json) {
      Product.__super__.constructor.apply(this, arguments);
    }

    Product.prototype.exec = function(ctx) {
      var e, items, product, values;
      items = this.source.execute(ctx);
      if (!typeIsArray(items)) {
        return null;
      }
      try {
        items = processQuantities(items);
      } catch (error) {
        e = error;
        return null;
      }
      if (!(items.length > 0)) {
        return null;
      }
      if (hasOnlyQuantities(items)) {
        values = getValuesFromQuantities(items);
        product = values.reduce(function(x, y) {
          return x * y;
        });
        return new Quantity(product, items[0].unit);
      } else {
        return items.reduce(function(x, y) {
          return x * y;
        });
      }
    };

    return Product;

  })(AggregateExpression);

  module.exports.GeometricMean = GeometricMean = (function(superClass) {
    extend(GeometricMean, superClass);

    function GeometricMean(json) {
      GeometricMean.__super__.constructor.apply(this, arguments);
    }

    GeometricMean.prototype.exec = function(ctx) {
      var e, geoMean, items, product, values;
      items = this.source.execute(ctx);
      if (!typeIsArray(items)) {
        return null;
      }
      try {
        items = processQuantities(items);
      } catch (error) {
        e = error;
        return null;
      }
      if (!(items.length > 0)) {
        return null;
      }
      if (hasOnlyQuantities(items)) {
        values = getValuesFromQuantities(items);
        product = values.reduce(function(x, y) {
          return x * y;
        });
        geoMean = Math.pow(product, 1.0 / items.length);
        return new Quantity(geoMean, items[0].unit);
      } else {
        product = items.reduce(function(x, y) {
          return x * y;
        });
        return Math.pow(product, 1.0 / items.length);
      }
    };

    return GeometricMean;

  })(AggregateExpression);

  module.exports.PopulationStdDev = PopulationStdDev = (function(superClass) {
    extend(PopulationStdDev, superClass);

    function PopulationStdDev(json) {
      PopulationStdDev.__super__.constructor.apply(this, arguments);
      this.type = "population_deviation";
    }

    return PopulationStdDev;

  })(StdDev);

  module.exports.Variance = Variance = (function(superClass) {
    extend(Variance, superClass);

    function Variance(json) {
      Variance.__super__.constructor.apply(this, arguments);
      this.type = "standard_variance";
    }

    return Variance;

  })(StdDev);

  module.exports.PopulationVariance = PopulationVariance = (function(superClass) {
    extend(PopulationVariance, superClass);

    function PopulationVariance(json) {
      PopulationVariance.__super__.constructor.apply(this, arguments);
      this.type = "population_variance";
    }

    return PopulationVariance;

  })(StdDev);

  module.exports.AllTrue = AllTrue = (function(superClass) {
    extend(AllTrue, superClass);

    function AllTrue(json) {
      AllTrue.__super__.constructor.apply(this, arguments);
    }

    AllTrue.prototype.exec = function(ctx) {
      var items;
      items = this.source.execute(ctx);
      return allTrue(items);
    };

    return AllTrue;

  })(AggregateExpression);

  module.exports.AnyTrue = AnyTrue = (function(superClass) {
    extend(AnyTrue, superClass);

    function AnyTrue(json) {
      AnyTrue.__super__.constructor.apply(this, arguments);
    }

    AnyTrue.prototype.exec = function(ctx) {
      var items;
      items = this.source.execute(ctx);
      return anyTrue(items);
    };

    return AnyTrue;

  })(AggregateExpression);

  processQuantities = function(values) {
    values = removeNulls(values);
    if (hasOnlyQuantities(values)) {
      return values = convertAllUnits(values);
    } else if (hasSomeQuantities(values)) {
      throw new Exception("Cannot perform aggregate operations on mixed values of Quantities and non Quantities");
    } else {
      return values;
    }
  };

  getValuesFromQuantities = function(quantities) {
    return quantities.map(function(quantity) {
      return quantity.value;
    });
  };

  hasOnlyQuantities = function(arr) {
    return arr.every(function(x) {
      return x.isQuantity;
    });
  };

  hasSomeQuantities = function(arr) {
    return arr.some(function(x) {
      return x.isQuantity;
    });
  };

  convertAllUnits = function(arr) {
    var converted, i, len, quantity;
    converted = [];
    for (i = 0, len = arr.length; i < len; i++) {
      quantity = arr[i];
      converted.push(quantity.convertUnit(arr[0].unit));
    }
    return converted;
  };

  medianOfNumbers = function(numbers) {
    numbers = numerical_sort(numbers, "asc");
    if (numbers.length % 2 === 1) {
      return numbers[(numbers.length - 1) / 2];
    } else {
      return (numbers[(numbers.length / 2) - 1] + numbers[numbers.length / 2]) / 2;
    }
  };

}).call(this);



},{"../datatypes/exception":7,"../datatypes/quantity":10,"../util/comparison":45,"../util/util":47,"./builder":15,"./expression":21}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Abs, Add, Ceiling, Divide, Exp, Expression, Floor, Ln, Log, MathUtil, MaxValue, MinValue, Modulo, Multiply, Negate, Power, Predecessor, Quantity, Round, Subtract, Successor, Truncate, TruncatedDivide, allTrue, anyTrue, build, doAddition, doDivision, doMultiplication, doSubtraction, ref, ref1, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  ref = require('../util/util'), typeIsArray = ref.typeIsArray, allTrue = ref.allTrue, anyTrue = ref.anyTrue;

  build = require('./builder').build;

  MathUtil = require('../util/math');

  ref1 = require('../datatypes/quantity'), Quantity = ref1.Quantity, doAddition = ref1.doAddition, doSubtraction = ref1.doSubtraction, doMultiplication = ref1.doMultiplication, doDivision = ref1.doDivision;

  module.exports.Add = Add = (function(superClass) {
    extend(Add, superClass);

    function Add(json) {
      Add.__super__.constructor.apply(this, arguments);
    }

    Add.prototype.exec = function(ctx) {
      var args, sum;
      args = this.execArgs(ctx);
      sum = null;
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        null;
      } else {
        if (args != null) {
          args.reduce(function(x, y) {
            if (x.isQuantity || x.isDateTime || x.isDate || x.isTime) {
              return sum = doAddition(x, y);
            } else {
              return sum = x + y;
            }
          });
        }
      }
      if (MathUtil.overflowsOrUnderflows(sum)) {
        return null;
      }
      return sum;
    };

    return Add;

  })(Expression);

  module.exports.Subtract = Subtract = (function(superClass) {
    extend(Subtract, superClass);

    function Subtract(json) {
      Subtract.__super__.constructor.apply(this, arguments);
    }

    Subtract.prototype.exec = function(ctx) {
      var args, difference;
      args = this.execArgs(ctx);
      difference = null;
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        null;
      } else {
        args.reduce(function(x, y) {
          if (x.isQuantity || x.isDateTime || x.isDate) {
            return difference = doSubtraction(x, y);
          } else {
            return difference = x - y;
          }
        });
      }
      if (MathUtil.overflowsOrUnderflows(difference)) {
        return null;
      }
      return difference;
    };

    return Subtract;

  })(Expression);

  module.exports.Multiply = Multiply = (function(superClass) {
    extend(Multiply, superClass);

    function Multiply(json) {
      Multiply.__super__.constructor.apply(this, arguments);
    }

    Multiply.prototype.exec = function(ctx) {
      var args, product;
      args = this.execArgs(ctx);
      product = null;
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        null;
      } else {
        if (args != null) {
          args.reduce(function(x, y) {
            if (x.isQuantity || y.isQuantity) {
              return product = doMultiplication(x, y);
            } else {
              return product = x * y;
            }
          });
        }
      }
      if (MathUtil.overflowsOrUnderflows(product)) {
        return null;
      }
      return product;
    };

    return Multiply;

  })(Expression);

  module.exports.Divide = Divide = (function(superClass) {
    extend(Divide, superClass);

    function Divide(json) {
      Divide.__super__.constructor.apply(this, arguments);
    }

    Divide.prototype.exec = function(ctx) {
      var args, quotient;
      args = this.execArgs(ctx);
      quotient = null;
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        null;
      } else {
        if (args != null) {
          args.reduce(function(x, y) {
            if (x.isQuantity) {
              return quotient = doDivision(x, y);
            } else {
              return quotient = x / y;
            }
          });
        }
      }
      if (MathUtil.overflowsOrUnderflows(quotient)) {
        return null;
      }
      return quotient;
    };

    return Divide;

  })(Expression);

  module.exports.TruncatedDivide = TruncatedDivide = (function(superClass) {
    extend(TruncatedDivide, superClass);

    function TruncatedDivide(json) {
      TruncatedDivide.__super__.constructor.apply(this, arguments);
    }

    TruncatedDivide.prototype.exec = function(ctx) {
      var args, quotient;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        null;
      } else {
        quotient = Math.floor(args.reduce(function(x, y) {
          return x / y;
        }));
      }
      if (MathUtil.overflowsOrUnderflows(quotient)) {
        return null;
      }
      return quotient;
    };

    return TruncatedDivide;

  })(Expression);

  module.exports.Modulo = Modulo = (function(superClass) {
    extend(Modulo, superClass);

    function Modulo(json) {
      Modulo.__super__.constructor.apply(this, arguments);
    }

    Modulo.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args.reduce(function(x, y) {
          return x % y;
        });
      }
    };

    return Modulo;

  })(Expression);

  module.exports.Ceiling = Ceiling = (function(superClass) {
    extend(Ceiling, superClass);

    function Ceiling(json) {
      Ceiling.__super__.constructor.apply(this, arguments);
    }

    Ceiling.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return Math.ceil(arg);
      }
    };

    return Ceiling;

  })(Expression);

  module.exports.Floor = Floor = (function(superClass) {
    extend(Floor, superClass);

    function Floor(json) {
      Floor.__super__.constructor.apply(this, arguments);
    }

    Floor.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return Math.floor(arg);
      }
    };

    return Floor;

  })(Expression);

  module.exports.Truncate = Truncate = (function(superClass) {
    extend(Truncate, superClass);

    function Truncate() {
      return Truncate.__super__.constructor.apply(this, arguments);
    }

    return Truncate;

  })(Floor);

  module.exports.Abs = Abs = (function(superClass) {
    extend(Abs, superClass);

    function Abs(json) {
      Abs.__super__.constructor.apply(this, arguments);
    }

    Abs.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else if (arg.isQuantity) {
        return new Quantity(Math.abs(arg.value), arg.unit);
      } else {
        return Math.abs(arg);
      }
    };

    return Abs;

  })(Expression);

  module.exports.Negate = Negate = (function(superClass) {
    extend(Negate, superClass);

    function Negate(json) {
      Negate.__super__.constructor.apply(this, arguments);
    }

    Negate.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else if (arg.isQuantity) {
        return new Quantity(arg.value * -1, arg.unit);
      } else {
        return arg * -1;
      }
    };

    return Negate;

  })(Expression);

  module.exports.Round = Round = (function(superClass) {
    extend(Round, superClass);

    function Round(json) {
      Round.__super__.constructor.apply(this, arguments);
      this.precision = build(json.precision);
    }

    Round.prototype.exec = function(ctx) {
      var arg, dec;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        dec = this.precision != null ? this.precision.execute(ctx) : 0;
        return Math.round(arg * Math.pow(10, dec)) / Math.pow(10, dec);
      }
    };

    return Round;

  })(Expression);

  module.exports.Ln = Ln = (function(superClass) {
    extend(Ln, superClass);

    function Ln(json) {
      Ln.__super__.constructor.apply(this, arguments);
    }

    Ln.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else {
        return Math.log(arg);
      }
    };

    return Ln;

  })(Expression);

  module.exports.Exp = Exp = (function(superClass) {
    extend(Exp, superClass);

    function Exp(json) {
      Exp.__super__.constructor.apply(this, arguments);
    }

    Exp.prototype.exec = function(ctx) {
      var arg, power;
      arg = this.execArgs(ctx);
      if (arg == null) {
        null;
      } else {
        power = Math.exp(arg);
      }
      if (MathUtil.overflowsOrUnderflows(power)) {
        return null;
      }
      return power;
    };

    return Exp;

  })(Expression);

  module.exports.Log = Log = (function(superClass) {
    extend(Log, superClass);

    function Log(json) {
      Log.__super__.constructor.apply(this, arguments);
    }

    Log.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args.reduce(function(x, y) {
          return Math.log(x) / Math.log(y);
        });
      }
    };

    return Log;

  })(Expression);

  module.exports.Power = Power = (function(superClass) {
    extend(Power, superClass);

    function Power(json) {
      Power.__super__.constructor.apply(this, arguments);
    }

    Power.prototype.exec = function(ctx) {
      var args, power;
      args = this.execArgs(ctx);
      power = null;
      if ((args == null) || args.some(function(x) {
        return x == null;
      })) {
        null;
      } else {
        power = args.reduce(function(x, y) {
          return Math.pow(x, y);
        });
      }
      if (MathUtil.overflowsOrUnderflows(power)) {
        return null;
      }
      return power;
    };

    return Power;

  })(Expression);

  module.exports.MinValue = MinValue = (function(superClass) {
    var MIN_VALUES;

    extend(MinValue, superClass);

    MIN_VALUES = {};

    MIN_VALUES['{urn:hl7-org:elm-types:r1}Integer'] = MathUtil.MIN_INT_VALUE;

    MIN_VALUES['{urn:hl7-org:elm-types:r1}Decimal'] = MathUtil.MIN_FLOAT_VALUE;

    MIN_VALUES['{urn:hl7-org:elm-types:r1}DateTime'] = MathUtil.MIN_DATETIME_VALUE;

    MIN_VALUES['{urn:hl7-org:elm-types:r1}Date'] = MathUtil.MIN_DATE_VALUE;

    MIN_VALUES['{urn:hl7-org:elm-types:r1}Time'] = MathUtil.MIN_TIME_VALUE;

    function MinValue(json) {
      MinValue.__super__.constructor.apply(this, arguments);
      this.valueType = json.valueType;
    }

    MinValue.prototype.exec = function(ctx) {
      var minDateTime;
      if (MIN_VALUES[this.valueType]) {
        if (this.valueType === '{urn:hl7-org:elm-types:r1}DateTime') {
          minDateTime = MIN_VALUES[this.valueType].copy();
          minDateTime.timezoneOffset = ctx.getTimezoneOffset();
          return minDateTime;
        } else {
          return MIN_VALUES[this.valueType];
        }
      } else {
        throw new Error("Minimum not supported for " + this.valueType);
      }
    };

    return MinValue;

  })(Expression);

  module.exports.MaxValue = MaxValue = (function(superClass) {
    var MAX_VALUES;

    extend(MaxValue, superClass);

    MAX_VALUES = {};

    MAX_VALUES['{urn:hl7-org:elm-types:r1}Integer'] = MathUtil.MAX_INT_VALUE;

    MAX_VALUES['{urn:hl7-org:elm-types:r1}Decimal'] = MathUtil.MAX_FLOAT_VALUE;

    MAX_VALUES['{urn:hl7-org:elm-types:r1}DateTime'] = MathUtil.MAX_DATETIME_VALUE;

    MAX_VALUES['{urn:hl7-org:elm-types:r1}Date'] = MathUtil.MAX_DATE_VALUE;

    MAX_VALUES['{urn:hl7-org:elm-types:r1}Time'] = MathUtil.MAX_TIME_VALUE;

    function MaxValue(json) {
      MaxValue.__super__.constructor.apply(this, arguments);
      this.valueType = json.valueType;
    }

    MaxValue.prototype.exec = function(ctx) {
      var maxDateTime;
      if (MAX_VALUES[this.valueType] != null) {
        if (this.valueType === '{urn:hl7-org:elm-types:r1}DateTime') {
          maxDateTime = MAX_VALUES[this.valueType].copy();
          maxDateTime.timezoneOffset = ctx.getTimezoneOffset();
          return maxDateTime;
        } else {
          return MAX_VALUES[this.valueType];
        }
      } else {
        throw new Error("Maximum not supported for " + this.valueType);
      }
    };

    return MaxValue;

  })(Expression);

  module.exports.Successor = Successor = (function(superClass) {
    extend(Successor, superClass);

    function Successor(json) {
      Successor.__super__.constructor.apply(this, arguments);
    }

    Successor.prototype.exec = function(ctx) {
      var arg, e, successor;
      arg = this.execArgs(ctx);
      successor = null;
      if (arg == null) {
        null;
      } else {
        try {
          successor = MathUtil.successor(arg);
        } catch (error) {
          e = error;
          if (e instanceof MathUtil.OverFlowException) {
            return null;
          }
        }
      }
      if (MathUtil.overflowsOrUnderflows(successor)) {
        return null;
      }
      return successor;
    };

    return Successor;

  })(Expression);

  module.exports.Predecessor = Predecessor = (function(superClass) {
    extend(Predecessor, superClass);

    function Predecessor(json) {
      Predecessor.__super__.constructor.apply(this, arguments);
    }

    Predecessor.prototype.exec = function(ctx) {
      var arg, e, predecessor;
      arg = this.execArgs(ctx);
      predecessor = null;
      if (arg == null) {
        null;
      } else {
        try {
          predecessor = MathUtil.predecessor(arg);
        } catch (error) {
          e = error;
          if (e instanceof MathUtil.OverFlowException) {
            return null;
          }
        }
      }
      if (MathUtil.overflowsOrUnderflows(predecessor)) {
        return null;
      }
      return predecessor;
    };

    return Predecessor;

  })(Expression);

}).call(this);



},{"../datatypes/quantity":10,"../util/math":46,"../util/util":47,"./builder":15,"./expression":21}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var E, build, constructByName, functionExists, typeIsArray;

  E = require('./expressions');

  typeIsArray = require('../util/util').typeIsArray;

  module.exports.build = build = function(json) {
    var child;
    if (json == null) {
      return json;
    }
    if (typeIsArray(json)) {
      return (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = json.length; i < len; i++) {
          child = json[i];
          results.push(build(child));
        }
        return results;
      })();
    }
    if (json.type === "FunctionRef") {
      return new E.FunctionRef(json);
    } else if (json.type === "Literal") {
      return E.Literal.from(json);
    } else if (functionExists(json.type)) {
      return constructByName(json.type, json);
    } else {
      return null;
    }
  };

  functionExists = function(name) {
    return typeof E[name] === "function";
  };

  constructByName = function(name, json) {
    return new E[name](json);
  };

}).call(this);



},{"../util/util":47,"./expressions":22}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var AnyInValueSet, CalculateAge, CalculateAgeAt, Code, CodeDef, CodeRef, CodeSystemDef, Concept, ConceptDef, ConceptRef, Expression, InValueSet, ValueSetDef, ValueSetRef, build, dt,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  dt = require('../datatypes/datatypes');

  build = require('./builder').build;

  module.exports.ValueSetDef = ValueSetDef = (function(superClass) {
    extend(ValueSetDef, superClass);

    function ValueSetDef(json) {
      ValueSetDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.id = json.id;
      this.version = json.version;
    }

    ValueSetDef.prototype.exec = function(ctx) {
      var ref, valueset;
      valueset = (ref = ctx.codeService.findValueSet(this.id, this.version)) != null ? ref : new dt.ValueSet(this.id, this.version);
      ctx.rootContext().set(this.name, valueset);
      return valueset;
    };

    return ValueSetDef;

  })(Expression);

  module.exports.ValueSetRef = ValueSetRef = (function(superClass) {
    extend(ValueSetRef, superClass);

    function ValueSetRef(json) {
      ValueSetRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.libraryName = json.libraryName;
    }

    ValueSetRef.prototype.exec = function(ctx) {
      var valueset;
      valueset = ctx.getValueSet(this.name, this.libraryName);
      if (valueset instanceof Expression) {
        valueset = valueset.execute(ctx);
      }
      return valueset;
    };

    return ValueSetRef;

  })(Expression);

  module.exports.AnyInValueSet = AnyInValueSet = (function(superClass) {
    extend(AnyInValueSet, superClass);

    function AnyInValueSet(json) {
      AnyInValueSet.__super__.constructor.apply(this, arguments);
      this.codes = build(json.codes);
      this.valueset = new ValueSetRef(json.valueset);
    }

    AnyInValueSet.prototype.exec = function(ctx) {
      var code, codes, i, len, valueset;
      valueset = this.valueset.execute(ctx);
      if (!((valueset != null) && valueset.isValueSet)) {
        throw new Error("ValueSet must be provided to InValueSet function");
      }
      codes = this.codes.exec(ctx);
      if (codes == null) {
        return false;
      }
      for (i = 0, len = codes.length; i < len; i++) {
        code = codes[i];
        if (valueset.hasMatch(code)) {
          return true;
        }
      }
      return false;
    };

    return AnyInValueSet;

  })(Expression);

  module.exports.InValueSet = InValueSet = (function(superClass) {
    extend(InValueSet, superClass);

    function InValueSet(json) {
      InValueSet.__super__.constructor.apply(this, arguments);
      this.code = build(json.code);
      this.valueset = new ValueSetRef(json.valueset);
    }

    InValueSet.prototype.exec = function(ctx) {
      var code, valueset;
      if (this.code == null) {
        return false;
      }
      if (this.valueset == null) {
        throw new Error("ValueSet must be provided to InValueSet function");
      }
      code = this.code.execute(ctx);
      if (code == null) {
        return false;
      }
      valueset = this.valueset.execute(ctx);
      if (!((valueset != null) && valueset.isValueSet)) {
        throw new Error("ValueSet must be provided to InValueSet function");
      }
      return valueset.hasMatch(code);
    };

    return InValueSet;

  })(Expression);

  module.exports.CodeSystemDef = CodeSystemDef = (function(superClass) {
    extend(CodeSystemDef, superClass);

    function CodeSystemDef(json) {
      CodeSystemDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.id = json.id;
      this.version = json.version;
    }

    CodeSystemDef.prototype.exec = function(ctx) {
      return new dt.CodeSystem(this.id, this.version);
    };

    return CodeSystemDef;

  })(Expression);

  module.exports.CodeDef = CodeDef = (function(superClass) {
    extend(CodeDef, superClass);

    function CodeDef(json) {
      CodeDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.id = json.id;
      this.systemName = json.codeSystem.name;
      this.display = json.display;
    }

    CodeDef.prototype.exec = function(ctx) {
      var ref, system;
      system = (ref = ctx.getCodeSystem(this.systemName)) != null ? ref.execute(ctx) : void 0;
      return new dt.Code(this.id, system.id, system.version, this.display);
    };

    return CodeDef;

  })(Expression);

  module.exports.CodeRef = CodeRef = (function(superClass) {
    extend(CodeRef, superClass);

    function CodeRef(json) {
      CodeRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.library = json.libraryName;
    }

    CodeRef.prototype.exec = function(ctx) {
      var ref;
      ctx = this.library ? ctx.getLibraryContext(this.library) : ctx;
      return (ref = ctx.getCode(this.name)) != null ? ref.execute(ctx) : void 0;
    };

    return CodeRef;

  })(Expression);

  module.exports.Code = Code = (function(superClass) {
    extend(Code, superClass);

    function Code(json) {
      Code.__super__.constructor.apply(this, arguments);
      this.code = json.code;
      this.systemName = json.system.name;
      this.version = json.version;
      this.display = json.display;
    }

    Object.defineProperties(Code.prototype, {
      isCode: {
        get: function() {
          return true;
        }
      }
    });

    Code.prototype.exec = function(ctx) {
      var ref, system;
      system = (ref = ctx.getCodeSystem(this.systemName)) != null ? ref.id : void 0;
      return new dt.Code(this.code, system, this.version, this.display);
    };

    return Code;

  })(Expression);

  module.exports.ConceptDef = ConceptDef = (function(superClass) {
    extend(ConceptDef, superClass);

    function ConceptDef(json) {
      ConceptDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.display = json.display;
      this.codes = json.code;
    }

    ConceptDef.prototype.exec = function(ctx) {
      var code, codes;
      codes = (function() {
        var i, len, ref, ref1, results;
        ref = this.codes;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          code = ref[i];
          results.push((ref1 = ctx.getCode(code.name)) != null ? ref1.execute(ctx) : void 0);
        }
        return results;
      }).call(this);
      return new dt.Concept(codes, this.display);
    };

    return ConceptDef;

  })(Expression);

  module.exports.ConceptRef = ConceptRef = (function(superClass) {
    extend(ConceptRef, superClass);

    function ConceptRef(json) {
      ConceptRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
    }

    ConceptRef.prototype.exec = function(ctx) {
      var ref;
      return (ref = ctx.getConcept(this.name)) != null ? ref.execute(ctx) : void 0;
    };

    return ConceptRef;

  })(Expression);

  module.exports.Concept = Concept = (function(superClass) {
    extend(Concept, superClass);

    function Concept(json) {
      Concept.__super__.constructor.apply(this, arguments);
      this.codes = json.code;
      this.display = json.display;
    }

    Object.defineProperties(Concept.prototype, {
      isConcept: {
        get: function() {
          return true;
        }
      }
    });

    Concept.prototype.toCode = function(ctx, code) {
      var ref, system;
      system = (ref = ctx.getCodeSystem(code.system.name)) != null ? ref.id : void 0;
      return new dt.Code(code.code, system, code.version, code.display);
    };

    Concept.prototype.exec = function(ctx) {
      var code, codes;
      codes = (function() {
        var i, len, ref, results;
        ref = this.codes;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          code = ref[i];
          results.push(this.toCode(ctx, code));
        }
        return results;
      }).call(this);
      return new dt.Concept(codes, this.display);
    };

    return Concept;

  })(Expression);

  module.exports.CalculateAge = CalculateAge = (function(superClass) {
    extend(CalculateAge, superClass);

    function CalculateAge(json) {
      CalculateAge.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    CalculateAge.prototype.exec = function(ctx) {
      var date1, date2, result;
      date1 = this.execArgs(ctx);
      date2 = dt.DateTime.fromJSDate(ctx.getExecutionDateTime());
      result = date1 != null ? date1.durationBetween(date2, this.precision.toLowerCase()) : void 0;
      if ((result != null) && result.isPoint()) {
        return result.low;
      } else {
        return result;
      }
    };

    return CalculateAge;

  })(Expression);

  module.exports.CalculateAgeAt = CalculateAgeAt = (function(superClass) {
    extend(CalculateAgeAt, superClass);

    function CalculateAgeAt(json) {
      CalculateAgeAt.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    CalculateAgeAt.prototype.exec = function(ctx) {
      var date1, date2, ref, result;
      ref = this.execArgs(ctx), date1 = ref[0], date2 = ref[1];
      if ((date1 != null) && (date2 != null)) {
        if (date2.isDate && date1.isDateTime) {
          date1 = date1.getDate();
        }
        result = date1.durationBetween(date2, this.precision.toLowerCase());
        if ((result != null) && result.isPoint()) {
          return result.low;
        } else {
          return result;
        }
      } else {
        return null;
      }
    };

    return CalculateAgeAt;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":5,"./builder":15,"./expression":21}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Expression, Greater, GreaterOrEqual, Less, LessOrEqual, Uncertainty,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  Uncertainty = require('../datatypes/datatypes').Uncertainty;

  module.exports.Less = Less = (function(superClass) {
    extend(Less, superClass);

    function Less(json) {
      Less.__super__.constructor.apply(this, arguments);
    }

    Less.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx).map(function(x) {
        return Uncertainty.from(x);
      });
      if (!((args[0] != null) && (args[1] != null))) {
        return null;
      }
      return args[0].lessThan(args[1]);
    };

    return Less;

  })(Expression);

  module.exports.LessOrEqual = LessOrEqual = (function(superClass) {
    extend(LessOrEqual, superClass);

    function LessOrEqual(json) {
      LessOrEqual.__super__.constructor.apply(this, arguments);
    }

    LessOrEqual.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx).map(function(x) {
        return Uncertainty.from(x);
      });
      if (!((args[0] != null) && (args[1] != null))) {
        return null;
      }
      return args[0].lessThanOrEquals(args[1]);
    };

    return LessOrEqual;

  })(Expression);

  module.exports.Greater = Greater = (function(superClass) {
    extend(Greater, superClass);

    function Greater(json) {
      Greater.__super__.constructor.apply(this, arguments);
    }

    Greater.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx).map(function(x) {
        return Uncertainty.from(x);
      });
      if (!((args[0] != null) && (args[1] != null))) {
        return null;
      }
      return args[0].greaterThan(args[1]);
    };

    return Greater;

  })(Expression);

  module.exports.GreaterOrEqual = GreaterOrEqual = (function(superClass) {
    extend(GreaterOrEqual, superClass);

    function GreaterOrEqual(json) {
      GreaterOrEqual.__super__.constructor.apply(this, arguments);
    }

    GreaterOrEqual.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx).map(function(x) {
        return Uncertainty.from(x);
      });
      if (!((args[0] != null) && (args[1] != null))) {
        return null;
      }
      return args[0].greaterThanOrEquals(args[1]);
    };

    return GreaterOrEqual;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":5,"./expression":21}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Case, CaseItem, Expression, If, build, equals,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  equals = require('../util/comparison').equals;

  module.exports.If = If = (function(superClass) {
    extend(If, superClass);

    function If(json) {
      If.__super__.constructor.apply(this, arguments);
      this.condition = build(json.condition);
      this.th = build(json.then);
      this.els = build(json["else"]);
    }

    If.prototype.exec = function(ctx) {
      if (this.condition.execute(ctx)) {
        return this.th.execute(ctx);
      } else {
        return this.els.execute(ctx);
      }
    };

    return If;

  })(Expression);

  module.exports.CaseItem = CaseItem = CaseItem = (function() {
    function CaseItem(json) {
      this.when = build(json.when);
      this.then = build(json.then);
    }

    return CaseItem;

  })();

  module.exports.Case = Case = (function(superClass) {
    extend(Case, superClass);

    function Case(json) {
      var ci;
      Case.__super__.constructor.apply(this, arguments);
      this.comparand = build(json.comparand);
      this.caseItems = (function() {
        var i, len, ref, results;
        ref = json.caseItem;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          ci = ref[i];
          results.push(new CaseItem(ci));
        }
        return results;
      })();
      this.els = build(json["else"]);
    }

    Case.prototype.exec = function(ctx) {
      if (this.comparand) {
        return this.exec_selected(ctx);
      } else {
        return this.exec_standard(ctx);
      }
    };

    Case.prototype.exec_selected = function(ctx) {
      var ci, i, len, ref, val;
      val = this.comparand.execute(ctx);
      ref = this.caseItems;
      for (i = 0, len = ref.length; i < len; i++) {
        ci = ref[i];
        if (equals(ci.when.execute(ctx), val)) {
          return ci.then.execute(ctx);
        }
      }
      return this.els.execute(ctx);
    };

    Case.prototype.exec_standard = function(ctx) {
      var ci, i, len, ref;
      ref = this.caseItems;
      for (i = 0, len = ref.length; i < len; i++) {
        ci = ref[i];
        if (ci.when.execute(ctx)) {
          return ci.then.execute(ctx);
        }
      }
      return this.els.execute(ctx);
    };

    return Case;

  })(Expression);

}).call(this);



},{"../util/comparison":45,"./builder":15,"./expression":21}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var DT, Date, DateFrom, DateTime, DateTimeComponentFrom, DifferenceBetween, DurationBetween, Expression, Literal, Now, Time, TimeFrom, TimeOfDay, TimezoneOffsetFrom, Today, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  Literal = require('./literal').Literal;

  DT = require('../datatypes/datatypes');

  module.exports.DateTime = DateTime = (function(superClass) {
    extend(DateTime, superClass);

    DateTime.PROPERTIES = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond', 'timezoneOffset'];

    function DateTime(json1) {
      this.json = json1;
      DateTime.__super__.constructor.apply(this, arguments);
    }

    DateTime.prototype.exec = function(ctx) {
      var args, i, len, p, property, ref;
      ref = DateTime.PROPERTIES;
      for (i = 0, len = ref.length; i < len; i++) {
        property = ref[i];
        if (this.json[property] != null) {
          this[property] = build(this.json[property]);
        } else if (property === 'timezoneOffset' && (ctx.getTimezoneOffset() != null)) {
          this[property] = Literal.from({
            "type": "Literal",
            "value": ctx.getTimezoneOffset(),
            "valueType": "{urn:hl7-org:elm-types:r1}Integer"
          });
        }
      }
      args = (function() {
        var j, len1, ref1, results;
        ref1 = DateTime.PROPERTIES;
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          p = ref1[j];
          results.push(this[p] != null ? this[p].execute(ctx) : void 0);
        }
        return results;
      }).call(this);
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(DT.DateTime, args, function(){});
    };

    return DateTime;

  })(Expression);

  module.exports.Date = Date = (function(superClass) {
    extend(Date, superClass);

    Date.PROPERTIES = ['year', 'month', 'day'];

    function Date(json1) {
      this.json = json1;
      Date.__super__.constructor.apply(this, arguments);
    }

    Date.prototype.exec = function(ctx) {
      var args, i, len, p, property, ref;
      ref = Date.PROPERTIES;
      for (i = 0, len = ref.length; i < len; i++) {
        property = ref[i];
        if (this.json[property] != null) {
          this[property] = build(this.json[property]);
        }
      }
      args = (function() {
        var j, len1, ref1, results;
        ref1 = Date.PROPERTIES;
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          p = ref1[j];
          results.push(this[p] != null ? this[p].execute(ctx) : void 0);
        }
        return results;
      }).call(this);
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(DT.Date, args, function(){});
    };

    return Date;

  })(Expression);

  module.exports.Time = Time = (function(superClass) {
    extend(Time, superClass);

    Time.PROPERTIES = ['hour', 'minute', 'second', 'millisecond'];

    function Time(json) {
      var i, len, property, ref;
      Time.__super__.constructor.apply(this, arguments);
      ref = Time.PROPERTIES;
      for (i = 0, len = ref.length; i < len; i++) {
        property = ref[i];
        if (json[property] != null) {
          this[property] = build(json[property]);
        }
      }
    }

    Time.prototype.exec = function(ctx) {
      var args, p;
      args = (function() {
        var i, len, ref, results;
        ref = Time.PROPERTIES;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          p = ref[i];
          results.push(this[p] != null ? this[p].execute(ctx) : void 0);
        }
        return results;
      }).call(this);
      return ((function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(DT.DateTime, [0, 1, 1].concat(slice.call(args)), function(){})).getTime();
    };

    return Time;

  })(Expression);

  module.exports.Today = Today = (function(superClass) {
    extend(Today, superClass);

    function Today(json) {
      Today.__super__.constructor.apply(this, arguments);
    }

    Today.prototype.exec = function(ctx) {
      return ctx.getExecutionDateTime().getDate();
    };

    return Today;

  })(Expression);

  module.exports.Now = Now = (function(superClass) {
    extend(Now, superClass);

    function Now(json) {
      Now.__super__.constructor.apply(this, arguments);
    }

    Now.prototype.exec = function(ctx) {
      return ctx.getExecutionDateTime();
    };

    return Now;

  })(Expression);

  module.exports.TimeOfDay = TimeOfDay = (function(superClass) {
    extend(TimeOfDay, superClass);

    function TimeOfDay(json) {
      TimeOfDay.__super__.constructor.apply(this, arguments);
    }

    TimeOfDay.prototype.exec = function(ctx) {
      return ctx.getExecutionDateTime().getTime();
    };

    return TimeOfDay;

  })(Expression);

  module.exports.DateTimeComponentFrom = DateTimeComponentFrom = (function(superClass) {
    extend(DateTimeComponentFrom, superClass);

    function DateTimeComponentFrom(json) {
      DateTimeComponentFrom.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    DateTimeComponentFrom.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return arg[this.precision.toLowerCase()];
      } else {
        return null;
      }
    };

    return DateTimeComponentFrom;

  })(Expression);

  module.exports.DateFrom = DateFrom = (function(superClass) {
    extend(DateFrom, superClass);

    function DateFrom(json) {
      DateFrom.__super__.constructor.apply(this, arguments);
    }

    DateFrom.prototype.exec = function(ctx) {
      var date;
      date = this.execArgs(ctx);
      if (date != null) {
        return date.getDate();
      } else {
        return null;
      }
    };

    return DateFrom;

  })(Expression);

  module.exports.TimeFrom = TimeFrom = (function(superClass) {
    extend(TimeFrom, superClass);

    function TimeFrom(json) {
      TimeFrom.__super__.constructor.apply(this, arguments);
    }

    TimeFrom.prototype.exec = function(ctx) {
      var date;
      date = this.execArgs(ctx);
      if (date != null) {
        return date.getTime();
      } else {
        return null;
      }
    };

    return TimeFrom;

  })(Expression);

  module.exports.TimezoneOffsetFrom = TimezoneOffsetFrom = (function(superClass) {
    extend(TimezoneOffsetFrom, superClass);

    function TimezoneOffsetFrom(json) {
      TimezoneOffsetFrom.__super__.constructor.apply(this, arguments);
    }

    TimezoneOffsetFrom.prototype.exec = function(ctx) {
      var date;
      date = this.execArgs(ctx);
      if (date != null) {
        return date.timezoneOffset;
      } else {
        return null;
      }
    };

    return TimezoneOffsetFrom;

  })(Expression);

  module.exports.doAfter = function(a, b, precision) {
    return a.after(b, precision);
  };

  module.exports.doBefore = function(a, b, precision) {
    return a.before(b, precision);
  };

  module.exports.DifferenceBetween = DifferenceBetween = (function(superClass) {
    extend(DifferenceBetween, superClass);

    function DifferenceBetween(json) {
      DifferenceBetween.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    DifferenceBetween.prototype.exec = function(ctx) {
      var args, ref, result;
      args = this.execArgs(ctx);
      if ((args[0] == null) || (args[1] == null) || typeof args[0].differenceBetween !== 'function' || typeof args[1].differenceBetween !== 'function') {
        return null;
      }
      result = args[0].differenceBetween(args[1], (ref = this.precision) != null ? ref.toLowerCase() : void 0);
      if ((result != null) && result.isPoint()) {
        return result.low;
      } else {
        return result;
      }
    };

    return DifferenceBetween;

  })(Expression);

  module.exports.DurationBetween = DurationBetween = (function(superClass) {
    extend(DurationBetween, superClass);

    function DurationBetween(json) {
      DurationBetween.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    DurationBetween.prototype.exec = function(ctx) {
      var args, ref, result;
      args = this.execArgs(ctx);
      if ((args[0] == null) || (args[1] == null) || typeof args[0].durationBetween !== 'function' || typeof args[1].durationBetween !== 'function') {
        return null;
      }
      result = args[0].durationBetween(args[1], (ref = this.precision) != null ? ref.toLowerCase() : void 0);
      if ((result != null) && result.isPoint()) {
        return result.low;
      } else {
        return result;
      }
    };

    return DurationBetween;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":5,"./builder":15,"./expression":21,"./literal":28}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Expression, IncludeDef, UnimplementedExpression, UsingDef, VersionedIdentifier, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  module.exports.UsingDef = UsingDef = (function(superClass) {
    extend(UsingDef, superClass);

    function UsingDef() {
      return UsingDef.__super__.constructor.apply(this, arguments);
    }

    return UsingDef;

  })(UnimplementedExpression);

  module.exports.IncludeDef = IncludeDef = (function(superClass) {
    extend(IncludeDef, superClass);

    function IncludeDef() {
      return IncludeDef.__super__.constructor.apply(this, arguments);
    }

    return IncludeDef;

  })(UnimplementedExpression);

  module.exports.VersionedIdentifier = VersionedIdentifier = (function(superClass) {
    extend(VersionedIdentifier, superClass);

    function VersionedIdentifier() {
      return VersionedIdentifier.__super__.constructor.apply(this, arguments);
    }

    return VersionedIdentifier;

  })(UnimplementedExpression);

}).call(this);



},{"./expression":21}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Expression, UnimplementedExpression, build, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  build = require('./builder').build;

  typeIsArray = require('../util/util').typeIsArray;

  module.exports.Expression = Expression = (function() {
    function Expression(json) {
      var op;
      if (json.operand != null) {
        op = build(json.operand);
        if (typeIsArray(json.operand)) {
          this.args = op;
        } else {
          this.arg = op;
        }
      }
      if (json.localId != null) {
        this.localId = json.localId;
      }
    }

    Expression.prototype.execute = function(ctx) {
      var execValue;
      if (this.localId != null) {
        execValue = this.exec(ctx);
        ctx.rootContext().setLocalIdWithResult(this.localId, execValue);
        return execValue;
      } else {
        return this.exec(ctx);
      }
    };

    Expression.prototype.exec = function(ctx) {
      return this;
    };

    Expression.prototype.execArgs = function(ctx) {
      var arg, i, len, ref, results;
      switch (false) {
        case this.args == null:
          ref = this.args;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            arg = ref[i];
            results.push(arg.execute(ctx));
          }
          return results;
        case this.arg == null:
          return this.arg.execute(ctx);
        default:
          return null;
      }
    };

    return Expression;

  })();

  module.exports.UnimplementedExpression = UnimplementedExpression = (function(superClass) {
    extend(UnimplementedExpression, superClass);

    function UnimplementedExpression(json1) {
      this.json = json1;
      UnimplementedExpression.__super__.constructor.apply(this, arguments);
    }

    UnimplementedExpression.prototype.exec = function(ctx) {
      throw new Error("Unimplemented Expression: " + this.json.type);
    };

    return UnimplementedExpression;

  })(Expression);

}).call(this);



},{"../util/util":47,"./builder":15}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var aggregate, arithmetic, clinical, comparison, conditional, datetime, declaration, element, expression, external, i, instance, interval, j, len, len1, lib, libs, list, literal, logical, nullological, overloaded, parameters, quantity, query, ratio, ref, reusable, string, structured, type;

  expression = require('./expression');

  aggregate = require('./aggregate');

  arithmetic = require('./arithmetic');

  clinical = require('./clinical');

  comparison = require('./comparison');

  conditional = require('./conditional');

  datetime = require('./datetime');

  declaration = require('./declaration');

  external = require('./external');

  instance = require('./instance');

  interval = require('./interval');

  list = require('./list');

  literal = require('./literal');

  logical = require('./logical');

  nullological = require('./nullological');

  parameters = require('./parameters');

  quantity = require('./quantity');

  query = require('./query');

  ratio = require('./ratio');

  reusable = require('./reusable');

  string = require('./string');

  structured = require('./structured');

  type = require('./type');

  overloaded = require('./overloaded');

  libs = [expression, aggregate, arithmetic, clinical, comparison, conditional, datetime, declaration, external, instance, interval, list, literal, logical, nullological, parameters, query, quantity, ratio, reusable, string, structured, type, overloaded];

  for (i = 0, len = libs.length; i < len; i++) {
    lib = libs[i];
    ref = Object.keys(lib);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      element = ref[j];
      module.exports[element] = lib[element];
    }
  }

}).call(this);



},{"./aggregate":13,"./arithmetic":14,"./clinical":16,"./comparison":17,"./conditional":18,"./datetime":19,"./declaration":20,"./expression":21,"./external":23,"./instance":24,"./interval":25,"./list":27,"./literal":28,"./logical":29,"./nullological":30,"./overloaded":31,"./parameters":32,"./quantity":33,"./query":34,"./ratio":35,"./reusable":36,"./string":37,"./structured":38,"./type":39}],23:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Expression, Retrieve, build, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  typeIsArray = require('../util/util').typeIsArray;

  module.exports.Retrieve = Retrieve = (function(superClass) {
    extend(Retrieve, superClass);

    function Retrieve(json) {
      Retrieve.__super__.constructor.apply(this, arguments);
      this.datatype = json.dataType;
      this.templateId = json.templateId;
      this.codeProperty = json.codeProperty;
      this.codes = build(json.codes);
      this.dateProperty = json.dateProperty;
      this.dateRange = build(json.dateRange);
    }

    Retrieve.prototype.exec = function(ctx) {
      var codes, r, range, records, ref;
      records = ctx.findRecords((ref = this.templateId) != null ? ref : this.datatype);
      codes = this.codes;
      if (this.codes && typeof this.codes.exec === 'function') {
        codes = this.codes.execute(ctx);
        if (codes == null) {
          return [];
        }
      }
      if (codes) {
        records = records.filter((function(_this) {
          return function(r) {
            return _this.recordMatchesCodesOrVS(r, codes);
          };
        })(this));
      }
      if (this.dateRange && this.dateProperty) {
        range = this.dateRange.execute(ctx);
        records = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = records.length; i < len; i++) {
            r = records[i];
            if (range.includes(r.getDateOrInterval(this.dateProperty))) {
              results.push(r);
            }
          }
          return results;
        }).call(this);
      }
      return records;
    };

    Retrieve.prototype.recordMatchesCodesOrVS = function(record, codes) {
      if (typeIsArray(codes)) {
        return codes.some((function(_this) {
          return function(c) {
            return c.hasMatch(record.getCode(_this.codeProperty));
          };
        })(this));
      } else {
        return codes.hasMatch(record.getCode(this.codeProperty));
      }
    };

    return Retrieve;

  })(Expression);

}).call(this);



},{"../util/util":47,"./builder":15,"./expression":21}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Code, Concept, Element, Expression, Instance, Quantity, build, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  Quantity = require('../datatypes/quantity').Quantity;

  ref = require('../datatypes/datatypes'), Code = ref.Code, Concept = ref.Concept;

  Element = (function() {
    function Element(json) {
      this.name = json.name;
      this.value = build(json.value);
    }

    Element.prototype.exec = function(ctx) {
      var ref1;
      return (ref1 = this.value) != null ? ref1.execute(ctx) : void 0;
    };

    return Element;

  })();

  module.exports.Instance = Instance = (function(superClass) {
    extend(Instance, superClass);

    function Instance(json) {
      var child;
      Instance.__super__.constructor.apply(this, arguments);
      this.classType = json.classType;
      this.element = (function() {
        var i, len, ref1, results;
        ref1 = json.element;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          child = ref1[i];
          results.push(new Element(child));
        }
        return results;
      })();
    }

    Instance.prototype.exec = function(ctx) {
      var el, i, len, obj, ref1;
      obj = {};
      ref1 = this.element;
      for (i = 0, len = ref1.length; i < len; i++) {
        el = ref1[i];
        obj[el.name] = el.exec(ctx);
      }
      switch (this.classType) {
        case "{urn:hl7-org:elm-types:r1}Quantity":
          return new Quantity(obj.value, obj.unit);
        case "{urn:hl7-org:elm-types:r1}Code":
          return new Code(obj.code, obj.system, obj.version, obj.display);
        case "{urn:hl7-org:elm-types:r1}Concept":
          return new Concept(obj.codes, obj.display);
        default:
          return obj;
      }
    };

    return Instance;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":5,"../datatypes/quantity":10,"./builder":15,"./expression":21}],25:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Collapse, End, Ends, Expand, Expression, Interval, MAX_DATETIME_VALUE, MIN_DATETIME_VALUE, Meets, MeetsAfter, MeetsBefore, Overlaps, OverlapsAfter, OverlapsBefore, Quantity, Size, Start, Starts, ThreeValuedLogic, UnimplementedExpression, Width, build, cmp, collapseIntervals, compare_units, convert_value, doAddition, doIncludes, doSubtraction, dtivl, intervalListType, predecessor, ref, ref1, ref2, successor, truncateDecimal,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  ThreeValuedLogic = require('../datatypes/logic').ThreeValuedLogic;

  build = require('./builder').build;

  ref1 = require('../datatypes/quantity'), Quantity = ref1.Quantity, doAddition = ref1.doAddition, doSubtraction = ref1.doSubtraction, compare_units = ref1.compare_units, convert_value = ref1.convert_value;

  ref2 = require('../util/math'), successor = ref2.successor, predecessor = ref2.predecessor, MAX_DATETIME_VALUE = ref2.MAX_DATETIME_VALUE, MIN_DATETIME_VALUE = ref2.MIN_DATETIME_VALUE;

  dtivl = require('../datatypes/interval');

  cmp = require('../util/comparison');

  module.exports.Interval = Interval = (function(superClass) {
    extend(Interval, superClass);

    function Interval(json) {
      Interval.__super__.constructor.apply(this, arguments);
      this.lowClosed = json.lowClosed;
      this.highClosed = json.highClosed;
      this.low = build(json.low);
      this.high = build(json.high);
    }

    Object.defineProperties(Interval.prototype, {
      isInterval: {
        get: function() {
          return true;
        }
      }
    });

    Interval.prototype.exec = function(ctx) {
      return new dtivl.Interval(this.low.execute(ctx), this.high.execute(ctx), this.lowClosed, this.highClosed);
    };

    return Interval;

  })(Expression);

  module.exports.doContains = function(interval, item, precision) {
    return interval.contains(item, precision);
  };

  module.exports.doIncludes = doIncludes = function(interval, subinterval, precision) {
    return interval.includes(subinterval, precision);
  };

  module.exports.doProperIncludes = function(interval, subinterval, precision) {
    return interval.properlyIncludes(subinterval, precision);
  };

  module.exports.doAfter = function(a, b, precision) {
    return a.after(b, precision);
  };

  module.exports.doBefore = function(a, b, precision) {
    return a.before(b, precision);
  };

  module.exports.Meets = Meets = (function(superClass) {
    extend(Meets, superClass);

    function Meets(json) {
      var ref3;
      Meets.__super__.constructor.apply(this, arguments);
      this.precision = (ref3 = json.precision) != null ? ref3.toLowerCase() : void 0;
    }

    Meets.prototype.exec = function(ctx) {
      var a, b, ref3;
      ref3 = this.execArgs(ctx), a = ref3[0], b = ref3[1];
      if ((a != null) && (b != null)) {
        return a.meets(b, this.precision);
      } else {
        return null;
      }
    };

    return Meets;

  })(Expression);

  module.exports.MeetsAfter = MeetsAfter = (function(superClass) {
    extend(MeetsAfter, superClass);

    function MeetsAfter(json) {
      var ref3;
      MeetsAfter.__super__.constructor.apply(this, arguments);
      this.precision = (ref3 = json.precision) != null ? ref3.toLowerCase() : void 0;
    }

    MeetsAfter.prototype.exec = function(ctx) {
      var a, b, ref3;
      ref3 = this.execArgs(ctx), a = ref3[0], b = ref3[1];
      if ((a != null) && (b != null)) {
        return a.meetsAfter(b, this.precision);
      } else {
        return null;
      }
    };

    return MeetsAfter;

  })(Expression);

  module.exports.MeetsBefore = MeetsBefore = (function(superClass) {
    extend(MeetsBefore, superClass);

    function MeetsBefore(json) {
      var ref3;
      MeetsBefore.__super__.constructor.apply(this, arguments);
      this.precision = (ref3 = json.precision) != null ? ref3.toLowerCase() : void 0;
    }

    MeetsBefore.prototype.exec = function(ctx) {
      var a, b, ref3;
      ref3 = this.execArgs(ctx), a = ref3[0], b = ref3[1];
      if ((a != null) && (b != null)) {
        return a.meetsBefore(b, this.precision);
      } else {
        return null;
      }
    };

    return MeetsBefore;

  })(Expression);

  module.exports.Overlaps = Overlaps = (function(superClass) {
    extend(Overlaps, superClass);

    function Overlaps(json) {
      var ref3;
      Overlaps.__super__.constructor.apply(this, arguments);
      this.precision = (ref3 = json.precision) != null ? ref3.toLowerCase() : void 0;
    }

    Overlaps.prototype.exec = function(ctx) {
      var a, b, ref3;
      ref3 = this.execArgs(ctx), a = ref3[0], b = ref3[1];
      if ((a != null) && (b != null)) {
        return a.overlaps(b, this.precision);
      } else {
        return null;
      }
    };

    return Overlaps;

  })(Expression);

  module.exports.OverlapsAfter = OverlapsAfter = (function(superClass) {
    extend(OverlapsAfter, superClass);

    function OverlapsAfter(json) {
      var ref3;
      OverlapsAfter.__super__.constructor.apply(this, arguments);
      this.precision = (ref3 = json.precision) != null ? ref3.toLowerCase() : void 0;
    }

    OverlapsAfter.prototype.exec = function(ctx) {
      var a, b, ref3;
      ref3 = this.execArgs(ctx), a = ref3[0], b = ref3[1];
      if ((a != null) && (b != null)) {
        return a.overlapsAfter(b, this.precision);
      } else {
        return null;
      }
    };

    return OverlapsAfter;

  })(Expression);

  module.exports.OverlapsBefore = OverlapsBefore = (function(superClass) {
    extend(OverlapsBefore, superClass);

    function OverlapsBefore(json) {
      var ref3;
      OverlapsBefore.__super__.constructor.apply(this, arguments);
      this.precision = (ref3 = json.precision) != null ? ref3.toLowerCase() : void 0;
    }

    OverlapsBefore.prototype.exec = function(ctx) {
      var a, b, ref3;
      ref3 = this.execArgs(ctx), a = ref3[0], b = ref3[1];
      if ((a != null) && (b != null)) {
        return a.overlapsBefore(b, this.precision);
      } else {
        return null;
      }
    };

    return OverlapsBefore;

  })(Expression);

  module.exports.doUnion = function(a, b) {
    return a.union(b);
  };

  module.exports.doExcept = function(a, b) {
    if ((a != null) && (b != null)) {
      return a.except(b);
    } else {
      return null;
    }
  };

  module.exports.doIntersect = function(a, b) {
    if ((a != null) && (b != null)) {
      return a.intersect(b);
    } else {
      return null;
    }
  };

  module.exports.Width = Width = (function(superClass) {
    extend(Width, superClass);

    function Width(json) {
      Width.__super__.constructor.apply(this, arguments);
    }

    Width.prototype.exec = function(ctx) {
      var ref3;
      return (ref3 = this.arg.execute(ctx)) != null ? ref3.width() : void 0;
    };

    return Width;

  })(Expression);

  module.exports.Size = Size = (function(superClass) {
    extend(Size, superClass);

    function Size(json) {
      Size.__super__.constructor.apply(this, arguments);
    }

    Size.prototype.exec = function(ctx) {
      var interval;
      interval = this.arg.execute(ctx);
      if (interval == null) {
        return null;
      }
      return interval.size();
    };

    return Size;

  })(Expression);

  module.exports.Start = Start = (function(superClass) {
    extend(Start, superClass);

    function Start(json) {
      Start.__super__.constructor.apply(this, arguments);
    }

    Start.prototype.exec = function(ctx) {
      var interval, start;
      interval = this.arg.execute(ctx);
      if (interval == null) {
        return null;
      }
      start = interval.start();
      if ((start != null ? start.isDateTime : void 0) && start.equals(MIN_DATETIME_VALUE)) {
        start.timezoneOffset = ctx.getTimezoneOffset();
      }
      return start;
    };

    return Start;

  })(Expression);

  module.exports.End = End = (function(superClass) {
    extend(End, superClass);

    function End(json) {
      End.__super__.constructor.apply(this, arguments);
    }

    End.prototype.exec = function(ctx) {
      var end, interval;
      interval = this.arg.execute(ctx);
      if (interval == null) {
        return null;
      }
      end = interval.end();
      if ((end != null ? end.isDateTime : void 0) && end.equals(MAX_DATETIME_VALUE)) {
        end.timezoneOffset = ctx.getTimezoneOffset();
      }
      return end;
    };

    return End;

  })(Expression);

  module.exports.Starts = Starts = (function(superClass) {
    extend(Starts, superClass);

    function Starts(json) {
      var ref3;
      Starts.__super__.constructor.apply(this, arguments);
      this.precision = (ref3 = json.precision) != null ? ref3.toLowerCase() : void 0;
    }

    Starts.prototype.exec = function(ctx) {
      var a, b, ref3;
      ref3 = this.execArgs(ctx), a = ref3[0], b = ref3[1];
      if ((a != null) && (b != null)) {
        return a.starts(b, this.precision);
      } else {
        return null;
      }
    };

    return Starts;

  })(Expression);

  module.exports.Ends = Ends = (function(superClass) {
    extend(Ends, superClass);

    function Ends(json) {
      var ref3;
      Ends.__super__.constructor.apply(this, arguments);
      this.precision = (ref3 = json.precision) != null ? ref3.toLowerCase() : void 0;
    }

    Ends.prototype.exec = function(ctx) {
      var a, b, ref3;
      ref3 = this.execArgs(ctx), a = ref3[0], b = ref3[1];
      if ((a != null) && (b != null)) {
        return a.ends(b, this.precision);
      } else {
        return null;
      }
    };

    return Ends;

  })(Expression);

  intervalListType = function(intervals) {
    var high, i, itvl, len, low, ref3, ref4, type;
    type = null;
    for (i = 0, len = intervals.length; i < len; i++) {
      itvl = intervals[i];
      if (itvl == null) {
        continue;
      }
      if ((itvl.low == null) && (itvl.high == null)) {
        continue;
      }
      low = (ref3 = itvl.low) != null ? ref3 : itvl.high;
      high = (ref4 = itvl.high) != null ? ref4 : itvl.low;
      if ((typeof low.isTime === "function" ? low.isTime() : void 0) && (typeof high.isTime === "function" ? high.isTime() : void 0)) {
        if (type == null) {
          type = 'time';
        } else if (type === 'time') {
          continue;
        } else {
          return 'mismatch';
        }
      } else if ((low.isDateTime || high.isDateTime) && (low.isDateTime || low.isDate) && (high.isDateTime || high.isDate)) {
        if ((type == null) || type === 'date') {
          type = 'datetime';
        } else if (type === 'datetime') {
          continue;
        } else {
          return 'mismatch';
        }
      } else if (low.isDate && high.isDate) {
        if (type == null) {
          type = 'date';
        } else if (type === 'date' || 'datetime') {
          continue;
        } else {
          return 'mismatch';
        }
      } else if (low.isQuantity && high.isQuantity) {
        if (type == null) {
          type = 'quantity';
        } else if (type === 'quantity') {
          continue;
        } else {
          return 'mismatch';
        }
      } else if (Number.isInteger(low) && Number.isInteger(high)) {
        if (type == null) {
          type = 'integer';
        } else if (type === 'integer' || 'decimal') {
          continue;
        } else {
          return 'mismatch';
        }
      } else if (typeof low === 'number' && typeof high === 'number') {
        if ((type == null) || type === 'integer') {
          type = 'decimal';
        } else if (type === 'decimal') {
          continue;
        } else {
          return 'mismatch';
        }
      } else {
        return 'mismatch';
      }
    }
    return type;
  };

  module.exports.Expand = Expand = (function(superClass) {
    extend(Expand, superClass);

    function Expand(json) {
      Expand.__super__.constructor.apply(this, arguments);
    }

    Expand.prototype.exec = function(ctx) {
      var defaultPer, expandFunction, i, interval, intervals, items, len, per, ref3, results, type;
      ref3 = this.execArgs(ctx), intervals = ref3[0], per = ref3[1];
      type = intervalListType(intervals);
      if (type === 'mismatch') {
        throw new Error("List of intervals contains mismatched types.");
      }
      if (type == null) {
        return null;
      }
      intervals = collapseIntervals(intervals, per);
      if (intervals.length === 0) {
        return [];
      }
      if (type === "time" || type === "date" || type === "datetime") {
        expandFunction = this.expandDTishInterval;
        defaultPer = function(interval) {
          return new Quantity(1, interval.low.getPrecision());
        };
      } else if (type === "quantity") {
        expandFunction = this.expandQuantityInterval;
        defaultPer = function(interval) {
          return new Quantity(1, interval.low.unit);
        };
      } else if (type === "integer" || type === "decimal") {
        expandFunction = this.expandNumericInterval;
        defaultPer = function(interval) {
          return new Quantity(1, '1');
        };
      } else {
        throw new Error("Interval list type not yet supported.");
      }
      results = [];
      for (i = 0, len = intervals.length; i < len; i++) {
        interval = intervals[i];
        if (interval == null) {
          continue;
        }
        if ((interval.low == null) || (interval.high == null)) {
          return null;
        }
        if (type === 'datetime') {
          interval.low = interval.low.getDateTime();
          interval.high = interval.high.getDateTime();
        }
        per = per != null ? per : defaultPer(interval);
        items = expandFunction.call(this, interval, per);
        if (items === null) {
          return null;
        }
        results.push.apply(results, items);
      }
      return results;
    };

    Expand.prototype.expandDTishInterval = function(interval, per) {
      var current_high, current_low, high, intervalToAdd, low, ref3, ref4, results;
      if ((ref3 = per.unit) === 'week' || ref3 === 'weeks') {
        per.value *= 7;
        per.unit = 'day';
      }
      if (ref4 = per.unit, indexOf.call(interval.low.constructor.FIELDS, ref4) < 0) {
        return null;
      }
      if (!((interval.low != null) && (interval.high != null))) {
        return null;
      }
      low = interval.lowClosed ? interval.low : interval.low.successor();
      high = interval.highClosed ? interval.high : interval.high.predecessor();
      if (low.after(high)) {
        return [];
      }
      if (interval.low.isLessPrecise(per.unit) || interval.high.isLessPrecise(per.unit)) {
        return [];
      }
      current_low = low;
      results = [];
      low = this.truncateToPrecision(low, per.unit);
      high = this.truncateToPrecision(high, per.unit);
      current_high = current_low.add(per.value, per.unit).predecessor();
      intervalToAdd = new dtivl.Interval(current_low, current_high, true, true);
      while (intervalToAdd.high.sameOrBefore(high)) {
        results.push(intervalToAdd);
        current_low = current_low.add(per.value, per.unit);
        current_high = current_low.add(per.value, per.unit).predecessor();
        intervalToAdd = new dtivl.Interval(current_low, current_high, true, true);
      }
      return results;
    };

    Expand.prototype.truncateToPrecision = function(value, unit) {
      var field, i, len, ref3, shouldTruncate;
      shouldTruncate = false;
      ref3 = value.constructor.FIELDS;
      for (i = 0, len = ref3.length; i < len; i++) {
        field = ref3[i];
        if (shouldTruncate) {
          value[field] = null;
        }
        if (field === unit) {
          shouldTruncate = true;
        }
      }
      return value;
    };

    Expand.prototype.expandQuantityInterval = function(interval, per) {
      var high_value, i, itvl, len, low_value, per_value, result_units, results;
      if (compare_units(interval.low.unit, per.unit) > 0) {
        result_units = per.unit;
      } else {
        result_units = interval.low.unit;
      }
      low_value = convert_value(interval.low.value, interval.low.unit, result_units);
      high_value = convert_value(interval.high.value, interval.high.unit, result_units);
      per_value = convert_value(per.value, per.unit, result_units);
      if (!((low_value != null) && (high_value != null) && (per_value != null))) {
        return null;
      }
      results = this.makeNumericIntervalList(low_value, high_value, interval.lowClosed, interval.highClosed, per_value);
      for (i = 0, len = results.length; i < len; i++) {
        itvl = results[i];
        itvl.low = new Quantity(itvl.low, result_units);
        itvl.high = new Quantity(itvl.high, result_units);
      }
      return results;
    };

    Expand.prototype.expandNumericInterval = function(interval, per) {
      if (!(per.unit === '1' || per.unit === '')) {
        return null;
      }
      return this.makeNumericIntervalList(interval.low, interval.high, interval.lowClosed, interval.highClosed, per.value);
    };

    Expand.prototype.makeNumericIntervalList = function(low, high, lowClosed, highClosed, perValue) {
      var current_high, current_low, decimalPrecision, intervalToAdd, perIsDecimal, perUnitSize, results;
      perIsDecimal = perValue.toString().includes('.');
      decimalPrecision = perIsDecimal ? 8 : 0;
      low = lowClosed ? low : successor(low);
      high = highClosed ? high : predecessor(high);
      low = truncateDecimal(low, decimalPrecision);
      high = truncateDecimal(high, decimalPrecision);
      if (low > high) {
        return [];
      }
      if (!((low != null) && (high != null))) {
        return [];
      }
      perUnitSize = perIsDecimal ? 0.00000001 : 1;
      if (low === high && Number.isInteger(low) && Number.isInteger(high) && !Number.isInteger(perValue)) {
        high = parseFloat((high + 1).toFixed(decimalPrecision));
      }
      current_low = low;
      results = [];
      if (perValue > (high - low + perUnitSize)) {
        return [];
      }
      current_high = parseFloat((current_low + perValue - perUnitSize).toFixed(decimalPrecision));
      intervalToAdd = new dtivl.Interval(current_low, current_high, true, true);
      while (intervalToAdd.high <= high) {
        results.push(intervalToAdd);
        current_low = parseFloat((current_low + perValue).toFixed(decimalPrecision));
        current_high = parseFloat((current_low + perValue - perUnitSize).toFixed(decimalPrecision));
        intervalToAdd = new dtivl.Interval(current_low, current_high, true, true);
      }
      return results;
    };

    return Expand;

  })(Expression);

  module.exports.Collapse = Collapse = (function(superClass) {
    extend(Collapse, superClass);

    function Collapse(json) {
      Collapse.__super__.constructor.apply(this, arguments);
    }

    Collapse.prototype.exec = function(ctx) {
      var intervals, perWidth, ref3;
      ref3 = this.execArgs(ctx), intervals = ref3[0], perWidth = ref3[1];
      return collapseIntervals(intervals, perWidth);
    };

    return Collapse;

  })(Expression);

  collapseIntervals = function(intervals, perWidth) {
    var a, b, collapsedIntervals, i, interval, intervalsClone, len, ref3, ref4, ref5, ref6;
    intervalsClone = [];
    for (i = 0, len = intervals.length; i < len; i++) {
      interval = intervals[i];
      if (interval != null) {
        intervalsClone.push(interval.copy());
      }
    }
    if (intervals == null) {
      return null;
    } else if ((intervalsClone != null ? intervalsClone.length : void 0) <= 1) {
      return intervalsClone;
    } else {
      if (perWidth == null) {
        perWidth = intervalsClone[0].getPointSize();
      }
      intervalsClone.sort(function(a, b) {
        var ref3, ref4;
        if (typeof ((ref3 = a.low) != null ? ref3.before : void 0) === 'function') {
          if ((b.low != null) && a.low.before(b.low)) {
            return -1;
          }
          if ((b.low == null) || a.low.after(b.low)) {
            return 1;
          }
        } else if ((a.low != null) && (b.low != null)) {
          if (a.low < b.low) {
            return -1;
          }
          if (a.low > b.low) {
            return 1;
          }
        } else if ((a.low != null) && (b.low == null)) {
          return 1;
        } else if ((a.low == null) && (b.low != null)) {
          return -1;
        }
        if (typeof ((ref4 = a.high) != null ? ref4.before : void 0) === 'function') {
          if ((b.high == null) || a.high.before(b.high)) {
            return -1;
          }
          if (a.high.after(b.high)) {
            return 1;
          }
        } else if ((a.high != null) && (b.high != null)) {
          if (a.high < b.high) {
            return -1;
          }
          if (a.high > b.high) {
            return 1;
          }
        } else if ((a.high != null) && (b.high == null)) {
          return -1;
        } else if ((a.high == null) && (b.high != null)) {
          return 1;
        }
        return 0;
      });
      collapsedIntervals = [];
      a = intervalsClone.shift();
      b = intervalsClone.shift();
      while (b) {
        if (typeof ((ref3 = b.low) != null ? ref3.durationBetween : void 0) === 'function') {
          if ((ref4 = a.high) != null ? ref4.sameOrAfter(b.low) : void 0) {
            if ((b.high == null) || b.high.after(a.high)) {
              a.high = b.high;
            }
          } else if (((ref5 = a.high) != null ? ref5.durationBetween(b.low, perWidth.unit).high : void 0) <= perWidth.value) {
            a.high = b.high;
          } else {
            collapsedIntervals.push(a);
            a = b;
          }
        } else if (typeof ((ref6 = b.low) != null ? ref6.sameOrBefore : void 0) === 'function') {
          if ((a.high != null) && b.low.sameOrBefore(doAddition(a.high, perWidth))) {
            if ((b.high == null) || b.high.after(a.high)) {
              a.high = b.high;
            }
          } else {
            collapsedIntervals.push(a);
            a = b;
          }
        } else {
          if ((b.low - a.high) <= perWidth.value) {
            if (b.high > a.high || (b.high == null)) {
              a.high = b.high;
            }
          } else {
            collapsedIntervals.push(a);
            a = b;
          }
        }
        b = intervalsClone.shift();
      }
      collapsedIntervals.push(a);
      return collapsedIntervals;
    }
  };

  truncateDecimal = function(decimal, decimalPlaces) {
    var re;
    re = new RegExp('^-?\\d+(?:\.\\d{0,' + (decimalPlaces || -1) + '})?');
    return parseFloat(decimal.toString().match(re)[0]);
  };

}).call(this);



},{"../datatypes/interval":8,"../datatypes/logic":9,"../datatypes/quantity":10,"../util/comparison":45,"../util/math":46,"./builder":15,"./expression":21}],26:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var CodeDef, CodeSystemDef, ConceptDef, ExpressionDef, FunctionDef, Library, ParameterDef, Results, ValueSetDef, ref;

  module.exports.Library = Library = (function() {
    function Library(json, libraryManager) {
      var code, codesystem, concept, expr, i, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, m, n, o, p, param, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref3, ref4, ref5, ref6, ref7, ref8, ref9, u, valueset;
      this.source = json;
      this.usings = [];
      ref2 = (ref = (ref1 = json.library.usings) != null ? ref1.def : void 0) != null ? ref : [];
      for (i = 0, len = ref2.length; i < len; i++) {
        u = ref2[i];
        if (u.localIdentifier !== "System") {
          this.usings.push({
            "name": u.localIdentifier,
            "version": u.version
          });
        }
      }
      this.parameters = {};
      ref5 = (ref3 = (ref4 = json.library.parameters) != null ? ref4.def : void 0) != null ? ref3 : [];
      for (j = 0, len1 = ref5.length; j < len1; j++) {
        param = ref5[j];
        this.parameters[param.name] = new ParameterDef(param);
      }
      this.codesystems = {};
      ref8 = (ref6 = (ref7 = json.library.codeSystems) != null ? ref7.def : void 0) != null ? ref6 : [];
      for (k = 0, len2 = ref8.length; k < len2; k++) {
        codesystem = ref8[k];
        this.codesystems[codesystem.name] = new CodeSystemDef(codesystem);
      }
      this.valuesets = {};
      ref11 = (ref9 = (ref10 = json.library.valueSets) != null ? ref10.def : void 0) != null ? ref9 : [];
      for (l = 0, len3 = ref11.length; l < len3; l++) {
        valueset = ref11[l];
        this.valuesets[valueset.name] = new ValueSetDef(valueset);
      }
      this.codes = {};
      ref14 = (ref12 = (ref13 = json.library.codes) != null ? ref13.def : void 0) != null ? ref12 : [];
      for (m = 0, len4 = ref14.length; m < len4; m++) {
        code = ref14[m];
        this.codes[code.name] = new CodeDef(code);
      }
      this.concepts = {};
      ref17 = (ref15 = (ref16 = json.library.concepts) != null ? ref16.def : void 0) != null ? ref15 : [];
      for (n = 0, len5 = ref17.length; n < len5; n++) {
        concept = ref17[n];
        this.concepts[concept.name] = new ConceptDef(concept);
      }
      this.expressions = {};
      ref20 = (ref18 = (ref19 = json.library.statements) != null ? ref19.def : void 0) != null ? ref18 : [];
      for (o = 0, len6 = ref20.length; o < len6; o++) {
        expr = ref20[o];
        this.expressions[expr.name] = expr.type === "FunctionDef" ? new FunctionDef(expr) : new ExpressionDef(expr);
      }
      this.includes = {};
      ref23 = (ref21 = (ref22 = json.library.includes) != null ? ref22.def : void 0) != null ? ref21 : [];
      for (p = 0, len7 = ref23.length; p < len7; p++) {
        expr = ref23[p];
        if (libraryManager) {
          this.includes[expr.localIdentifier] = libraryManager.resolve(expr.path, expr.version);
        }
      }
    }

    Library.prototype.get = function(identifier) {
      return this.expressions[identifier] || this.includes[identifier];
    };

    Library.prototype.getValueSet = function(identifier, libraryName) {
      var ref;
      if (this.valuesets[identifier] != null) {
        return this.valuesets[identifier];
      }
      return (ref = this.includes[libraryName]) != null ? ref.valuesets[identifier] : void 0;
    };

    Library.prototype.getCodeSystem = function(identifier) {
      return this.codesystems[identifier];
    };

    Library.prototype.getCode = function(identifier) {
      return this.codes[identifier];
    };

    Library.prototype.getConcept = function(identifier) {
      return this.concepts[identifier];
    };

    Library.prototype.getParameter = function(name) {
      return this.parameters[name];
    };

    return Library;

  })();

  ref = require('./expressions'), ExpressionDef = ref.ExpressionDef, FunctionDef = ref.FunctionDef, ParameterDef = ref.ParameterDef, ValueSetDef = ref.ValueSetDef, CodeSystemDef = ref.CodeSystemDef, CodeDef = ref.CodeDef, ConceptDef = ref.ConceptDef;

  Results = require('../runtime/results').Results;

}).call(this);



},{"../runtime/results":44,"./expressions":22}],27:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Current, Distinct, Exists, Expression, Filter, First, Flatten, ForEach, IndexOf, Last, List, SingletonFrom, Times, ToList, UnimplementedExpression, ValueSet, build, doContains, doDistinct, doIncludes, equals, ref, removeDuplicateNulls, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  ValueSet = require('../datatypes/datatypes').ValueSet;

  build = require('./builder').build;

  typeIsArray = require('../util/util').typeIsArray;

  equals = require('../util/comparison').equals;

  module.exports.List = List = (function(superClass) {
    extend(List, superClass);

    function List(json) {
      var ref1;
      List.__super__.constructor.apply(this, arguments);
      this.elements = (ref1 = build(json.element)) != null ? ref1 : [];
    }

    Object.defineProperties(List.prototype, {
      isList: {
        get: function() {
          return true;
        }
      }
    });

    List.prototype.exec = function(ctx) {
      var item, j, len, ref1, results;
      ref1 = this.elements;
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        item = ref1[j];
        results.push(item.execute(ctx));
      }
      return results;
    };

    return List;

  })(Expression);

  module.exports.Exists = Exists = (function(superClass) {
    extend(Exists, superClass);

    function Exists(json) {
      Exists.__super__.constructor.apply(this, arguments);
    }

    Exists.prototype.exec = function(ctx) {
      var item, j, len, list;
      list = this.execArgs(ctx);
      if ((list != null ? list.length : void 0) > 0) {
        for (j = 0, len = list.length; j < len; j++) {
          item = list[j];
          if (item !== null) {
            return true;
          }
        }
      }
      return false;
    };

    return Exists;

  })(Expression);

  module.exports.doUnion = function(a, b) {
    var distinct;
    distinct = doDistinct(a.concat(b));
    return removeDuplicateNulls(distinct);
  };

  module.exports.doExcept = function(a, b) {
    var distinct, itm, j, len, results, setList;
    distinct = doDistinct(a);
    setList = removeDuplicateNulls(distinct);
    results = [];
    for (j = 0, len = setList.length; j < len; j++) {
      itm = setList[j];
      if (!doContains(b, itm)) {
        results.push(itm);
      }
    }
    return results;
  };

  module.exports.doIntersect = function(a, b) {
    var distinct, itm, j, len, results, setList;
    distinct = doDistinct(a);
    setList = removeDuplicateNulls(distinct);
    results = [];
    for (j = 0, len = setList.length; j < len; j++) {
      itm = setList[j];
      if (doContains(b, itm)) {
        results.push(itm);
      }
    }
    return results;
  };

  module.exports.Times = Times = (function(superClass) {
    extend(Times, superClass);

    function Times() {
      return Times.__super__.constructor.apply(this, arguments);
    }

    return Times;

  })(UnimplementedExpression);

  module.exports.Filter = Filter = (function(superClass) {
    extend(Filter, superClass);

    function Filter() {
      return Filter.__super__.constructor.apply(this, arguments);
    }

    return Filter;

  })(UnimplementedExpression);

  module.exports.SingletonFrom = SingletonFrom = (function(superClass) {
    extend(SingletonFrom, superClass);

    function SingletonFrom(json) {
      SingletonFrom.__super__.constructor.apply(this, arguments);
    }

    SingletonFrom.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && arg.length > 1) {
        throw new Error('IllegalArgument: \'SingletonFrom\' requires a 0 or 1 arg array');
      } else if ((arg != null) && arg.length === 1) {
        return arg[0];
      } else {
        return null;
      }
    };

    return SingletonFrom;

  })(Expression);

  module.exports.ToList = ToList = (function(superClass) {
    extend(ToList, superClass);

    function ToList(json) {
      ToList.__super__.constructor.apply(this, arguments);
    }

    ToList.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return [arg];
      } else {
        return [];
      }
    };

    return ToList;

  })(Expression);

  module.exports.IndexOf = IndexOf = (function(superClass) {
    extend(IndexOf, superClass);

    function IndexOf(json) {
      IndexOf.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
      this.element = build(json.element);
    }

    IndexOf.prototype.exec = function(ctx) {
      var el, i, index, itm, j, len, src;
      src = this.source.execute(ctx);
      el = this.element.execute(ctx);
      if ((src == null) || (el == null)) {
        return null;
      }
      for (i = j = 0, len = src.length; j < len; i = ++j) {
        itm = src[i];
        if (equals(itm, el)) {
          index = i;
          break;
        }
      }
      if (index != null) {
        return index;
      } else {
        return -1;
      }
    };

    return IndexOf;

  })(Expression);

  module.exports.doContains = doContains = function(container, item) {
    var element, j, len;
    for (j = 0, len = container.length; j < len; j++) {
      element = container[j];
      if (equals(element, item)) {
        return true;
      }
    }
    return false;
  };

  module.exports.doIncludes = doIncludes = function(list, sublist) {
    return sublist.every(function(x) {
      return doContains(list, x);
    });
  };

  module.exports.doProperIncludes = function(list, sublist) {
    return list.length > sublist.length && doIncludes(list, sublist);
  };

  module.exports.ForEach = ForEach = (function(superClass) {
    extend(ForEach, superClass);

    function ForEach() {
      return ForEach.__super__.constructor.apply(this, arguments);
    }

    return ForEach;

  })(UnimplementedExpression);

  module.exports.Flatten = Flatten = (function(superClass) {
    extend(Flatten, superClass);

    function Flatten(json) {
      Flatten.__super__.constructor.apply(this, arguments);
    }

    Flatten.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (typeIsArray(arg) && (arg.every(function(x) {
        return typeIsArray(x);
      }))) {
        return arg.reduce((function(x, y) {
          return x.concat(y);
        }), []);
      } else {
        return arg;
      }
    };

    return Flatten;

  })(Expression);

  module.exports.Distinct = Distinct = (function(superClass) {
    extend(Distinct, superClass);

    function Distinct(json) {
      Distinct.__super__.constructor.apply(this, arguments);
    }

    Distinct.prototype.exec = function(ctx) {
      var result;
      result = this.execArgs(ctx);
      if (result == null) {
        return null;
      }
      return doDistinct(result);
    };

    return Distinct;

  })(Expression);

  doDistinct = function(list) {
    var distinct;
    distinct = [];
    list.filter(function(item) {
      var isNew;
      isNew = distinct.every(function(seenItem) {
        return !equals(item, seenItem);
      });
      if (isNew) {
        distinct.push(item);
      }
      return isNew;
    });
    return distinct;
  };

  removeDuplicateNulls = function(list) {
    var firstNullFound, item, j, len, setList;
    firstNullFound = false;
    setList = [];
    for (j = 0, len = list.length; j < len; j++) {
      item = list[j];
      if (item !== null) {
        setList.push(item);
      }
      if (item === null && !firstNullFound) {
        setList.push(item);
        firstNullFound = true;
      }
    }
    return setList;
  };

  module.exports.Current = Current = (function(superClass) {
    extend(Current, superClass);

    function Current() {
      return Current.__super__.constructor.apply(this, arguments);
    }

    return Current;

  })(UnimplementedExpression);

  module.exports.First = First = (function(superClass) {
    extend(First, superClass);

    function First(json) {
      First.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
    }

    First.prototype.exec = function(ctx) {
      var src;
      src = this.source.exec(ctx);
      if ((src != null) && typeIsArray(src) && src.length > 0) {
        return src[0];
      } else {
        return null;
      }
    };

    return First;

  })(Expression);

  module.exports.Last = Last = (function(superClass) {
    extend(Last, superClass);

    function Last(json) {
      Last.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
    }

    Last.prototype.exec = function(ctx) {
      var src;
      src = this.source.exec(ctx);
      if ((src != null) && typeIsArray(src) && src.length > 0) {
        return src[src.length - 1];
      } else {
        return null;
      }
    };

    return Last;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":5,"../util/comparison":45,"../util/util":47,"./builder":15,"./expression":21}],28:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var BooleanLiteral, DecimalLiteral, Expression, IntegerLiteral, Literal, StringLiteral,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  module.exports.Literal = Literal = (function(superClass) {
    extend(Literal, superClass);

    Literal.from = function(json) {
      switch (json.valueType) {
        case "{urn:hl7-org:elm-types:r1}Boolean":
          return new BooleanLiteral(json);
        case "{urn:hl7-org:elm-types:r1}Integer":
          return new IntegerLiteral(json);
        case "{urn:hl7-org:elm-types:r1}Decimal":
          return new DecimalLiteral(json);
        case "{urn:hl7-org:elm-types:r1}String":
          return new StringLiteral(json);
        default:
          return new Literal(json);
      }
    };

    function Literal(json) {
      Literal.__super__.constructor.apply(this, arguments);
      this.valueType = json.valueType;
      this.value = json.value;
    }

    Literal.prototype.exec = function(ctx) {
      return this.value;
    };

    return Literal;

  })(Expression);

  module.exports.BooleanLiteral = BooleanLiteral = (function(superClass) {
    extend(BooleanLiteral, superClass);

    function BooleanLiteral(json) {
      BooleanLiteral.__super__.constructor.apply(this, arguments);
      this.value = this.value === 'true';
    }

    Object.defineProperties(BooleanLiteral.prototype, {
      isBooleanLiteral: {
        get: function() {
          return true;
        }
      }
    });

    BooleanLiteral.prototype.exec = function(ctx) {
      return this.value;
    };

    return BooleanLiteral;

  })(Literal);

  module.exports.IntegerLiteral = IntegerLiteral = (function(superClass) {
    extend(IntegerLiteral, superClass);

    function IntegerLiteral(json) {
      IntegerLiteral.__super__.constructor.apply(this, arguments);
      this.value = parseInt(this.value, 10);
    }

    Object.defineProperties(IntegerLiteral.prototype, {
      isIntegerLiteral: {
        get: function() {
          return true;
        }
      }
    });

    IntegerLiteral.prototype.exec = function(ctx) {
      return this.value;
    };

    return IntegerLiteral;

  })(Literal);

  module.exports.DecimalLiteral = DecimalLiteral = (function(superClass) {
    extend(DecimalLiteral, superClass);

    function DecimalLiteral(json) {
      DecimalLiteral.__super__.constructor.apply(this, arguments);
      this.value = parseFloat(this.value);
    }

    Object.defineProperties(DecimalLiteral.prototype, {
      isDecimalLiteral: {
        get: function() {
          return true;
        }
      }
    });

    DecimalLiteral.prototype.exec = function(ctx) {
      return this.value;
    };

    return DecimalLiteral;

  })(Literal);

  module.exports.StringLiteral = StringLiteral = (function(superClass) {
    extend(StringLiteral, superClass);

    function StringLiteral(json) {
      StringLiteral.__super__.constructor.apply(this, arguments);
    }

    Object.defineProperties(StringLiteral.prototype, {
      isStringLiteral: {
        get: function() {
          return true;
        }
      }
    });

    StringLiteral.prototype.exec = function(ctx) {
      return this.value.replace(/\\'/g, "'").replace(/\\"/g, "\"");
    };

    return StringLiteral;

  })(Literal);

}).call(this);



},{"./expression":21}],29:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var And, Expression, IsFalse, IsTrue, Not, Or, ThreeValuedLogic, Xor,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  ThreeValuedLogic = require('../datatypes/datatypes').ThreeValuedLogic;

  module.exports.And = And = (function(superClass) {
    extend(And, superClass);

    function And(json) {
      And.__super__.constructor.apply(this, arguments);
    }

    And.prototype.exec = function(ctx) {
      return ThreeValuedLogic.and.apply(ThreeValuedLogic, this.execArgs(ctx));
    };

    return And;

  })(Expression);

  module.exports.Or = Or = (function(superClass) {
    extend(Or, superClass);

    function Or(json) {
      Or.__super__.constructor.apply(this, arguments);
    }

    Or.prototype.exec = function(ctx) {
      return ThreeValuedLogic.or.apply(ThreeValuedLogic, this.execArgs(ctx));
    };

    return Or;

  })(Expression);

  module.exports.Not = Not = (function(superClass) {
    extend(Not, superClass);

    function Not(json) {
      Not.__super__.constructor.apply(this, arguments);
    }

    Not.prototype.exec = function(ctx) {
      return ThreeValuedLogic.not(this.execArgs(ctx));
    };

    return Not;

  })(Expression);

  module.exports.Xor = Xor = (function(superClass) {
    extend(Xor, superClass);

    function Xor(json) {
      Xor.__super__.constructor.apply(this, arguments);
    }

    Xor.prototype.exec = function(ctx) {
      return ThreeValuedLogic.xor.apply(ThreeValuedLogic, this.execArgs(ctx));
    };

    return Xor;

  })(Expression);

  module.exports.IsTrue = IsTrue = (function(superClass) {
    extend(IsTrue, superClass);

    function IsTrue(json) {
      IsTrue.__super__.constructor.apply(this, arguments);
    }

    IsTrue.prototype.exec = function(ctx) {
      return true === this.execArgs(ctx);
    };

    return IsTrue;

  })(Expression);

  module.exports.IsFalse = IsFalse = (function(superClass) {
    extend(IsFalse, superClass);

    function IsFalse(json) {
      IsFalse.__super__.constructor.apply(this, arguments);
    }

    IsFalse.prototype.exec = function(ctx) {
      return false === this.execArgs(ctx);
    };

    return IsFalse;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":5,"./expression":21}],30:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Coalesce, Expression, IsNull, Null,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  module.exports.Null = Null = (function(superClass) {
    extend(Null, superClass);

    function Null(json) {
      Null.__super__.constructor.apply(this, arguments);
    }

    Null.prototype.exec = function(ctx) {
      return null;
    };

    return Null;

  })(Expression);

  module.exports.IsNull = IsNull = (function(superClass) {
    extend(IsNull, superClass);

    function IsNull(json) {
      IsNull.__super__.constructor.apply(this, arguments);
    }

    IsNull.prototype.exec = function(ctx) {
      return this.execArgs(ctx) == null;
    };

    return IsNull;

  })(Expression);

  module.exports.Coalesce = Coalesce = (function(superClass) {
    extend(Coalesce, superClass);

    function Coalesce(json) {
      Coalesce.__super__.constructor.apply(this, arguments);
    }

    Coalesce.prototype.exec = function(ctx) {
      var arg, i, item, j, len, len1, ref, result;
      ref = this.args;
      for (i = 0, len = ref.length; i < len; i++) {
        arg = ref[i];
        result = arg.execute(ctx);
        if (this.args.length === 1 && Array.isArray(result)) {
          for (j = 0, len1 = result.length; j < len1; j++) {
            item = result[j];
            if (item != null) {
              return item;
            }
          }
        } else {
          if (result != null) {
            return result;
          }
        }
      }
      return null;
    };

    return Coalesce;

  })(Expression);

}).call(this);



},{"./expression":21}],31:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var After, Contains, DT, DateTime, Equal, Equivalent, Except, Exception, Expression, IVL, In, IncludedIn, Includes, Indexer, Intersect, LIST, Length, NotEqual, ProperIncludedIn, ProperIncludes, STRING, SameAs, SameOrAfter, SameOrBefore, ThreeValuedLogic, Union, build, equals, equivalent, ref, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  ThreeValuedLogic = require('../datatypes/logic').ThreeValuedLogic;

  DateTime = require('../datatypes/datetime').DateTime;

  Exception = require('../datatypes/exception').Exception;

  typeIsArray = require('../util/util').typeIsArray;

  ref = require('../util/comparison'), equals = ref.equals, equivalent = ref.equivalent;

  build = require('./builder').build;

  DT = require('./datetime');

  LIST = require('./list');

  IVL = require('./interval');

  STRING = require('./string');

  module.exports.Equal = Equal = (function(superClass) {
    extend(Equal, superClass);

    function Equal(json) {
      Equal.__super__.constructor.apply(this, arguments);
    }

    Equal.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if (!((args[0] != null) && (args[1] != null))) {
        return null;
      }
      return equals.apply(null, this.execArgs(ctx));
    };

    return Equal;

  })(Expression);

  module.exports.Equivalent = Equivalent = (function(superClass) {
    extend(Equivalent, superClass);

    function Equivalent(json) {
      Equivalent.__super__.constructor.apply(this, arguments);
    }

    Equivalent.prototype.exec = function(ctx) {
      var a, b, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a == null) && (b == null)) {
        return true;
      } else if ((a == null) || (b == null)) {
        return false;
      } else {
        return equivalent(a, b);
      }
    };

    return Equivalent;

  })(Expression);

  module.exports.NotEqual = NotEqual = (function(superClass) {
    extend(NotEqual, superClass);

    function NotEqual(json) {
      NotEqual.__super__.constructor.apply(this, arguments);
    }

    NotEqual.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if (!((args[0] != null) && (args[1] != null))) {
        return null;
      }
      return ThreeValuedLogic.not(equals.apply(null, this.execArgs(ctx)));
    };

    return NotEqual;

  })(Expression);

  module.exports.Union = Union = (function(superClass) {
    extend(Union, superClass);

    function Union(json) {
      Union.__super__.constructor.apply(this, arguments);
    }

    Union.prototype.exec = function(ctx) {
      var a, b, lib, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(a):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doUnion(a, b);
    };

    return Union;

  })(Expression);

  module.exports.Except = Except = (function(superClass) {
    extend(Except, superClass);

    function Except(json) {
      Except.__super__.constructor.apply(this, arguments);
    }

    Except.prototype.exec = function(ctx) {
      var a, b, lib, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(a):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doExcept(a, b);
    };

    return Except;

  })(Expression);

  module.exports.Intersect = Intersect = (function(superClass) {
    extend(Intersect, superClass);

    function Intersect(json) {
      Intersect.__super__.constructor.apply(this, arguments);
    }

    Intersect.prototype.exec = function(ctx) {
      var a, b, lib, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(a):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doIntersect(a, b);
    };

    return Intersect;

  })(Expression);

  module.exports.Indexer = Indexer = (function(superClass) {
    extend(Indexer, superClass);

    function Indexer(json) {
      Indexer.__super__.constructor.apply(this, arguments);
    }

    Indexer.prototype.exec = function(ctx) {
      var index, operand, ref1;
      ref1 = this.execArgs(ctx), operand = ref1[0], index = ref1[1];
      if ((operand == null) || (index == null)) {
        return null;
      }
      if (index < 0 || index >= operand.length) {
        return null;
      }
      return operand[index];
    };

    return Indexer;

  })(Expression);

  module.exports.In = In = (function(superClass) {
    extend(In, superClass);

    function In(json) {
      var ref1;
      In.__super__.constructor.apply(this, arguments);
      this.precision = (ref1 = json.precision) != null ? ref1.toLowerCase() : void 0;
    }

    In.prototype.exec = function(ctx) {
      var container, item, lib, ref1;
      ref1 = this.execArgs(ctx), item = ref1[0], container = ref1[1];
      if ((container == null) || (item == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doContains(container, item, this.precision);
    };

    return In;

  })(Expression);

  module.exports.Contains = Contains = (function(superClass) {
    extend(Contains, superClass);

    function Contains(json) {
      var ref1;
      Contains.__super__.constructor.apply(this, arguments);
      this.precision = (ref1 = json.precision) != null ? ref1.toLowerCase() : void 0;
    }

    Contains.prototype.exec = function(ctx) {
      var container, item, lib, ref1;
      ref1 = this.execArgs(ctx), container = ref1[0], item = ref1[1];
      if ((container == null) || (item == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doContains(container, item, this.precision);
    };

    return Contains;

  })(Expression);

  module.exports.Includes = Includes = (function(superClass) {
    extend(Includes, superClass);

    function Includes(json) {
      var ref1;
      Includes.__super__.constructor.apply(this, arguments);
      this.precision = (ref1 = json.precision) != null ? ref1.toLowerCase() : void 0;
    }

    Includes.prototype.exec = function(ctx) {
      var contained, container, lib, ref1;
      ref1 = this.execArgs(ctx), container = ref1[0], contained = ref1[1];
      if ((container == null) || (contained == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doIncludes(container, contained, this.precision);
    };

    return Includes;

  })(Expression);

  module.exports.IncludedIn = IncludedIn = (function(superClass) {
    extend(IncludedIn, superClass);

    function IncludedIn(json) {
      var ref1;
      IncludedIn.__super__.constructor.apply(this, arguments);
      this.precision = (ref1 = json.precision) != null ? ref1.toLowerCase() : void 0;
    }

    IncludedIn.prototype.exec = function(ctx) {
      var contained, container, lib, ref1;
      ref1 = this.execArgs(ctx), contained = ref1[0], container = ref1[1];
      if ((container == null) || (contained == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doIncludes(container, contained, this.precision);
    };

    return IncludedIn;

  })(Expression);

  module.exports.ProperIncludes = ProperIncludes = (function(superClass) {
    extend(ProperIncludes, superClass);

    function ProperIncludes(json) {
      var ref1;
      ProperIncludes.__super__.constructor.apply(this, arguments);
      this.precision = (ref1 = json.precision) != null ? ref1.toLowerCase() : void 0;
    }

    ProperIncludes.prototype.exec = function(ctx) {
      var contained, container, lib, ref1;
      ref1 = this.execArgs(ctx), container = ref1[0], contained = ref1[1];
      if ((container == null) || (contained == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doProperIncludes(container, contained, this.precision);
    };

    return ProperIncludes;

  })(Expression);

  module.exports.ProperIncludedIn = ProperIncludedIn = (function(superClass) {
    extend(ProperIncludedIn, superClass);

    function ProperIncludedIn(json) {
      var ref1;
      ProperIncludedIn.__super__.constructor.apply(this, arguments);
      this.precision = (ref1 = json.precision) != null ? ref1.toLowerCase() : void 0;
    }

    ProperIncludedIn.prototype.exec = function(ctx) {
      var contained, container, lib, ref1;
      ref1 = this.execArgs(ctx), contained = ref1[0], container = ref1[1];
      if ((container == null) || (contained == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !typeIsArray(container):
            return LIST;
          default:
            return IVL;
        }
      })();
      return lib.doProperIncludes(container, contained, this.precision);
    };

    return ProperIncludedIn;

  })(Expression);

  module.exports.Length = Length = (function(superClass) {
    extend(Length, superClass);

    function Length(json) {
      Length.__super__.constructor.apply(this, arguments);
    }

    Length.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return arg.length;
      } else {
        return null;
      }
    };

    return Length;

  })(Expression);

  module.exports.After = After = (function(superClass) {
    extend(After, superClass);

    function After(json) {
      var ref1;
      After.__super__.constructor.apply(this, arguments);
      this.precision = (ref1 = json.precision) != null ? ref1.toLowerCase() : void 0;
    }

    After.prototype.exec = function(ctx) {
      var a, b, lib, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !(a instanceof DateTime):
            return DT;
          default:
            return IVL;
        }
      })();
      return lib.doAfter(a, b, this.precision);
    };

    return After;

  })(Expression);

  module.exports.Before = After = (function(superClass) {
    extend(After, superClass);

    function After(json) {
      var ref1;
      After.__super__.constructor.apply(this, arguments);
      this.precision = (ref1 = json.precision) != null ? ref1.toLowerCase() : void 0;
    }

    After.prototype.exec = function(ctx) {
      var a, b, lib, ref1;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a == null) || (b == null)) {
        return null;
      }
      lib = (function() {
        switch (false) {
          case !(a instanceof DateTime):
            return DT;
          default:
            return IVL;
        }
      })();
      return lib.doBefore(a, b, this.precision);
    };

    return After;

  })(Expression);

  module.exports.SameAs = SameAs = (function(superClass) {
    extend(SameAs, superClass);

    function SameAs(json) {
      SameAs.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    SameAs.prototype.exec = function(ctx) {
      var a, b, ref1, ref2;
      ref1 = this.execArgs(ctx), a = ref1[0], b = ref1[1];
      if ((a != null) && (b != null)) {
        return a.sameAs(b, (ref2 = this.precision) != null ? ref2.toLowerCase() : void 0);
      } else {
        return null;
      }
    };

    return SameAs;

  })(Expression);

  module.exports.SameOrAfter = SameOrAfter = (function(superClass) {
    extend(SameOrAfter, superClass);

    function SameOrAfter(json) {
      SameOrAfter.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    SameOrAfter.prototype.exec = function(ctx) {
      var d1, d2, ref1, ref2;
      ref1 = this.execArgs(ctx), d1 = ref1[0], d2 = ref1[1];
      if ((d1 != null) && (d2 != null)) {
        return d1.sameOrAfter(d2, (ref2 = this.precision) != null ? ref2.toLowerCase() : void 0);
      } else {
        return null;
      }
    };

    return SameOrAfter;

  })(Expression);

  module.exports.SameOrBefore = SameOrBefore = (function(superClass) {
    extend(SameOrBefore, superClass);

    function SameOrBefore(json) {
      SameOrBefore.__super__.constructor.apply(this, arguments);
      this.precision = json.precision;
    }

    SameOrBefore.prototype.exec = function(ctx) {
      var d1, d2, ref1, ref2;
      ref1 = this.execArgs(ctx), d1 = ref1[0], d2 = ref1[1];
      if ((d1 != null) && (d2 != null)) {
        return d1.sameOrBefore(d2, (ref2 = this.precision) != null ? ref2.toLowerCase() : void 0);
      } else {
        return null;
      }
    };

    return SameOrBefore;

  })(Expression);

}).call(this);



},{"../datatypes/datetime":6,"../datatypes/exception":7,"../datatypes/logic":9,"../util/comparison":45,"../util/util":47,"./builder":15,"./datetime":19,"./expression":21,"./interval":25,"./list":27,"./string":37}],32:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Expression, ParameterDef, ParameterRef, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  module.exports.ParameterDef = ParameterDef = (function(superClass) {
    extend(ParameterDef, superClass);

    function ParameterDef(json) {
      ParameterDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this["default"] = build(json["default"]);
      this.parameterTypeSpecifier = json.parameterTypeSpecifier;
    }

    ParameterDef.prototype.exec = function(ctx) {
      var ref;
      if (((ctx != null ? ctx.parameters[this.name] : void 0) != null)) {
        return ctx.parameters[this.name];
      } else if (this["default"] != null) {
        return (ref = this["default"]) != null ? ref.execute(ctx) : void 0;
      } else {
        return ctx.getParentParameter(this.name);
      }
    };

    return ParameterDef;

  })(Expression);

  module.exports.ParameterRef = ParameterRef = (function(superClass) {
    extend(ParameterRef, superClass);

    function ParameterRef(json) {
      ParameterRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.library = json.libraryName;
    }

    ParameterRef.prototype.exec = function(ctx) {
      var ref;
      ctx = this.library ? ctx.getLibraryContext(this.library) : ctx;
      return (ref = ctx.getParameter(this.name)) != null ? ref.execute(ctx) : void 0;
    };

    return ParameterRef;

  })(Expression);

}).call(this);



},{"./builder":15,"./expression":21}],33:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Code, DT, Exception, Expression, FunctionRef, Quantity, ValueSet, build, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  FunctionRef = require('./reusable').FunctionRef;

  ref = require('../datatypes/datatypes'), ValueSet = ref.ValueSet, Code = ref.Code;

  Exception = require('../datatypes/exception').Exception;

  build = require('./builder').build;

  DT = require('../datatypes/datatypes');

  module.exports.Quantity = Quantity = (function(superClass) {
    extend(Quantity, superClass);

    function Quantity(json) {
      Quantity.__super__.constructor.apply(this, arguments);
      this.value = parseFloat(json.value);
      this.unit = json.unit;
    }

    Quantity.prototype.exec = function(ctx) {
      return new DT.Quantity(this.value, this.unit);
    };

    return Quantity;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":5,"../datatypes/exception":7,"./builder":15,"./expression":21,"./reusable":36}],34:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var AliasRef, AliasedQuerySource, ByColumn, ByDirection, ByExpression, Context, Expression, LetClause, MultiSource, Query, QueryLetRef, ReturnClause, Sort, SortClause, UnimplementedExpression, With, Without, allTrue, build, equals, ref, ref1, toDistinctList, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  Context = require('../runtime/context').Context;

  build = require('./builder').build;

  ref1 = require('../util/util'), typeIsArray = ref1.typeIsArray, allTrue = ref1.allTrue;

  equals = require('../util/comparison').equals;

  module.exports.AliasedQuerySource = AliasedQuerySource = (function() {
    function AliasedQuerySource(json) {
      this.alias = json.alias;
      this.expression = build(json.expression);
    }

    return AliasedQuerySource;

  })();

  module.exports.LetClause = LetClause = (function() {
    function LetClause(json) {
      this.identifier = json.identifier;
      this.expression = build(json.expression);
    }

    return LetClause;

  })();

  module.exports.With = With = (function(superClass) {
    extend(With, superClass);

    function With(json) {
      With.__super__.constructor.apply(this, arguments);
      this.alias = json.alias;
      this.expression = build(json.expression);
      this.suchThat = build(json.suchThat);
    }

    With.prototype.exec = function(ctx) {
      var childCtx, rec, records, returns;
      records = this.expression.execute(ctx);
      this.isList = typeIsArray(records);
      records = this.isList ? records : [records];
      returns = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = records.length; i < len; i++) {
          rec = records[i];
          childCtx = ctx.childContext();
          childCtx.set(this.alias, rec);
          results.push(this.suchThat.execute(childCtx));
        }
        return results;
      }).call(this);
      return returns.some(function(x) {
        return x;
      });
    };

    return With;

  })(Expression);

  module.exports.Without = Without = (function(superClass) {
    extend(Without, superClass);

    function Without(json) {
      Without.__super__.constructor.apply(this, arguments);
    }

    Without.prototype.exec = function(ctx) {
      return !Without.__super__.exec.call(this, ctx);
    };

    return Without;

  })(With);

  module.exports.Sort = Sort = (function(superClass) {
    extend(Sort, superClass);

    function Sort() {
      return Sort.__super__.constructor.apply(this, arguments);
    }

    return Sort;

  })(UnimplementedExpression);

  module.exports.ByDirection = ByDirection = (function(superClass) {
    extend(ByDirection, superClass);

    function ByDirection(json) {
      ByDirection.__super__.constructor.apply(this, arguments);
      this.direction = json.direction;
      this.low_order = this.direction === "asc" ? -1 : 1;
      this.high_order = this.low_order * -1;
    }

    ByDirection.prototype.exec = function(ctx, a, b) {
      if (a === b) {
        return 0;
      } else if (a.isQuantity && b.isQuantity) {
        if (a.before(b)) {
          return this.low_order;
        } else {
          return this.high_order;
        }
      } else if (a < b) {
        return this.low_order;
      } else {
        return this.high_order;
      }
    };

    return ByDirection;

  })(Expression);

  module.exports.ByExpression = ByExpression = (function(superClass) {
    extend(ByExpression, superClass);

    function ByExpression(json) {
      ByExpression.__super__.constructor.apply(this, arguments);
      this.expression = build(json.expression);
      this.direction = json.direction;
      this.low_order = this.direction === "asc" ? -1 : 1;
      this.high_order = this.low_order * -1;
    }

    ByExpression.prototype.exec = function(ctx, a, b) {
      var a_val, b_val, sctx;
      sctx = ctx.childContext(a);
      a_val = this.expression.execute(sctx);
      sctx = ctx.childContext(b);
      b_val = this.expression.execute(sctx);
      if (a_val === b_val) {
        return 0;
      } else if (a_val.isQuantity && b_val.isQuantity) {
        if (a_val.before(b_val)) {
          return this.low_order;
        } else {
          return this.high_order;
        }
      } else if (a_val < b_val) {
        return this.low_order;
      } else {
        return this.high_order;
      }
    };

    return ByExpression;

  })(Expression);

  module.exports.ByColumn = ByColumn = (function(superClass) {
    extend(ByColumn, superClass);

    function ByColumn(json) {
      ByColumn.__super__.constructor.apply(this, arguments);
      this.expression = build({
        "name": json.path,
        "type": "IdentifierRef"
      });
    }

    return ByColumn;

  })(ByExpression);

  module.exports.ReturnClause = ReturnClause = ReturnClause = (function() {
    function ReturnClause(json) {
      var ref2;
      this.expression = build(json.expression);
      this.distinct = (ref2 = json.distinct) != null ? ref2 : true;
    }

    return ReturnClause;

  })();

  module.exports.SortClause = SortClause = SortClause = (function() {
    function SortClause(json) {
      this.by = build(json != null ? json.by : void 0);
    }

    SortClause.prototype.sort = function(ctx, values) {
      if (this.by) {
        return values.sort((function(_this) {
          return function(a, b) {
            var i, item, len, order, ref2;
            order = 0;
            ref2 = _this.by;
            for (i = 0, len = ref2.length; i < len; i++) {
              item = ref2[i];
              order = item.exec(ctx, a, b);
              if (order !== 0) {
                break;
              }
            }
            return order;
          };
        })(this));
      }
    };

    return SortClause;

  })();

  toDistinctList = function(xList) {
    var i, inYList, j, len, len1, x, y, yList;
    yList = [];
    for (i = 0, len = xList.length; i < len; i++) {
      x = xList[i];
      inYList = false;
      for (j = 0, len1 = yList.length; j < len1; j++) {
        y = yList[j];
        if (equals(x, y)) {
          inYList = true;
        }
      }
      if (!inYList) {
        yList.push(x);
      }
    }
    return yList;
  };

  module.exports.Query = Query = (function(superClass) {
    extend(Query, superClass);

    function Query(json) {
      var d, s;
      Query.__super__.constructor.apply(this, arguments);
      this.sources = new MultiSource((function() {
        var i, len, ref2, results;
        ref2 = json.source;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          s = ref2[i];
          results.push(new AliasedQuerySource(s));
        }
        return results;
      })());
      this.letClauses = (function() {
        var i, len, ref2, ref3, results;
        ref3 = (ref2 = json["let"]) != null ? ref2 : [];
        results = [];
        for (i = 0, len = ref3.length; i < len; i++) {
          d = ref3[i];
          results.push(new LetClause(d));
        }
        return results;
      })();
      this.relationship = json.relationship != null ? build(json.relationship) : [];
      this.where = build(json.where);
      this.returnClause = json["return"] != null ? new ReturnClause(json["return"]) : null;
      this.aliases = this.sources.aliases();
      this.sortClause = json.sort != null ? new SortClause(json.sort) : null;
    }

    Query.prototype.exec = function(ctx) {
      var distinct, ref2, returnedValues;
      returnedValues = [];
      this.sources.forEach(ctx, (function(_this) {
        return function(rctx) {
          var child_ctx, def, i, len, passed, ref2, rel, relations, val;
          ref2 = _this.letClauses;
          for (i = 0, len = ref2.length; i < len; i++) {
            def = ref2[i];
            rctx.set(def.identifier, def.expression.execute(rctx));
          }
          relations = (function() {
            var j, len1, ref3, results;
            ref3 = this.relationship;
            results = [];
            for (j = 0, len1 = ref3.length; j < len1; j++) {
              rel = ref3[j];
              child_ctx = rctx.childContext();
              results.push(rel.execute(child_ctx));
            }
            return results;
          }).call(_this);
          passed = allTrue(relations);
          passed = passed && (_this.where ? _this.where.execute(rctx) : passed);
          if (passed) {
            if (_this.returnClause != null) {
              val = _this.returnClause.expression.execute(rctx);
              return returnedValues.push(val);
            } else {
              if (_this.aliases.length === 1) {
                return returnedValues.push(rctx.get(_this.aliases[0]));
              } else {
                return returnedValues.push(rctx.context_values);
              }
            }
          }
        };
      })(this));
      distinct = this.returnClause != null ? this.returnClause.distinct : true;
      if (distinct) {
        returnedValues = toDistinctList(returnedValues);
      }
      if ((ref2 = this.sortClause) != null) {
        ref2.sort(ctx, returnedValues);
      }
      if (this.sources.returnsList()) {
        return returnedValues;
      } else {
        return returnedValues[0];
      }
    };

    return Query;

  })(Expression);

  module.exports.AliasRef = AliasRef = (function(superClass) {
    extend(AliasRef, superClass);

    function AliasRef(json) {
      AliasRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
    }

    AliasRef.prototype.exec = function(ctx) {
      return ctx != null ? ctx.get(this.name) : void 0;
    };

    return AliasRef;

  })(Expression);

  module.exports.QueryLetRef = QueryLetRef = (function(superClass) {
    extend(QueryLetRef, superClass);

    function QueryLetRef(json) {
      QueryLetRef.__super__.constructor.apply(this, arguments);
    }

    return QueryLetRef;

  })(AliasRef);

  MultiSource = (function() {
    function MultiSource(sources) {
      this.sources = sources;
      this.alias = this.sources[0].alias;
      this.expression = this.sources[0].expression;
      this.isList = true;
      if (this.sources.length > 1) {
        this.rest = new MultiSource(this.sources.slice(1));
      }
    }

    MultiSource.prototype.aliases = function() {
      var a;
      a = [this.alias];
      if (this.rest) {
        a = a.concat(this.rest.aliases());
      }
      return a;
    };

    MultiSource.prototype.returnsList = function() {
      return this.isList || (this.rest && this.rest.returnsList());
    };

    MultiSource.prototype.forEach = function(ctx, func) {
      var i, len, rctx, rec, records, results;
      records = this.expression.execute(ctx);
      this.isList = typeIsArray(records);
      records = this.isList ? records : [records];
      results = [];
      for (i = 0, len = records.length; i < len; i++) {
        rec = records[i];
        rctx = new Context(ctx);
        rctx.set(this.alias, rec);
        if (this.rest) {
          results.push(this.rest.forEach(rctx, func));
        } else {
          results.push(func(rctx));
        }
      }
      return results;
    };

    return MultiSource;

  })();

}).call(this);



},{"../runtime/context":41,"../util/comparison":45,"../util/util":47,"./builder":15,"./expression":21}],35:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var DT, Exception, Expression, Quantity, Ratio,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Exception = require('../datatypes/exception').Exception;

  Expression = require('./expression').Expression;

  Quantity = require('../datatypes/quantity').Quantity;

  DT = require('../datatypes/datatypes');

  module.exports.Ratio = Ratio = (function(superClass) {
    extend(Ratio, superClass);

    function Ratio(json) {
      Ratio.__super__.constructor.apply(this, arguments);
      if (json.numerator == null) {
        throw new Error("Cannot create a ratio with an undefined numerator value");
      } else {
        this.numerator = new Quantity(json.numerator.value, json.numerator.unit);
      }
      if (json.denominator == null) {
        throw new Error("Cannot create a ratio with an undefined denominator value");
      } else {
        this.denominator = new Quantity(json.denominator.value, json.denominator.unit);
      }
    }

    Ratio.prototype.exec = function(ctx) {
      return new DT.Ratio(this.numerator, this.denominator);
    };

    return Ratio;

  })(Expression);

}).call(this);



},{"../datatypes/datatypes":5,"../datatypes/exception":7,"../datatypes/quantity":10,"./expression":21}],36:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Expression, ExpressionDef, ExpressionRef, FunctionDef, FunctionRef, IdentifierRef, OperandRef, build,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Expression = require('./expression').Expression;

  build = require('./builder').build;

  module.exports.ExpressionDef = ExpressionDef = (function(superClass) {
    extend(ExpressionDef, superClass);

    function ExpressionDef(json) {
      ExpressionDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.context = json.context;
      this.expression = build(json.expression);
    }

    ExpressionDef.prototype.exec = function(ctx) {
      var ref, value;
      value = (ref = this.expression) != null ? ref.execute(ctx) : void 0;
      ctx.rootContext().set(this.name, value);
      return value;
    };

    return ExpressionDef;

  })(Expression);

  module.exports.ExpressionRef = ExpressionRef = (function(superClass) {
    extend(ExpressionRef, superClass);

    function ExpressionRef(json) {
      ExpressionRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.library = json.libraryName;
    }

    ExpressionRef.prototype.exec = function(ctx) {
      var value;
      ctx = this.library ? ctx.getLibraryContext(this.library) : ctx;
      value = ctx.get(this.name);
      if (value instanceof Expression) {
        value = value.execute(ctx);
      }
      return value;
    };

    return ExpressionRef;

  })(Expression);

  module.exports.FunctionDef = FunctionDef = (function(superClass) {
    extend(FunctionDef, superClass);

    function FunctionDef(json) {
      FunctionDef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.expression = build(json.expression);
      this.parameters = json.operand;
    }

    FunctionDef.prototype.exec = function(ctx) {
      return this;
    };

    return FunctionDef;

  })(Expression);

  module.exports.FunctionRef = FunctionRef = (function(superClass) {
    extend(FunctionRef, superClass);

    function FunctionRef(json) {
      FunctionRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.library = json.libraryName;
    }

    FunctionRef.prototype.exec = function(ctx) {
      var args, child_ctx, functionDef, i, j, len, p, ref, ref1, ref2;
      functionDef = this.library ? (ref = ctx.get(this.library)) != null ? ref.get(this.name) : void 0 : ctx.get(this.name);
      args = this.execArgs(ctx);
      child_ctx = this.library ? (ref1 = ctx.getLibraryContext(this.library)) != null ? ref1.childContext() : void 0 : ctx.childContext();
      if (args.length !== functionDef.parameters.length) {
        throw new Error("incorrect number of arguments supplied");
      }
      ref2 = functionDef.parameters;
      for (i = j = 0, len = ref2.length; j < len; i = ++j) {
        p = ref2[i];
        child_ctx.set(p.name, args[i]);
      }
      return functionDef.expression.execute(child_ctx);
    };

    return FunctionRef;

  })(Expression);

  module.exports.OperandRef = OperandRef = (function(superClass) {
    extend(OperandRef, superClass);

    function OperandRef(json) {
      this.name = json.name;
    }

    OperandRef.prototype.exec = function(ctx) {
      return ctx.get(this.name);
    };

    return OperandRef;

  })(Expression);

  module.exports.IdentifierRef = IdentifierRef = (function(superClass) {
    extend(IdentifierRef, superClass);

    function IdentifierRef(json) {
      IdentifierRef.__super__.constructor.apply(this, arguments);
      this.name = json.name;
      this.library = json.libraryName;
    }

    IdentifierRef.prototype.exec = function(ctx) {
      var _obj, curr_obj, curr_val, j, len, part, parts, ref, ref1, ref2, val;
      val = this.library ? (ref = ctx.get(this.library)) != null ? ref.get(this.name) : void 0 : ctx.get(this.name);
      if (val == null) {
        parts = this.name.split(".");
        val = ctx.get(part);
        if ((val != null) && parts.length > 1) {
          curr_obj = val;
          curr_val = null;
          ref1 = parts.slice(1);
          for (j = 0, len = ref1.length; j < len; j++) {
            part = ref1[j];
            _obj = (ref2 = curr_obj != null ? curr_obj[part] : void 0) != null ? ref2 : curr_obj != null ? typeof curr_obj.get === "function" ? curr_obj.get(part) : void 0 : void 0;
            curr_obj = _obj instanceof Function ? _obj.call(curr_obj) : _obj;
          }
          val = curr_obj;
        }
      }
      if (val instanceof Function) {
        return val.call(ctx.context_values);
      } else {
        return val;
      }
    };

    return IdentifierRef;

  })(Expression);

}).call(this);



},{"./builder":15,"./expression":21}],37:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Combine, Concatenate, EndsWith, Expression, Lower, Matches, PositionOf, Split, SplitOnMatches, StartsWith, Substring, UnimplementedExpression, Upper, build, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  build = require('./builder').build;

  module.exports.Concatenate = Concatenate = (function(superClass) {
    extend(Concatenate, superClass);

    function Concatenate(json) {
      Concatenate.__super__.constructor.apply(this, arguments);
    }

    Concatenate.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if (args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args.reduce(function(x, y) {
          return x + y;
        });
      }
    };

    return Concatenate;

  })(Expression);

  module.exports.Combine = Combine = (function(superClass) {
    extend(Combine, superClass);

    function Combine(json) {
      Combine.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
      this.separator = build(json.separator);
    }

    Combine.prototype.exec = function(ctx) {
      var filteredArray, separator, source;
      source = this.source.execute(ctx);
      separator = this.separator != null ? this.separator.execute(ctx) : '';
      if (source == null) {
        return null;
      } else {
        filteredArray = source.filter(function(x) {
          return x !== null && x !== void 0;
        });
        if (filteredArray.length < 1) {
          return null;
        } else {
          return filteredArray.join(separator);
        }
      }
    };

    return Combine;

  })(Expression);

  module.exports.Split = Split = (function(superClass) {
    extend(Split, superClass);

    function Split(json) {
      Split.__super__.constructor.apply(this, arguments);
      this.stringToSplit = build(json.stringToSplit);
      this.separator = build(json.separator);
    }

    Split.prototype.exec = function(ctx) {
      var separator, stringToSplit;
      stringToSplit = this.stringToSplit.execute(ctx);
      separator = this.separator.execute(ctx);
      if (!((stringToSplit != null) && (separator != null))) {
        return null;
      } else {
        return stringToSplit.split(separator);
      }
    };

    return Split;

  })(Expression);

  module.exports.SplitOnMatches = SplitOnMatches = (function(superClass) {
    extend(SplitOnMatches, superClass);

    function SplitOnMatches(json) {
      SplitOnMatches.__super__.constructor.apply(this, arguments);
      this.stringToSplit = build(json.stringToSplit);
      this.separatorPattern = build(json.separatorPattern);
    }

    SplitOnMatches.prototype.exec = function(ctx) {
      var separatorPattern, stringToSplit;
      stringToSplit = this.stringToSplit.execute(ctx);
      separatorPattern = this.separatorPattern.execute(ctx);
      if (!((stringToSplit != null) && (separatorPattern != null))) {
        return null;
      } else {
        return stringToSplit.split(new RegExp(separatorPattern));
      }
    };

    return SplitOnMatches;

  })(Expression);

  module.exports.Upper = Upper = (function(superClass) {
    extend(Upper, superClass);

    function Upper(json) {
      Upper.__super__.constructor.apply(this, arguments);
    }

    Upper.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return arg.toUpperCase();
      } else {
        return null;
      }
    };

    return Upper;

  })(Expression);

  module.exports.Lower = Lower = (function(superClass) {
    extend(Lower, superClass);

    function Lower(json) {
      Lower.__super__.constructor.apply(this, arguments);
    }

    Lower.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg != null) {
        return arg.toLowerCase();
      } else {
        return null;
      }
    };

    return Lower;

  })(Expression);

  module.exports.PositionOf = PositionOf = (function(superClass) {
    extend(PositionOf, superClass);

    function PositionOf(json) {
      PositionOf.__super__.constructor.apply(this, arguments);
      this.pattern = build(json.pattern);
      this.string = build(json.string);
    }

    PositionOf.prototype.exec = function(ctx) {
      var pattern, string;
      pattern = this.pattern.execute(ctx);
      string = this.string.execute(ctx);
      if (!((pattern != null) && (string != null))) {
        return null;
      } else {
        return string.indexOf(pattern);
      }
    };

    return PositionOf;

  })(Expression);

  module.exports.Matches = Matches = (function(superClass) {
    extend(Matches, superClass);

    function Matches(json) {
      Matches.__super__.constructor.apply(this, arguments);
    }

    Matches.prototype.exec = function(ctx) {
      var pattern, ref1, string;
      ref1 = this.execArgs(ctx), string = ref1[0], pattern = ref1[1];
      if (!((string != null) && (pattern != null))) {
        return null;
      }
      if (string.match(new RegExp(pattern))) {
        return true;
      } else {
        return false;
      }
    };

    return Matches;

  })(Expression);

  module.exports.Substring = Substring = (function(superClass) {
    extend(Substring, superClass);

    function Substring(json) {
      Substring.__super__.constructor.apply(this, arguments);
      this.stringToSub = build(json.stringToSub);
      this.startIndex = build(json.startIndex);
      this.length = build(json['length']);
    }

    Substring.prototype.exec = function(ctx) {
      var length, startIndex, stringToSub;
      stringToSub = this.stringToSub.execute(ctx);
      startIndex = this.startIndex.execute(ctx);
      length = this.length != null ? this.length.execute(ctx) : null;
      if ((stringToSub == null) || (startIndex == null) || startIndex < 0 || startIndex >= stringToSub.length) {
        return null;
      } else if (length != null) {
        return stringToSub.substr(startIndex, length);
      } else {
        return stringToSub.substr(startIndex);
      }
    };

    return Substring;

  })(Expression);

  module.exports.StartsWith = StartsWith = (function(superClass) {
    extend(StartsWith, superClass);

    function StartsWith(json) {
      StartsWith.__super__.constructor.apply(this, arguments);
    }

    StartsWith.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if (args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args[0].slice(0, args[1].length) === args[1];
      }
    };

    return StartsWith;

  })(Expression);

  module.exports.EndsWith = EndsWith = (function(superClass) {
    extend(EndsWith, superClass);

    function EndsWith(json) {
      EndsWith.__super__.constructor.apply(this, arguments);
    }

    EndsWith.prototype.exec = function(ctx) {
      var args;
      args = this.execArgs(ctx);
      if (args.some(function(x) {
        return x == null;
      })) {
        return null;
      } else {
        return args[1] === '' || args[0].slice(-args[1].length) === args[1];
      }
    };

    return EndsWith;

  })(Expression);

}).call(this);



},{"./builder":15,"./expression":21}],38:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Expression, Property, Tuple, TupleElement, TupleElementDefinition, UnimplementedExpression, build, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  build = require('./builder').build;

  module.exports.Property = Property = (function(superClass) {
    extend(Property, superClass);

    function Property(json) {
      Property.__super__.constructor.apply(this, arguments);
      this.scope = json.scope;
      this.source = build(json.source);
      this.path = json.path;
    }

    Property.prototype.exec = function(ctx) {
      var _obj, curr_obj, curr_val, i, len, obj, part, parts, ref1, ref2, val;
      obj = this.scope != null ? ctx.get(this.scope) : this.source;
      if (obj instanceof Expression) {
        obj = obj.execute(ctx);
      }
      val = (ref1 = obj != null ? obj[this.path] : void 0) != null ? ref1 : obj != null ? typeof obj.get === "function" ? obj.get(this.path) : void 0 : void 0;
      if (!val) {
        parts = this.path.split(".");
        curr_obj = obj;
        curr_val = null;
        for (i = 0, len = parts.length; i < len; i++) {
          part = parts[i];
          _obj = (ref2 = curr_obj != null ? curr_obj[part] : void 0) != null ? ref2 : curr_obj != null ? typeof curr_obj.get === "function" ? curr_obj.get(part) : void 0 : void 0;
          curr_obj = _obj instanceof Function ? _obj.call(curr_obj) : _obj;
        }
        val = curr_obj != null ? curr_obj : null;
      }
      if (val instanceof Function) {
        return val.call(obj);
      } else {
        return val;
      }
    };

    return Property;

  })(Expression);

  module.exports.Tuple = Tuple = (function(superClass) {
    extend(Tuple, superClass);

    function Tuple(json) {
      var el, elements;
      Tuple.__super__.constructor.apply(this, arguments);
      elements = json.element != null ? json.element : [];
      this.elements = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = elements.length; i < len; i++) {
          el = elements[i];
          results.push({
            name: el.name,
            value: build(el.value)
          });
        }
        return results;
      })();
    }

    Object.defineProperties(Tuple.prototype, {
      isTuple: {
        get: function() {
          return true;
        }
      }
    });

    Tuple.prototype.exec = function(ctx) {
      var el, i, len, ref1, ref2, val;
      val = {};
      ref1 = this.elements;
      for (i = 0, len = ref1.length; i < len; i++) {
        el = ref1[i];
        val[el.name] = (ref2 = el.value) != null ? ref2.execute(ctx) : void 0;
      }
      return val;
    };

    return Tuple;

  })(Expression);

  module.exports.TupleElement = TupleElement = (function(superClass) {
    extend(TupleElement, superClass);

    function TupleElement() {
      return TupleElement.__super__.constructor.apply(this, arguments);
    }

    return TupleElement;

  })(UnimplementedExpression);

  module.exports.TupleElementDefinition = TupleElementDefinition = (function(superClass) {
    extend(TupleElementDefinition, superClass);

    function TupleElementDefinition() {
      return TupleElementDefinition.__super__.constructor.apply(this, arguments);
    }

    return TupleElementDefinition;

  })(UnimplementedExpression);

}).call(this);



},{"./builder":15,"./expression":21}],39:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var As, CanConvertQuantity, Concept, Convert, ConvertQuantity, ConvertsToBoolean, ConvertsToDate, ConvertsToDateTime, ConvertsToDecimal, ConvertsToInteger, ConvertsToQuantity, ConvertsToRatio, ConvertsToString, ConvertsToTime, Date, DateTime, Expression, FunctionRef, IntervalTypeSpecifier, Is, ListTypeSpecifier, NamedTypeSpecifier, Quantity, Ratio, ToBoolean, ToConcept, ToDate, ToDateTime, ToDecimal, ToInteger, ToQuantity, ToRatio, ToString, ToTime, TupleTypeSpecifier, UnimplementedExpression, canConvertToType, isValidDecimal, isValidInteger, limitDecimalPrecision, normalizeMillisecondsField, parseQuantity, ref, ref1, ref2, ref3,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./expression'), Expression = ref.Expression, UnimplementedExpression = ref.UnimplementedExpression;

  FunctionRef = require('./reusable').FunctionRef;

  ref1 = require('../datatypes/datetime'), DateTime = ref1.DateTime, Date = ref1.Date;

  Concept = require('../datatypes/clinical').Concept;

  ref2 = require('../datatypes/quantity'), parseQuantity = ref2.parseQuantity, Quantity = ref2.Quantity;

  ref3 = require('../util/math'), isValidDecimal = ref3.isValidDecimal, isValidInteger = ref3.isValidInteger, limitDecimalPrecision = ref3.limitDecimalPrecision;

  normalizeMillisecondsField = require('../util/util').normalizeMillisecondsField;

  Ratio = require('../datatypes/ratio').Ratio;

  module.exports.As = As = (function(superClass) {
    extend(As, superClass);

    function As(json) {
      var ref4;
      As.__super__.constructor.apply(this, arguments);
      this.asType = json.asType;
      this.asTypeSpecifier = json.asTypeSpecifier;
      this.strict = (ref4 = json.strict) != null ? ref4 : false;
    }

    As.prototype.exec = function(ctx) {
      return this.execArgs(ctx);
    };

    return As;

  })(Expression);

  module.exports.ToBoolean = ToBoolean = (function(superClass) {
    extend(ToBoolean, superClass);

    function ToBoolean(json) {
      ToBoolean.__super__.constructor.apply(this, arguments);
    }

    ToBoolean.prototype.exec = function(ctx) {
      var arg, strArg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        strArg = arg.toString().toLowerCase();
        if (strArg === "true" || strArg === "t" || strArg === "yes" || strArg === "y" || strArg === "1") {
          return true;
        } else if (strArg === "false" || strArg === "f" || strArg === "no" || strArg === "n" || strArg === "0") {
          return false;
        } else {
          return null;
        }
      } else {
        return null;
      }
    };

    return ToBoolean;

  })(Expression);

  module.exports.ToConcept = ToConcept = (function(superClass) {
    extend(ToConcept, superClass);

    function ToConcept(json) {
      ToConcept.__super__.constructor.apply(this, arguments);
    }

    ToConcept.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        return new Concept([arg], arg.display);
      } else {
        return null;
      }
    };

    return ToConcept;

  })(Expression);

  module.exports.ToDate = ToDate = (function(superClass) {
    extend(ToDate, superClass);

    function ToDate(json) {
      ToDate.__super__.constructor.apply(this, arguments);
    }

    ToDate.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else if (arg.isDateTime) {
        return arg.getDate();
      } else {
        return Date.parse(arg.toString());
      }
    };

    return ToDate;

  })(Expression);

  module.exports.ToDateTime = ToDateTime = (function(superClass) {
    extend(ToDateTime, superClass);

    function ToDateTime(json) {
      ToDateTime.__super__.constructor.apply(this, arguments);
    }

    ToDateTime.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if (arg == null) {
        return null;
      } else if (arg.isDate) {
        return arg.getDateTime();
      } else {
        return DateTime.parse(arg.toString());
      }
    };

    return ToDateTime;

  })(Expression);

  module.exports.ToDecimal = ToDecimal = (function(superClass) {
    extend(ToDecimal, superClass);

    function ToDecimal(json) {
      ToDecimal.__super__.constructor.apply(this, arguments);
    }

    ToDecimal.prototype.exec = function(ctx) {
      var arg, decimal;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        decimal = parseFloat(arg.toString());
        decimal = limitDecimalPrecision(decimal);
        if (isValidDecimal(decimal)) {
          return decimal;
        }
      }
      return null;
    };

    return ToDecimal;

  })(Expression);

  module.exports.ToInteger = ToInteger = (function(superClass) {
    extend(ToInteger, superClass);

    function ToInteger(json) {
      ToInteger.__super__.constructor.apply(this, arguments);
    }

    ToInteger.prototype.exec = function(ctx) {
      var arg, integer;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        integer = parseInt(arg.toString());
        if (isValidInteger(integer)) {
          return integer;
        }
      }
      return null;
    };

    return ToInteger;

  })(Expression);

  module.exports.ToQuantity = ToQuantity = (function(superClass) {
    extend(ToQuantity, superClass);

    function ToQuantity(json) {
      ToQuantity.__super__.constructor.apply(this, arguments);
    }

    ToQuantity.prototype.exec = function(ctx) {
      var arg, quantity;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        quantity = parseQuantity(arg.toString());
        return quantity;
      } else {
        return null;
      }
    };

    return ToQuantity;

  })(Expression);

  module.exports.ToRatio = ToRatio = (function(superClass) {
    extend(ToRatio, superClass);

    function ToRatio(json) {
      ToRatio.__super__.constructor.apply(this, arguments);
    }

    ToRatio.prototype.exec = function(ctx) {
      var arg, denominator, numerator, splitRatioString;
      arg = this.execArgs(ctx);
      if (arg != null) {
        try {
          splitRatioString = arg.toString().match(/^(\d+(\.\d+)?\s*('.+')?)\s*:\s*(\d+(\.\d+)?\s*('.+')?)$/);
          if (splitRatioString == null) {
            return null;
          }
          numerator = parseQuantity(splitRatioString[1]);
          denominator = parseQuantity(splitRatioString[4]);
        } catch (error) {
          return null;
        }
        if (!((numerator != null) && (denominator != null))) {
          return null;
        }
        return new Ratio(numerator, denominator);
      } else {
        return null;
      }
    };

    return ToRatio;

  })(Expression);

  module.exports.ToString = ToString = (function(superClass) {
    extend(ToString, superClass);

    function ToString(json) {
      ToString.__super__.constructor.apply(this, arguments);
    }

    ToString.prototype.exec = function(ctx) {
      var arg;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        return arg.toString();
      } else {
        return null;
      }
    };

    return ToString;

  })(Expression);

  module.exports.ToTime = ToTime = (function(superClass) {
    extend(ToTime, superClass);

    function ToTime(json) {
      ToTime.__super__.constructor.apply(this, arguments);
    }

    ToTime.prototype.exec = function(ctx) {
      var arg, hours, matches, milliseconds, minutes, seconds, timeString;
      arg = this.execArgs(ctx);
      if ((arg != null) && typeof arg !== 'undefined') {
        timeString = arg.toString();
        matches = /^((\d{2})(\:(\d{2})(\:(\d{2})(\.(\d+))?)?)?)?$/.exec(timeString);
        if (matches == null) {
          return null;
        }
        hours = matches[2];
        minutes = matches[4];
        seconds = matches[6];
        if (hours != null) {
          if (!(hours >= 0 && hours <= 23)) {
            return null;
          }
          hours = parseInt(hours, 10);
        }
        if (minutes != null) {
          if (!(minutes >= 0 && minutes <= 59)) {
            return null;
          }
          minutes = parseInt(minutes, 10);
        }
        if (seconds != null) {
          if (!(seconds >= 0 && seconds <= 59)) {
            return null;
          }
          seconds = parseInt(seconds, 10);
        }
        milliseconds = matches[8];
        if (milliseconds != null) {
          milliseconds = parseInt(normalizeMillisecondsField(milliseconds));
        }
        return new DateTime(0, 1, 1, hours, minutes, seconds, milliseconds, null);
      } else {
        return null;
      }
    };

    return ToTime;

  })(Expression);

  module.exports.Convert = Convert = (function(superClass) {
    extend(Convert, superClass);

    function Convert(json) {
      Convert.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
      this.toType = json.toType;
    }

    Convert.prototype.exec = function(ctx) {
      switch (this.toType) {
        case "{urn:hl7-org:elm-types:r1}Boolean":
          return new ToBoolean({
            "type": "ToBoolean",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Concept":
          return new ToConcept({
            "type": "ToConcept",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Decimal":
          return new ToDecimal({
            "type": "ToDecimal",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Integer":
          return new ToInteger({
            "type": "ToInteger",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}String":
          return new ToString({
            "type": "ToString",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Quantity":
          return new ToQuantity({
            "type": "ToQuantity",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}DateTime":
          return new ToDateTime({
            "type": "ToDateTime",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Date":
          return new ToDate({
            "type": "ToDate",
            "operand": this.operand
          }).execute(ctx);
        case "{urn:hl7-org:elm-types:r1}Time":
          return new ToTime({
            "type": "ToTime",
            "operand": this.operand
          }).execute(ctx);
        default:
          return this.execArgs(ctx);
      }
    };

    return Convert;

  })(Expression);

  module.exports.ConvertsToBoolean = ConvertsToBoolean = (function(superClass) {
    extend(ConvertsToBoolean, superClass);

    function ConvertsToBoolean(json) {
      ConvertsToBoolean.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToBoolean.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToBoolean, this.operand, ctx);
      }
    };

    return ConvertsToBoolean;

  })(Expression);

  module.exports.ConvertsToDate = ConvertsToDate = (function(superClass) {
    extend(ConvertsToDate, superClass);

    function ConvertsToDate(json) {
      ConvertsToDate.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToDate.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToDate, this.operand, ctx);
      }
    };

    return ConvertsToDate;

  })(Expression);

  module.exports.ConvertsToDateTime = ConvertsToDateTime = (function(superClass) {
    extend(ConvertsToDateTime, superClass);

    function ConvertsToDateTime(json) {
      ConvertsToDateTime.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToDateTime.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToDateTime, this.operand, ctx);
      }
    };

    return ConvertsToDateTime;

  })(Expression);

  module.exports.ConvertsToDecimal = ConvertsToDecimal = (function(superClass) {
    extend(ConvertsToDecimal, superClass);

    function ConvertsToDecimal(json) {
      ConvertsToDecimal.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToDecimal.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToDecimal, this.operand, ctx);
      }
    };

    return ConvertsToDecimal;

  })(Expression);

  module.exports.ConvertsToInteger = ConvertsToInteger = (function(superClass) {
    extend(ConvertsToInteger, superClass);

    function ConvertsToInteger(json) {
      ConvertsToInteger.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToInteger.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToInteger, this.operand, ctx);
      }
    };

    return ConvertsToInteger;

  })(Expression);

  module.exports.ConvertsToQuantity = ConvertsToQuantity = (function(superClass) {
    extend(ConvertsToQuantity, superClass);

    function ConvertsToQuantity(json) {
      ConvertsToQuantity.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToQuantity.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToQuantity, this.operand, ctx);
      }
    };

    return ConvertsToQuantity;

  })(Expression);

  module.exports.ConvertsToRatio = ConvertsToRatio = (function(superClass) {
    extend(ConvertsToRatio, superClass);

    function ConvertsToRatio(json) {
      ConvertsToRatio.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToRatio.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToRatio, this.operand, ctx);
      }
    };

    return ConvertsToRatio;

  })(Expression);

  module.exports.ConvertsToString = ConvertsToString = (function(superClass) {
    extend(ConvertsToString, superClass);

    function ConvertsToString(json) {
      ConvertsToString.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToString.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToString, this.operand, ctx);
      }
    };

    return ConvertsToString;

  })(Expression);

  module.exports.ConvertsToTime = ConvertsToTime = (function(superClass) {
    extend(ConvertsToTime, superClass);

    function ConvertsToTime(json) {
      ConvertsToTime.__super__.constructor.apply(this, arguments);
      this.operand = json.operand;
    }

    ConvertsToTime.prototype.exec = function(ctx) {
      var operatorValue;
      operatorValue = this.execArgs(ctx);
      if (operatorValue === null) {
        return null;
      } else {
        return canConvertToType(ToTime, this.operand, ctx);
      }
    };

    return ConvertsToTime;

  })(Expression);

  canConvertToType = function(toFunction, operand, ctx) {
    var value;
    try {
      value = new toFunction({
        "type": toFunction.name,
        "operand": operand
      }).execute(ctx);
      if (value != null) {
        return true;
      } else {
        return false;
      }
    } catch (error) {
      return false;
    }
  };

  module.exports.ConvertQuantity = ConvertQuantity = (function(superClass) {
    extend(ConvertQuantity, superClass);

    function ConvertQuantity(json) {
      ConvertQuantity.__super__.constructor.apply(this, arguments);
    }

    ConvertQuantity.prototype.exec = function(ctx) {
      var newUnit, quantity, ref4;
      ref4 = this.execArgs(ctx), quantity = ref4[0], newUnit = ref4[1];
      if ((quantity != null) && (newUnit != null)) {
        try {
          return quantity.convertUnit(newUnit);
        } catch (error) {
          return null;
        }
      }
    };

    return ConvertQuantity;

  })(Expression);

  module.exports.CanConvertQuantity = CanConvertQuantity = (function(superClass) {
    extend(CanConvertQuantity, superClass);

    function CanConvertQuantity(json) {
      CanConvertQuantity.__super__.constructor.apply(this, arguments);
    }

    CanConvertQuantity.prototype.exec = function(ctx) {
      var newUnit, quantity, ref4;
      ref4 = this.execArgs(ctx), quantity = ref4[0], newUnit = ref4[1];
      if ((quantity != null) && (newUnit != null)) {
        try {
          quantity.convertUnit(newUnit);
          return true;
        } catch (error) {
          return false;
        }
      }
      return null;
    };

    return CanConvertQuantity;

  })(Expression);

  module.exports.Is = Is = (function(superClass) {
    extend(Is, superClass);

    function Is() {
      return Is.__super__.constructor.apply(this, arguments);
    }

    return Is;

  })(UnimplementedExpression);

  module.exports.IntervalTypeSpecifier = IntervalTypeSpecifier = (function(superClass) {
    extend(IntervalTypeSpecifier, superClass);

    function IntervalTypeSpecifier() {
      return IntervalTypeSpecifier.__super__.constructor.apply(this, arguments);
    }

    return IntervalTypeSpecifier;

  })(UnimplementedExpression);

  module.exports.ListTypeSpecifier = ListTypeSpecifier = (function(superClass) {
    extend(ListTypeSpecifier, superClass);

    function ListTypeSpecifier() {
      return ListTypeSpecifier.__super__.constructor.apply(this, arguments);
    }

    return ListTypeSpecifier;

  })(UnimplementedExpression);

  module.exports.NamedTypeSpecifier = NamedTypeSpecifier = (function(superClass) {
    extend(NamedTypeSpecifier, superClass);

    function NamedTypeSpecifier() {
      return NamedTypeSpecifier.__super__.constructor.apply(this, arguments);
    }

    return NamedTypeSpecifier;

  })(UnimplementedExpression);

  module.exports.TupleTypeSpecifier = TupleTypeSpecifier = (function(superClass) {
    extend(TupleTypeSpecifier, superClass);

    function TupleTypeSpecifier() {
      return TupleTypeSpecifier.__super__.constructor.apply(this, arguments);
    }

    return TupleTypeSpecifier;

  })(UnimplementedExpression);

}).call(this);



},{"../datatypes/clinical":4,"../datatypes/datetime":6,"../datatypes/quantity":10,"../datatypes/ratio":11,"../util/math":46,"../util/util":47,"./expression":21,"./reusable":36}],40:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  window.cql = require('../../cql');

  window.executeSimpleELM = function(elm, patientSource, valueSets, libraryName, version, executionDateTime, parameters) {
    var codeService, executor, lib, rep;
    if (parameters == null) {
      parameters = {};
    }
    if (Array.isArray(elm)) {
      if (elm.length > 1) {
        rep = new cql.Repository(elm);
        lib = rep.resolve(libraryName, version);
      } else {
        lib = new cql.Library(elm[0]);
      }
    } else {
      lib = new cql.Library(elm);
    }
    codeService = new cql.CodeService(valueSets);
    executor = new cql.Executor(lib, codeService, parameters);
    return executor.exec(patientSource, executionDateTime);
  };

}).call(this);



},{"../../cql":3}],41:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Context, Exception, Library, PatientContext, UnfilteredContext, dt, typeIsArray, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Library = require('../elm/library').Library;

  Exception = require('../datatypes/exception').Exception;

  typeIsArray = require('../util/util').typeIsArray;

  dt = require('../datatypes/datatypes');

  util = require('util');

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  module.exports.Context = Context = (function() {
    function Context(parent, _codeService, _parameters) {
      this.parent = parent;
      this._codeService = _codeService != null ? _codeService : null;
      if (_parameters == null) {
        _parameters = {};
      }
      this.context_values = {};
      this.library_context = {};
      this.localId_context = {};
      this.checkParameters(_parameters);
      this._parameters = _parameters;
    }

    Context.property("parameters", {
      get: function() {
        var ref;
        return this._parameters || ((ref = this.parent) != null ? ref.parameters : void 0);
      },
      set: function(params) {
        this.checkParameters(params);
        return this._parameters = params;
      }
    });

    Context.property("codeService", {
      get: function() {
        var ref;
        return this._codeService || ((ref = this.parent) != null ? ref.codeService : void 0);
      },
      set: function(cs) {
        return this._codeService = cs;
      }
    });

    Context.prototype.withParameters = function(params) {
      this.parameters = params != null ? params : {};
      return this;
    };

    Context.prototype.withCodeService = function(cs) {
      this.codeService = cs;
      return this;
    };

    Context.prototype.rootContext = function() {
      if (this.parent) {
        return this.parent.rootContext();
      } else {
        return this;
      }
    };

    Context.prototype.findRecords = function(profile) {
      var ref;
      return (ref = this.parent) != null ? ref.findRecords(profile) : void 0;
    };

    Context.prototype.childContext = function(context_values) {
      var ctx;
      if (context_values == null) {
        context_values = {};
      }
      ctx = new Context(this);
      ctx.context_values = context_values;
      return ctx;
    };

    Context.prototype.getLibraryContext = function(library) {
      var ref;
      return (ref = this.parent) != null ? ref.getLibraryContext(library) : void 0;
    };

    Context.prototype.getLocalIdContext = function(localId) {
      var ref;
      return (ref = this.parent) != null ? ref.getLocalIdContext(localId) : void 0;
    };

    Context.prototype.getParameter = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getParameter(name) : void 0;
    };

    Context.prototype.getParentParameter = function(name) {
      var ref;
      if (((ref = this.parent) != null ? ref.parameters[name] : void 0) != null) {
        return this.parent.parameters[name];
      } else if (this.parent != null) {
        return this.parent.getParentParameter(name);
      }
    };

    Context.prototype.getTimezoneOffset = function() {
      var ref;
      if (this.executionDateTime != null) {
        return this.executionDateTime.timezoneOffset;
      } else if (((ref = this.parent) != null ? ref.getTimezoneOffset : void 0) != null) {
        return this.parent.getTimezoneOffset();
      } else {
        throw new Exception("No Timezone Offset has been set");
      }
    };

    Context.prototype.getExecutionDateTime = function() {
      var ref;
      if (this.executionDateTime != null) {
        return this.executionDateTime;
      } else if (((ref = this.parent) != null ? ref.getExecutionDateTime : void 0) != null) {
        return this.parent.getExecutionDateTime();
      } else {
        throw new Exception("No Execution DateTime has been set");
      }
    };

    Context.prototype.getValueSet = function(name, library) {
      var ref;
      return (ref = this.parent) != null ? ref.getValueSet(name, library) : void 0;
    };

    Context.prototype.getCodeSystem = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getCodeSystem(name) : void 0;
    };

    Context.prototype.getCode = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getCode(name) : void 0;
    };

    Context.prototype.getConcept = function(name) {
      var ref;
      return (ref = this.parent) != null ? ref.getConcept(name) : void 0;
    };

    Context.prototype.get = function(identifier) {
      var ref;
      if (typeof this.context_values[identifier] !== 'undefined') {
        return this.context_values[identifier];
      } else if (identifier === "$this") {
        return this.context_values;
      } else {
        return (ref = this.parent) != null ? ref.get(identifier) : void 0;
      }
    };

    Context.prototype.set = function(identifier, value) {
      return this.context_values[identifier] = value;
    };

    Context.prototype.setLocalIdWithResult = function(localId, value) {
      var ctx;
      ctx = this.localId_context[localId];
      if (ctx === false || ctx === null || ctx === void 0 || ctx.length === 0) {
        return this.localId_context[localId] = value;
      } else {
        return ctx;
      }
    };

    Context.prototype.getLocalIdResult = function(localId) {
      return this.localId_context[localId];
    };

    Context.prototype.getAllLocalIds = function() {
      var lib, libName, localIdResults, ref;
      localIdResults = {};
      localIdResults[this.parent.source.library.identifier.id] = {};
      localIdResults[this.parent.source.library.identifier.id] = this.localId_context;
      ref = this.library_context;
      for (libName in ref) {
        lib = ref[libName];
        this.supportLibraryLocalIds(lib, localIdResults);
      }
      return localIdResults;
    };

    Context.prototype.supportLibraryLocalIds = function(lib, localIdResults) {
      var ref, results, supportLib, supportLibName;
      if (localIdResults[lib.library.source.library.identifier.id] != null) {
        this.mergeLibraryLocalIdResults(localIdResults, lib.library.source.library.identifier.id, lib.localId_context);
      } else {
        localIdResults[lib.library.source.library.identifier.id] = lib.localId_context;
      }
      ref = lib.library_context;
      results = [];
      for (supportLibName in ref) {
        supportLib = ref[supportLibName];
        results.push(this.supportLibraryLocalIds(supportLib, localIdResults));
      }
      return results;
    };

    Context.prototype.mergeLibraryLocalIdResults = function(localIdResults, libraryId, libraryResults) {
      var existingResult, localId, localIdResult, results;
      results = [];
      for (localId in libraryResults) {
        localIdResult = libraryResults[localId];
        existingResult = localIdResults[libraryId][localId];
        if (existingResult === false || existingResult === null || existingResult === void 0 || existingResult.length === 0) {
          results.push(localIdResults[libraryId][localId] = localIdResult);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Context.prototype.checkParameters = function(params) {
      var pDef, pName, pVal;
      for (pName in params) {
        pVal = params[pName];
        pDef = this.getParameter(pName);
        if (pVal == null) {
          return;
        }
        if (typeof pDef === "undefined") {
          return;
        } else if ((pDef.parameterTypeSpecifier != null) && !this.matchesTypeSpecifier(pVal, pDef.parameterTypeSpecifier)) {
          throw new Error("Passed in parameter '" + pName + "' is wrong type");
        } else if ((pDef['default'] != null) && !this.matchesInstanceType(pVal, pDef['default'])) {
          throw new Error("Passed in parameter '" + pName + "' is wrong type");
        }
      }
      return true;
    };

    Context.prototype.matchesTypeSpecifier = function(val, spec) {
      switch (spec.type) {
        case "NamedTypeSpecifier":
          return this.matchesNamedTypeSpecifier(val, spec);
        case "ListTypeSpecifier":
          return this.matchesListTypeSpecifier(val, spec);
        case "TupleTypeSpecifier":
          return this.matchesTupleTypeSpecifier(val, spec);
        case "IntervalTypeSpecifier":
          return this.matchesIntervalTypeSpecifier(val, spec);
        default:
          return true;
      }
    };

    Context.prototype.matchesListTypeSpecifier = function(val, spec) {
      return typeIsArray(val) && val.every((function(_this) {
        return function(x) {
          return _this.matchesTypeSpecifier(x, spec.elementType);
        };
      })(this));
    };

    Context.prototype.matchesTupleTypeSpecifier = function(val, spec) {
      return typeof val === "object" && !typeIsArray(val) && spec.element.every((function(_this) {
        return function(x) {
          return typeof val[x.name] === "undefined" || _this.matchesTypeSpecifier(val[x.name], x.elementType);
        };
      })(this));
    };

    Context.prototype.matchesIntervalTypeSpecifier = function(val, spec) {
      return val.isInterval && ((val.low == null) || this.matchesTypeSpecifier(val.low, spec.pointType)) && ((val.high == null) || this.matchesTypeSpecifier(val.high, spec.pointType));
    };

    Context.prototype.matchesNamedTypeSpecifier = function(val, spec) {
      switch (spec.name) {
        case "{urn:hl7-org:elm-types:r1}Boolean":
          return typeof val === "boolean";
        case "{urn:hl7-org:elm-types:r1}Decimal":
          return typeof val === "number";
        case "{urn:hl7-org:elm-types:r1}Integer":
          return typeof val === "number" && Math.floor(val) === val;
        case "{urn:hl7-org:elm-types:r1}String":
          return typeof val === "string";
        case "{urn:hl7-org:elm-types:r1}Concept":
          return val != null ? val.isConcept : void 0;
        case "{urn:hl7-org:elm-types:r1}Code":
          return val != null ? val.isCode : void 0;
        case "{urn:hl7-org:elm-types:r1}DateTime":
          return val != null ? val.isDateTime : void 0;
        case "{urn:hl7-org:elm-types:r1}Date":
          return val != null ? val.isDate : void 0;
        case "{urn:hl7-org:elm-types:r1}Quantity":
          return val != null ? val.isQuantity : void 0;
        case "{urn:hl7-org:elm-types:r1}Time":
          return (val != null ? val.isDateTime : void 0) && val.isTime();
        default:
          return true;
      }
    };

    Context.prototype.matchesInstanceType = function(val, inst) {
      switch (false) {
        case !inst.isBooleanLiteral:
          return typeof val === "boolean";
        case !inst.isDecimalLiteral:
          return typeof val === "number";
        case !inst.isIntegerLiteral:
          return typeof val === "number" && Math.floor(val) === val;
        case !inst.isStringLiteral:
          return typeof val === "string";
        case !inst.isCode:
          return val != null ? val.isCode : void 0;
        case !inst.isConcept:
          return val != null ? val.isConcept : void 0;
        case !inst.isDateTime:
          return val != null ? val.isDateTime : void 0;
        case !inst.isQuantity:
          return val != null ? val.isQuantity : void 0;
        case !inst.isTime:
          return (val != null ? val.isDateTime : void 0) && val.isTime();
        case !inst.isList:
          return this.matchesListInstanceType(val, inst);
        case !inst.isTuple:
          return this.matchesTupleInstanceType(val, inst);
        case !inst.isInterval:
          return this.matchesIntervalInstanceType(val, inst);
        default:
          return true;
      }
    };

    Context.prototype.matchesListInstanceType = function(val, list) {
      return typeIsArray(val) && val.every((function(_this) {
        return function(x) {
          return _this.matchesInstanceType(x, list.elements[0]);
        };
      })(this));
    };

    Context.prototype.matchesTupleInstanceType = function(val, tpl) {
      return typeof val === "object" && !typeIsArray(val) && tpl.elements.every((function(_this) {
        return function(x) {
          return typeof val[x.name] === "undefined" || _this.matchesInstanceType(val[x.name], x.value);
        };
      })(this));
    };

    Context.prototype.matchesIntervalInstanceType = function(val, ivl) {
      var pointType, ref;
      pointType = (ref = ivl.low) != null ? ref : ivl.high;
      return val.isInterval && ((val.low == null) || this.matchesInstanceType(val.low, pointType)) && ((val.high == null) || this.matchesInstanceType(val.high, pointType));
    };

    return Context;

  })();

  module.exports.PatientContext = PatientContext = (function(superClass) {
    extend(PatientContext, superClass);

    function PatientContext(library1, patient, codeService, parameters, executionDateTime) {
      this.library = library1;
      this.patient = patient;
      this.executionDateTime = executionDateTime != null ? executionDateTime : dt.DateTime.fromJSDate(new Date());
      PatientContext.__super__.constructor.call(this, this.library, codeService, parameters);
    }

    PatientContext.prototype.rootContext = function() {
      return this;
    };

    PatientContext.prototype.getLibraryContext = function(library) {
      var base;
      return (base = this.library_context)[library] || (base[library] = new PatientContext(this.get(library), this.patient, this.codeService, this.parameters, this.executionDateTime));
    };

    PatientContext.prototype.getLocalIdContext = function(localId) {
      var base;
      return (base = this.localId_context)[localId] || (base[localId] = new PatientContext(this.get(library), this.patient, this.codeService, this.parameters, this.executionDateTime));
    };

    PatientContext.prototype.findRecords = function(profile) {
      var ref;
      return (ref = this.patient) != null ? ref.findRecords(profile) : void 0;
    };

    return PatientContext;

  })(Context);

  module.exports.UnfilteredContext = UnfilteredContext = (function(superClass) {
    extend(UnfilteredContext, superClass);

    function UnfilteredContext(library1, results, codeService, parameters, executionDateTime) {
      this.library = library1;
      this.results = results;
      this.executionDateTime = executionDateTime != null ? executionDateTime : dt.DateTime.fromJSDate(new Date());
      UnfilteredContext.__super__.constructor.call(this, this.library, codeService, parameters);
    }

    UnfilteredContext.prototype.rootContext = function() {
      return this;
    };

    UnfilteredContext.prototype.findRecords = function(template) {
      throw new Exception("Retreives are not currently supported in Unfiltered Context");
    };

    UnfilteredContext.prototype.getLibraryContext = function(library) {
      throw new Exception("Library expressions are not currently supported in Unfiltered Context");
    };

    UnfilteredContext.prototype.get = function(identifier) {
      var pid, ref, ref1, res, results;
      if (this.context_values[identifier]) {
        return this.context_values[identifier];
      }
      if (((ref = this.library[identifier]) != null ? ref.context : void 0) === "Unfiltered") {
        return this.library.expressions[identifier];
      }
      ref1 = this.results.patientResults;
      results = [];
      for (pid in ref1) {
        res = ref1[pid];
        results.push(res[identifier]);
      }
      return results;
    };

    return UnfilteredContext;

  })(Context);

}).call(this);



},{"../datatypes/datatypes":5,"../datatypes/exception":7,"../elm/library":26,"../util/util":47,"util":60}],42:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Executor, PatientContext, Results, UnfilteredContext, ref;

  module.exports.Executor = Executor = (function() {
    function Executor(library, codeService, parameters) {
      this.library = library;
      this.codeService = codeService;
      this.parameters = parameters;
    }

    Executor.prototype.withLibrary = function(lib) {
      this.library = lib;
      return this;
    };

    Executor.prototype.withParameters = function(params) {
      this.parameters = params != null ? params : {};
      return this;
    };

    Executor.prototype.withCodeService = function(cs) {
      this.codeService = cs;
      return this;
    };

    Executor.prototype.exec_expression = function(expression, patientSource) {
      var expr, p, patient_ctx, r;
      Results(r = new Results());
      expr = this.library.expressions[expression];
      while (expr && (p = patientSource.currentPatient())) {
        patient_ctx = new PatientContext(this.library, p, this.codeService, this.parameters);
        r.recordPatientResult(patient_ctx, expression, expr.execute(patient_ctx));
        patientSource.nextPatient();
      }
      return r;
    };

    Executor.prototype.exec = function(patientSource, executionDateTime) {
      var expr, key, r, ref, unfilteredContext;
      Results(r = this.exec_patient_context(patientSource, executionDateTime));
      unfilteredContext = new UnfilteredContext(this.library, r, this.codeService, this.parameters);
      ref = this.library.expressions;
      for (key in ref) {
        expr = ref[key];
        if (expr.context === "Unfiltered") {
          r.recordUnfilteredResult(key, expr.exec(unfilteredContext));
        }
      }
      return r;
    };

    Executor.prototype.exec_patient_context = function(patientSource, executionDateTime) {
      var expr, key, p, patient_ctx, r, ref;
      Results(r = new Results());
      while (p = patientSource.currentPatient()) {
        patient_ctx = new PatientContext(this.library, p, this.codeService, this.parameters, executionDateTime);
        ref = this.library.expressions;
        for (key in ref) {
          expr = ref[key];
          if (expr.context === "Patient") {
            r.recordPatientResult(patient_ctx, key, expr.execute(patient_ctx));
          }
        }
        patientSource.nextPatient();
      }
      return r;
    };

    return Executor;

  })();

  Results = require('./results').Results;

  ref = require('./context'), UnfilteredContext = ref.UnfilteredContext, PatientContext = ref.PatientContext;

}).call(this);



},{"./context":41,"./results":44}],43:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Repository, cql;

  cql = require('../cql');

  module.exports.Repository = Repository = (function() {
    function Repository(data) {
      var k, v;
      this.data = data;
      this.libraries = (function() {
        var ref, results;
        ref = this.data;
        results = [];
        for (k in ref) {
          v = ref[k];
          results.push(v);
        }
        return results;
      }).call(this);
    }

    Repository.prototype.resolve = function(library, version) {
      var i, len, lib, ref, ref1, ref2, ref3, ref4;
      ref = this.libraries;
      for (i = 0, len = ref.length; i < len; i++) {
        lib = ref[i];
        if (((ref1 = lib.library) != null ? (ref2 = ref1.identifier) != null ? ref2.id : void 0 : void 0) === library && ((ref3 = lib.library) != null ? (ref4 = ref3.identifier) != null ? ref4.version : void 0 : void 0) === version) {
          return new cql.Library(lib, this);
        }
      }
    };

    return Repository;

  })();

}).call(this);



},{"../cql":3}],44:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Results;

  module.exports.Results = Results = (function() {
    function Results() {
      this.patientResults = {};
      this.unfilteredResults = {};
      this.localIdPatientResultsMap = {};
    }

    Results.prototype.recordPatientResult = function(patient_ctx, resultName, result) {
      var base, p, patientId;
      p = patient_ctx.patient;
      patientId = typeof p.getId === 'function' ? p.getId() : p.id();
      if ((base = this.patientResults)[patientId] == null) {
        base[patientId] = {};
      }
      this.patientResults[patientId][resultName] = result;
      return this.localIdPatientResultsMap[patientId] = patient_ctx.getAllLocalIds();
    };

    Results.prototype.recordUnfilteredResult = function(resultName, result) {
      return this.unfilteredResults[resultName] = result;
    };

    return Results;

  })();

}).call(this);



},{}],45:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var DateTime, Uncertainty, areDateTimesOrQuantities, areNumbers, classesEqual, codesAreEquivalent, compareEveryItemInArrays, compareObjects, deepCompareKeysAndValues, equals, equivalent, getClassOfObjects, getKeysFromObject, isCode, isFunction, isUncertainty;

  DateTime = require('../datatypes/datetime').DateTime;

  Uncertainty = require('../datatypes/uncertainty').Uncertainty;

  areNumbers = function(a, b) {
    return typeof a === 'number' && typeof b === 'number';
  };

  areDateTimesOrQuantities = function(a, b) {
    return (a != null ? a.isDateTime : void 0) && (b != null ? b.isDateTime : void 0) || (a != null ? a.isDate : void 0) && (b != null ? b.isDate : void 0) || (a != null ? a.isTime : void 0) && (b != null ? b.isTime : void 0) || (a != null ? a.isQuantity : void 0) && (b != null ? b.isQuantity : void 0);
  };

  isUncertainty = function(x) {
    return x instanceof Uncertainty;
  };

  module.exports.lessThan = function(a, b, precision) {
    switch (false) {
      case !areNumbers(a, b):
        return a < b;
      case !areDateTimesOrQuantities(a, b):
        return a.before(b, precision);
      case !isUncertainty(a):
        return a.lessThan(b);
      case !isUncertainty(b):
        return Uncertainty.from(a).lessThan(b);
      default:
        return null;
    }
  };

  module.exports.lessThanOrEquals = function(a, b, precision) {
    switch (false) {
      case !areNumbers(a, b):
        return a <= b;
      case !areDateTimesOrQuantities(a, b):
        return a.sameOrBefore(b, precision);
      case !isUncertainty(a):
        return a.lessThanOrEquals(b);
      case !isUncertainty(b):
        return Uncertainty.from(a).lessThanOrEquals(b);
      default:
        return null;
    }
  };

  module.exports.greaterThan = function(a, b, precision) {
    switch (false) {
      case !areNumbers(a, b):
        return a > b;
      case !areDateTimesOrQuantities(a, b):
        return a.after(b, precision);
      case !isUncertainty(a):
        return a.greaterThan(b);
      case !isUncertainty(b):
        return Uncertainty.from(a).greaterThan(b);
      default:
        return null;
    }
  };

  module.exports.greaterThanOrEquals = function(a, b, precision) {
    switch (false) {
      case !areNumbers(a, b):
        return a >= b;
      case !areDateTimesOrQuantities(a, b):
        return a.sameOrAfter(b, precision);
      case !isUncertainty(a):
        return a.greaterThanOrEquals(b);
      case !isUncertainty(b):
        return Uncertainty.from(a).greaterThanOrEquals(b);
      default:
        return null;
    }
  };

  module.exports.equivalent = equivalent = function(a, b) {
    var aClass, bClass, ref;
    if ((a == null) && (b == null)) {
      return true;
    }
    if (!((a != null) && (b != null))) {
      return false;
    }
    if (isCode(a)) {
      return codesAreEquivalent(a, b);
    }
    if (typeof a.equivalent === 'function') {
      return a.equivalent(b);
    }
    ref = getClassOfObjects(a, b), aClass = ref[0], bClass = ref[1];
    switch (aClass) {
      case '[object Array]':
        return compareEveryItemInArrays(a, b, equivalent);
      case '[object Object]':
        return compareObjects(a, b, equivalent);
      case '[object String]':
        if (bClass === '[object String]') {
          a = a.replace(/\s/g, ' ');
          b = b.replace(/\s/g, ' ');
          return (a.localeCompare(b, 'en', {
            sensitivity: 'base'
          })) === 0;
        }
    }
    return equals(a, b);
  };

  isCode = function(object) {
    return object.hasMatch && typeof object.hasMatch === 'function';
  };

  codesAreEquivalent = function(code1, code2) {
    return code1.hasMatch(code2);
  };

  getClassOfObjects = function(object1, object2) {
    var obj;
    return (function() {
      var j, len, ref, results;
      ref = [object1, object2];
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        results.push({}.toString.call(obj));
      }
      return results;
    })();
  };

  compareEveryItemInArrays = function(array1, array2, comparisonFunction) {
    return array1.length === array2.length && array1.every(function(item, i) {
      return comparisonFunction(item, array2[i]);
    });
  };

  compareObjects = function(a, b, comparisonFunction) {
    if (!classesEqual(a, b)) {
      return false;
    }
    return deepCompareKeysAndValues(a, b, comparisonFunction);
  };

  classesEqual = function(object1, object2) {
    return object2 instanceof object1.constructor && object1 instanceof object2.constructor;
  };

  deepCompareKeysAndValues = function(a, b, comparisonFunction) {
    var aKeys, bKeys, finalComparisonResult, shouldReturnNull;
    aKeys = getKeysFromObject(a).sort();
    bKeys = getKeysFromObject(b).sort();
    shouldReturnNull = false;
    if (aKeys.length === bKeys.length && aKeys.every((function(_this) {
      return function(value, index) {
        return value === bKeys[index];
      };
    })(this))) {
      finalComparisonResult = aKeys.every(function(key) {
        var comparisonResult;
        if ((a[key] == null) && (b[key] == null)) {
          return true;
        }
        comparisonResult = comparisonFunction(a[key], b[key]);
        if (comparisonResult === null) {
          shouldReturnNull = true;
        }
        return comparisonResult;
      });
    } else {
      finalComparisonResult = false;
    }
    if (shouldReturnNull) {
      return null;
    }
    return finalComparisonResult;
  };

  getKeysFromObject = function(object) {
    var key, objectClass;
    objectClass = {}.toString.call(object);
    return ((function() {
      var results;
      if (!isFunction(key)) {
        results = [];
        for (key in object) {
          results.push(key);
        }
        return results;
      }
    })());
  };

  isFunction = function(input) {
    return input instanceof Function || {}.toString.call(input) === '[object Function]';
  };

  module.exports.equals = equals = function(a, b) {
    var aClass, bClass, ref;
    if (!((a != null) && (b != null))) {
      return null;
    }
    if (a != null ? a.isQuantity : void 0) {
      return a.equals(b);
    }
    if (a != null ? a.isRatio : void 0) {
      return a.equals(b);
    }
    if (a instanceof Uncertainty) {
      b = Uncertainty.from(b);
    } else if (b instanceof Uncertainty) {
      a = Uncertainty.from(a);
    }
    if (typeof a.equals === 'function') {
      return a.equals(b);
    }
    if (typeof a === typeof b && typeof a === 'string' || typeof a === 'number' || typeof a === 'boolean') {
      return a === b;
    }
    ref = getClassOfObjects(a, b), aClass = ref[0], bClass = ref[1];
    if (aClass !== bClass) {
      return false;
    }
    switch (aClass) {
      case '[object Date]':
        return a.getTime() === b.getTime();
      case '[object RegExp]':
        return ['source', 'global', 'ignoreCase', 'multiline'].every(function(p) {
          return a[p] === b[p];
        });
      case '[object Array]':
        if (a.indexOf(null) >= 0 || a.indexOf(void 0) >= 0 || b.indexOf(null) >= 0 || b.indexOf(void 0) >= 0) {
          return null;
        }
        return compareEveryItemInArrays(a, b, equals);
      case '[object Object]':
        return compareObjects(a, b, equals);
      case '[object Function]':
        return a.toString() === b.toString();
    }
    return false;
  };

}).call(this);



},{"../datatypes/datetime":6,"../datatypes/uncertainty":12}],46:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var Date, DateTime, Exception, MAX_DATETIME_VALUE, MAX_DATE_VALUE, MAX_FLOAT_VALUE, MAX_INT_VALUE, MAX_TIME_VALUE, MIN_DATETIME_VALUE, MIN_DATE_VALUE, MIN_FLOAT_PRECISION_VALUE, MIN_FLOAT_VALUE, MIN_INT_VALUE, MIN_TIME_VALUE, OverFlowException, Uncertainty, isValidDecimal, isValidInteger, predecessor, ref, successor,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Exception = require('../datatypes/exception').Exception;

  ref = require('../datatypes/datetime'), DateTime = ref.DateTime, Date = ref.Date;

  Uncertainty = require('../datatypes/uncertainty').Uncertainty;

  module.exports.MAX_INT_VALUE = MAX_INT_VALUE = Math.pow(2, 31) - 1;

  module.exports.MIN_INT_VALUE = MIN_INT_VALUE = Math.pow(-2, 31);

  module.exports.MAX_FLOAT_VALUE = MAX_FLOAT_VALUE = 99999999999999999999999999999.99999999;

  module.exports.MIN_FLOAT_VALUE = MIN_FLOAT_VALUE = -99999999999999999999999999999.99999999;

  module.exports.MIN_FLOAT_PRECISION_VALUE = MIN_FLOAT_PRECISION_VALUE = Math.pow(10, -8);

  module.exports.MIN_DATETIME_VALUE = MIN_DATETIME_VALUE = DateTime.parse("0001-01-01T00:00:00.000");

  module.exports.MAX_DATETIME_VALUE = MAX_DATETIME_VALUE = DateTime.parse("9999-12-31T23:59:59.999");

  module.exports.MIN_DATE_VALUE = MIN_DATE_VALUE = Date.parse("0001-01-01");

  module.exports.MAX_DATE_VALUE = MAX_DATE_VALUE = Date.parse("9999-12-31");

  module.exports.MIN_TIME_VALUE = MIN_TIME_VALUE = DateTime.parse("0000-01-01T00:00:00.000");

  module.exports.MAX_TIME_VALUE = MAX_TIME_VALUE = DateTime.parse("0000-01-01T23:59:59.999");

  module.exports.overflowsOrUnderflows = function(value) {
    if (value == null) {
      return false;
    }
    if (value.isQuantity) {
      if (!isValidDecimal(value.value)) {
        return true;
      }
    } else if ((value.isTime != null) && value.isTime()) {
      if (value.after(MAX_TIME_VALUE)) {
        return true;
      }
      if (value.before(MIN_TIME_VALUE)) {
        return true;
      }
    } else if (value.isDateTime) {
      if (value.after(MAX_DATETIME_VALUE)) {
        return true;
      }
      if (value.before(MIN_DATETIME_VALUE)) {
        return true;
      }
    } else if (value.isDate) {
      if (value.after(MAX_DATE_VALUE)) {
        return true;
      }
      if (value.before(MIN_DATE_VALUE)) {
        return true;
      }
    } else if (Number.isInteger(value)) {
      if (!isValidInteger(value)) {
        return true;
      }
    } else {
      if (!isValidDecimal(value)) {
        return true;
      }
    }
    return false;
  };

  module.exports.isValidInteger = isValidInteger = function(integer) {
    if (isNaN(integer)) {
      return false;
    }
    if (integer > MAX_INT_VALUE) {
      return false;
    }
    if (integer < MIN_INT_VALUE) {
      return false;
    }
    return true;
  };

  module.exports.isValidDecimal = isValidDecimal = function(decimal) {
    if (isNaN(decimal)) {
      return false;
    }
    if (decimal > MAX_FLOAT_VALUE) {
      return false;
    }
    if (decimal < MIN_FLOAT_VALUE) {
      return false;
    }
    return true;
  };

  module.exports.limitDecimalPrecision = function(decimal) {
    var decimalPoints, decimalString, splitDecimalString;
    decimalString = decimal.toString();
    if (decimalString.indexOf('e') !== -1) {
      return decimal;
    }
    splitDecimalString = decimalString.split('.');
    decimalPoints = splitDecimalString[1];
    if ((decimalPoints != null) && decimalPoints.length > 8) {
      decimalString = splitDecimalString[0] + '.' + splitDecimalString[1].substring(0, 8);
    }
    return parseFloat(decimalString);
  };

  module.exports.OverFlowException = OverFlowException = OverFlowException = (function(superClass) {
    extend(OverFlowException, superClass);

    function OverFlowException() {
      return OverFlowException.__super__.constructor.apply(this, arguments);
    }

    return OverFlowException;

  })(Exception);

  module.exports.successor = successor = function(val) {
    var e, high, succ;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        if (val === MAX_INT_VALUE) {
          throw new OverFlowException();
        } else {
          return val + 1;
        }
      } else {
        if (val === MAX_FLOAT_VALUE) {
          throw new OverFlowException();
        } else {
          return val + MIN_FLOAT_PRECISION_VALUE;
        }
      }
    } else if (val != null ? val.isDateTime : void 0) {
      if (val.sameAs(MAX_DATETIME_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.successor();
      }
    } else if (val != null ? val.isDate : void 0) {
      if (val.sameAs(MAX_DATE_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.successor();
      }
    } else if (val != null ? val.isTime : void 0) {
      if (val.sameAs(MAX_TIME_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.successor();
      }
    } else if (val != null ? val.isUncertainty : void 0) {
      high = (function() {
        try {
          return successor(val.high);
        } catch (error) {
          e = error;
          return val.high;
        }
      })();
      return new Uncertainty(successor(val.low), high);
    } else if (val != null ? val.isQuantity : void 0) {
      succ = val.clone();
      succ.value = successor(val.value);
      return succ;
    } else if (val == null) {
      return null;
    }
  };

  module.exports.predecessor = predecessor = function(val) {
    var e, low, pred;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        if (val === MIN_INT_VALUE) {
          throw new OverFlowException();
        } else {
          return val - 1;
        }
      } else {
        if (val === MIN_FLOAT_VALUE) {
          throw new OverFlowException();
        } else {
          return val - MIN_FLOAT_PRECISION_VALUE;
        }
      }
    } else if (val != null ? val.isDateTime : void 0) {
      if (val.sameAs(MIN_DATETIME_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.predecessor();
      }
    } else if (val != null ? val.isDate : void 0) {
      if (val.sameAs(MIN_DATE_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.predecessor();
      }
    } else if (val != null ? val.isTime : void 0) {
      if (val.sameAs(MIN_TIME_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.predecessor();
      }
    } else if (val != null ? val.isUncertainty : void 0) {
      low = (function() {
        try {
          return predecessor(val.low);
        } catch (error) {
          e = error;
          return val.low;
        }
      })();
      return new Uncertainty(low, predecessor(val.high));
    } else if (val != null ? val.isQuantity : void 0) {
      pred = val.clone();
      pred.value = predecessor(val.value);
      return pred;
    } else if (val == null) {
      return null;
    }
  };

  module.exports.maxValueForInstance = function(val) {
    var val2;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        return MAX_INT_VALUE;
      } else {
        return MAX_FLOAT_VALUE;
      }
    } else if (val != null ? val.isDateTime : void 0) {
      return MAX_DATETIME_VALUE.copy();
    } else if (val != null ? val.isDate : void 0) {
      return MAX_DATE_VALUE.copy();
    } else if (val != null ? val.isTime : void 0) {
      return MAX_TIME_VALUE.copy();
    } else if (val != null ? val.isQuantity : void 0) {
      val2 = val.clone();
      val2.value = maxValueForInstance(val2.value);
      return val2;
    } else {
      return null;
    }
  };

  module.exports.minValueForInstance = function(val) {
    var val2;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        return MIN_INT_VALUE;
      } else {
        return MIN_FLOAT_VALUE;
      }
    } else if (val != null ? val.isDateTime : void 0) {
      return MIN_DATETIME_VALUE.copy();
    } else if (val != null ? val.isDate : void 0) {
      return MIN_DATE_VALUE.copy();
    } else if (val != null ? val.isTime : void 0) {
      return MIN_TIME_VALUE.copy();
    } else if (val != null ? val.isQuantity : void 0) {
      val2 = val.clone();
      val2.value = minValueForInstance(val2.value);
      return val2;
    } else {
      return null;
    }
  };

  module.exports.decimalAdjust = function(type, value, exp) {
    var v;
    if (typeof exp === 'undefined' || +exp === 0) {
      return Math[type](value);
    }
    value = +value;
    exp = +exp;
    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
      return 0/0;
    }
    value = value.toString().split('e');
    v = value[1] ? +value[1] - exp : -exp;
    value = Math[type](+(value[0] + 'e' + v));
    value = value.toString().split('e');
    v = value[1] ? +value[1] + exp : exp;
    return +(value[0] + 'e' + v);
  };

}).call(this);



},{"../datatypes/datetime":6,"../datatypes/exception":7,"../datatypes/uncertainty":12}],47:[function(require,module,exports){
// Generated by CoffeeScript 1.12.7
(function() {
  var getTimezoneSeparatorFromString, normalizeMillisecondsField, normalizeMillisecondsFieldInString, typeIsArray;

  module.exports.removeNulls = function(things) {
    return things.filter(function(x) {
      return x != null;
    });
  };

  module.exports.numerical_sort = function(things, direction) {
    if (direction == null) {
      direction = "asc";
    }
    return things.sort(function(a, b) {
      if (direction === "asc") {
        return a - b;
      } else {
        return b - a;
      }
    });
  };

  module.exports.isNull = function(value) {
    return value === null;
  };

  module.exports.typeIsArray = typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  module.exports.allTrue = function(things) {
    if (typeIsArray(things)) {
      return things.every(function(x) {
        return x;
      });
    } else {
      return things;
    }
  };

  module.exports.anyTrue = function(things) {
    if (typeIsArray(things)) {
      return things.some(function(x) {
        return x;
      });
    } else {
      return things;
    }
  };

  module.exports.jsDate = Date;

  module.exports.normalizeMillisecondsFieldInString = normalizeMillisecondsFieldInString = function(string, msString) {
    var beforeMs, msAndAfter, ref, timezoneField, timezoneSeparator;
    msString = normalizeMillisecondsField(msString);
    ref = string.split('.'), beforeMs = ref[0], msAndAfter = ref[1];
    timezoneSeparator = getTimezoneSeparatorFromString(msAndAfter);
    if (!!timezoneSeparator) {
      timezoneField = msAndAfter != null ? msAndAfter.split(timezoneSeparator)[1] : void 0;
    }
    if (timezoneField == null) {
      timezoneField = '';
    }
    return string = beforeMs + '.' + msString + timezoneSeparator + timezoneField;
  };

  module.exports.normalizeMillisecondsField = normalizeMillisecondsField = function(msString) {
    return msString = (msString + "00").substring(0, 3);
  };

  module.exports.getTimezoneSeparatorFromString = getTimezoneSeparatorFromString = function(string) {
    var ref, ref1, timezoneSeparator;
    if ((string != null ? (ref = string.match(/-/)) != null ? ref.length : void 0 : void 0) === 1) {
      return timezoneSeparator = '-';
    } else if ((string != null ? (ref1 = string.match(/\+/)) != null ? ref1.length : void 0 : void 0) === 1) {
      return timezoneSeparator = '+';
    } else {
      return timezoneSeparator = '';
    }
  };

}).call(this);



},{}],48:[function(require,module,exports){
//! moment.js
//! version : 2.20.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString(keepOffset) {
    if (!this.isValid()) {
        return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
            return this.toDate().toISOString();
        } else {
            return new Date(this._d.valueOf()).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.20.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

// currently HTML5 input type only supports 24-hour formats
hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',                             // <input type="date" />
    TIME: 'HH:mm',                                  // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
    WEEK: 'YYYY-[W]WW',                             // <input type="week" />
    MONTH: 'YYYY-MM'                                // <input type="month" />
};

return hooks;

})));

},{}],49:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],50:[function(require,module,exports){
module.exports={
  "10*": {
    "value": 10,
    "ucum": "1"
  },
  "10^": {
    "value": 10,
    "ucum": "1"
  },
  "[pi]": {
    "value": 3.141592653589793,
    "ucum": "1"
  },
  "%": {
    "value": 1,
    "ucum": "10*-2"
  },
  "[ppth]": {
    "value": 1,
    "ucum": "10*-3"
  },
  "[ppm]": {
    "value": 1,
    "ucum": "10*-6"
  },
  "[ppb]": {
    "value": 1,
    "ucum": "10*-9"
  },
  "[pptr]": {
    "value": 1,
    "ucum": "10*-12"
  },
  "mol": {
    "value": 6.0221367,
    "ucum": "10*23"
  },
  "sr": {
    "value": 1,
    "ucum": "rad2"
  },
  "Hz": {
    "value": 1,
    "ucum": "s-1"
  },
  "N": {
    "value": 1,
    "ucum": "kg.m/s2"
  },
  "Pa": {
    "value": 1,
    "ucum": "N/m2"
  },
  "J": {
    "value": 1,
    "ucum": "N.m"
  },
  "W": {
    "value": 1,
    "ucum": "J/s"
  },
  "A": {
    "value": 1,
    "ucum": "C/s"
  },
  "V": {
    "value": 1,
    "ucum": "J/C"
  },
  "F": {
    "value": 1,
    "ucum": "C/V"
  },
  "Ohm": {
    "value": 1,
    "ucum": "V/A"
  },
  "S": {
    "value": 1,
    "ucum": "Ohm-1"
  },
  "Wb": {
    "value": 1,
    "ucum": "V.s"
  },
  "Cel": {
    "value": null,
    "ucum": "cel(1 K)"
  },
  "T": {
    "value": 1,
    "ucum": "Wb/m2"
  },
  "H": {
    "value": 1,
    "ucum": "Wb/A"
  },
  "lm": {
    "value": 1,
    "ucum": "cd.sr"
  },
  "lx": {
    "value": 1,
    "ucum": "lm/m2"
  },
  "Bq": {
    "value": 1,
    "ucum": "s-1"
  },
  "Gy": {
    "value": 1,
    "ucum": "J/kg"
  },
  "Sv": {
    "value": 1,
    "ucum": "J/kg"
  },
  "gon": {
    "value": 0.9,
    "ucum": "deg"
  },
  "deg": {
    "value": 2,
    "ucum": "[pi].rad/360"
  },
  "'": {
    "value": 1,
    "ucum": "deg/60"
  },
  "''": {
    "value": 1,
    "ucum": "'/60"
  },
  "l": {
    "value": 1,
    "ucum": "dm3"
  },
  "L": {
    "value": 1,
    "ucum": "l"
  },
  "ar": {
    "value": 100,
    "ucum": "m2"
  },
  "min": {
    "value": 60,
    "ucum": "s"
  },
  "h": {
    "value": 60,
    "ucum": "min"
  },
  "d": {
    "value": 24,
    "ucum": "h"
  },
  "a_t": {
    "value": 365.24219,
    "ucum": "d"
  },
  "a_j": {
    "value": 365.25,
    "ucum": "d"
  },
  "a_g": {
    "value": 365.2425,
    "ucum": "d"
  },
  "a": {
    "value": 1,
    "ucum": "a_j"
  },
  "wk": {
    "value": 7,
    "ucum": "d"
  },
  "mo_s": {
    "value": 29.53059,
    "ucum": "d"
  },
  "mo_j": {
    "value": 1,
    "ucum": "a_j/12"
  },
  "mo_g": {
    "value": 1,
    "ucum": "a_g/12"
  },
  "mo": {
    "value": 1,
    "ucum": "mo_j"
  },
  "t": {
    "value": 1000,
    "ucum": "kg"
  },
  "bar": {
    "value": 100000,
    "ucum": "Pa"
  },
  "u": {
    "value": 1.6605402e-24,
    "ucum": "g"
  },
  "eV": {
    "value": 1,
    "ucum": "[e].V"
  },
  "AU": {
    "value": 149597.870691,
    "ucum": "Mm"
  },
  "pc": {
    "value": 30856780000000000,
    "ucum": "m"
  },
  "[c]": {
    "value": 299792458,
    "ucum": "m/s"
  },
  "[h]": {
    "value": 6.6260755e-24,
    "ucum": "J.s"
  },
  "[k]": {
    "value": 1.380658e-23,
    "ucum": "J/K"
  },
  "[eps_0]": {
    "value": 8.854187817e-12,
    "ucum": "F/m"
  },
  "[mu_0]": {
    "value": 1,
    "ucum": "4.[pi].10*-7.N/A2"
  },
  "[e]": {
    "value": 1.60217733e-19,
    "ucum": "C"
  },
  "[m_e]": {
    "value": 9.1093897e-28,
    "ucum": "g"
  },
  "[m_p]": {
    "value": 1.6726231e-24,
    "ucum": "g"
  },
  "[G]": {
    "value": 6.67259e-11,
    "ucum": "m3.kg-1.s-2"
  },
  "[g]": {
    "value": 9.80665,
    "ucum": "m/s2"
  },
  "atm": {
    "value": 101325,
    "ucum": "Pa"
  },
  "[ly]": {
    "value": 1,
    "ucum": "[c].a_j"
  },
  "gf": {
    "value": 1,
    "ucum": "g.[g]"
  },
  "[lbf_av]": {
    "value": 1,
    "ucum": "[lb_av].[g]"
  },
  "Ky": {
    "value": 1,
    "ucum": "cm-1"
  },
  "Gal": {
    "value": 1,
    "ucum": "cm/s2"
  },
  "dyn": {
    "value": 1,
    "ucum": "g.cm/s2"
  },
  "erg": {
    "value": 1,
    "ucum": "dyn.cm"
  },
  "P": {
    "value": 1,
    "ucum": "dyn.s/cm2"
  },
  "Bi": {
    "value": 10,
    "ucum": "A"
  },
  "St": {
    "value": 1,
    "ucum": "cm2/s"
  },
  "Mx": {
    "value": 1e-8,
    "ucum": "Wb"
  },
  "G": {
    "value": 0.0001,
    "ucum": "T"
  },
  "Oe": {
    "value": 250,
    "ucum": "/[pi].A/m"
  },
  "Gb": {
    "value": 1,
    "ucum": "Oe.cm"
  },
  "sb": {
    "value": 1,
    "ucum": "cd/cm2"
  },
  "Lmb": {
    "value": 1,
    "ucum": "cd/cm2/[pi]"
  },
  "ph": {
    "value": 0.0001,
    "ucum": "lx"
  },
  "Ci": {
    "value": 37000000000,
    "ucum": "Bq"
  },
  "R": {
    "value": 0.000258,
    "ucum": "C/kg"
  },
  "RAD": {
    "value": 100,
    "ucum": "erg/g"
  },
  "REM": {
    "value": 1,
    "ucum": "RAD"
  },
  "[in_i]": {
    "value": 2.54,
    "ucum": "cm"
  },
  "[ft_i]": {
    "value": 12,
    "ucum": "[in_i]"
  },
  "[yd_i]": {
    "value": 3,
    "ucum": "[ft_i]"
  },
  "[mi_i]": {
    "value": 5280,
    "ucum": "[ft_i]"
  },
  "[fth_i]": {
    "value": 6,
    "ucum": "[ft_i]"
  },
  "[nmi_i]": {
    "value": 1852,
    "ucum": "m"
  },
  "[kn_i]": {
    "value": 1,
    "ucum": "[nmi_i]/h"
  },
  "[sin_i]": {
    "value": 1,
    "ucum": "[in_i]2"
  },
  "[sft_i]": {
    "value": 1,
    "ucum": "[ft_i]2"
  },
  "[syd_i]": {
    "value": 1,
    "ucum": "[yd_i]2"
  },
  "[cin_i]": {
    "value": 1,
    "ucum": "[in_i]3"
  },
  "[cft_i]": {
    "value": 1,
    "ucum": "[ft_i]3"
  },
  "[cyd_i]": {
    "value": 1,
    "ucum": "[yd_i]3"
  },
  "[bf_i]": {
    "value": 144,
    "ucum": "[in_i]3"
  },
  "[cr_i]": {
    "value": 128,
    "ucum": "[ft_i]3"
  },
  "[mil_i]": {
    "value": 0.001,
    "ucum": "[in_i]"
  },
  "[cml_i]": {
    "value": 1,
    "ucum": "[pi]/4.[mil_i]2"
  },
  "[hd_i]": {
    "value": 4,
    "ucum": "[in_i]"
  },
  "[ft_us]": {
    "value": 1200,
    "ucum": "m/3937"
  },
  "[yd_us]": {
    "value": 3,
    "ucum": "[ft_us]"
  },
  "[in_us]": {
    "value": 1,
    "ucum": "[ft_us]/12"
  },
  "[rd_us]": {
    "value": 16.5,
    "ucum": "[ft_us]"
  },
  "[ch_us]": {
    "value": 4,
    "ucum": "[rd_us]"
  },
  "[lk_us]": {
    "value": 1,
    "ucum": "[ch_us]/100"
  },
  "[rch_us]": {
    "value": 100,
    "ucum": "[ft_us]"
  },
  "[rlk_us]": {
    "value": 1,
    "ucum": "[rch_us]/100"
  },
  "[fth_us]": {
    "value": 6,
    "ucum": "[ft_us]"
  },
  "[fur_us]": {
    "value": 40,
    "ucum": "[rd_us]"
  },
  "[mi_us]": {
    "value": 8,
    "ucum": "[fur_us]"
  },
  "[acr_us]": {
    "value": 160,
    "ucum": "[rd_us]2"
  },
  "[srd_us]": {
    "value": 1,
    "ucum": "[rd_us]2"
  },
  "[smi_us]": {
    "value": 1,
    "ucum": "[mi_us]2"
  },
  "[sct]": {
    "value": 1,
    "ucum": "[mi_us]2"
  },
  "[twp]": {
    "value": 36,
    "ucum": "[sct]"
  },
  "[mil_us]": {
    "value": 0.001,
    "ucum": "[in_us]"
  },
  "[in_br]": {
    "value": 2.539998,
    "ucum": "cm"
  },
  "[ft_br]": {
    "value": 12,
    "ucum": "[in_br]"
  },
  "[rd_br]": {
    "value": 16.5,
    "ucum": "[ft_br]"
  },
  "[ch_br]": {
    "value": 4,
    "ucum": "[rd_br]"
  },
  "[lk_br]": {
    "value": 1,
    "ucum": "[ch_br]/100"
  },
  "[fth_br]": {
    "value": 6,
    "ucum": "[ft_br]"
  },
  "[pc_br]": {
    "value": 2.5,
    "ucum": "[ft_br]"
  },
  "[yd_br]": {
    "value": 3,
    "ucum": "[ft_br]"
  },
  "[mi_br]": {
    "value": 5280,
    "ucum": "[ft_br]"
  },
  "[nmi_br]": {
    "value": 6080,
    "ucum": "[ft_br]"
  },
  "[kn_br]": {
    "value": 1,
    "ucum": "[nmi_br]/h"
  },
  "[acr_br]": {
    "value": 4840,
    "ucum": "[yd_br]2"
  },
  "[gal_us]": {
    "value": 231,
    "ucum": "[in_i]3"
  },
  "[bbl_us]": {
    "value": 42,
    "ucum": "[gal_us]"
  },
  "[qt_us]": {
    "value": 1,
    "ucum": "[gal_us]/4"
  },
  "[pt_us]": {
    "value": 1,
    "ucum": "[qt_us]/2"
  },
  "[gil_us]": {
    "value": 1,
    "ucum": "[pt_us]/4"
  },
  "[foz_us]": {
    "value": 1,
    "ucum": "[gil_us]/4"
  },
  "[fdr_us]": {
    "value": 1,
    "ucum": "[foz_us]/8"
  },
  "[min_us]": {
    "value": 1,
    "ucum": "[fdr_us]/60"
  },
  "[crd_us]": {
    "value": 128,
    "ucum": "[ft_i]3"
  },
  "[bu_us]": {
    "value": 2150.42,
    "ucum": "[in_i]3"
  },
  "[gal_wi]": {
    "value": 1,
    "ucum": "[bu_us]/8"
  },
  "[pk_us]": {
    "value": 1,
    "ucum": "[bu_us]/4"
  },
  "[dqt_us]": {
    "value": 1,
    "ucum": "[pk_us]/8"
  },
  "[dpt_us]": {
    "value": 1,
    "ucum": "[dqt_us]/2"
  },
  "[tbs_us]": {
    "value": 1,
    "ucum": "[foz_us]/2"
  },
  "[tsp_us]": {
    "value": 1,
    "ucum": "[tbs_us]/3"
  },
  "[cup_us]": {
    "value": 16,
    "ucum": "[tbs_us]"
  },
  "[foz_m]": {
    "value": 30,
    "ucum": "mL"
  },
  "[cup_m]": {
    "value": 240,
    "ucum": "mL"
  },
  "[tsp_m]": {
    "value": 5,
    "ucum": "mL"
  },
  "[tbs_m]": {
    "value": 15,
    "ucum": "mL"
  },
  "[gal_br]": {
    "value": 4.54609,
    "ucum": "l"
  },
  "[pk_br]": {
    "value": 2,
    "ucum": "[gal_br]"
  },
  "[bu_br]": {
    "value": 4,
    "ucum": "[pk_br]"
  },
  "[qt_br]": {
    "value": 1,
    "ucum": "[gal_br]/4"
  },
  "[pt_br]": {
    "value": 1,
    "ucum": "[qt_br]/2"
  },
  "[gil_br]": {
    "value": 1,
    "ucum": "[pt_br]/4"
  },
  "[foz_br]": {
    "value": 1,
    "ucum": "[gil_br]/5"
  },
  "[fdr_br]": {
    "value": 1,
    "ucum": "[foz_br]/8"
  },
  "[min_br]": {
    "value": 1,
    "ucum": "[fdr_br]/60"
  },
  "[gr]": {
    "value": 64.79891,
    "ucum": "mg"
  },
  "[lb_av]": {
    "value": 7000,
    "ucum": "[gr]"
  },
  "[oz_av]": {
    "value": 1,
    "ucum": "[lb_av]/16"
  },
  "[dr_av]": {
    "value": 1,
    "ucum": "[oz_av]/16"
  },
  "[scwt_av]": {
    "value": 100,
    "ucum": "[lb_av]"
  },
  "[lcwt_av]": {
    "value": 112,
    "ucum": "[lb_av]"
  },
  "[ston_av]": {
    "value": 20,
    "ucum": "[scwt_av]"
  },
  "[lton_av]": {
    "value": 20,
    "ucum": "[lcwt_av]"
  },
  "[stone_av]": {
    "value": 14,
    "ucum": "[lb_av]"
  },
  "[pwt_tr]": {
    "value": 24,
    "ucum": "[gr]"
  },
  "[oz_tr]": {
    "value": 20,
    "ucum": "[pwt_tr]"
  },
  "[lb_tr]": {
    "value": 12,
    "ucum": "[oz_tr]"
  },
  "[sc_ap]": {
    "value": 20,
    "ucum": "[gr]"
  },
  "[dr_ap]": {
    "value": 3,
    "ucum": "[sc_ap]"
  },
  "[oz_ap]": {
    "value": 8,
    "ucum": "[dr_ap]"
  },
  "[lb_ap]": {
    "value": 12,
    "ucum": "[oz_ap]"
  },
  "[oz_m]": {
    "value": 28,
    "ucum": "g"
  },
  "[lne]": {
    "value": 1,
    "ucum": "[in_i]/12"
  },
  "[pnt]": {
    "value": 1,
    "ucum": "[lne]/6"
  },
  "[pca]": {
    "value": 12,
    "ucum": "[pnt]"
  },
  "[pnt_pr]": {
    "value": 0.013837,
    "ucum": "[in_i]"
  },
  "[pca_pr]": {
    "value": 12,
    "ucum": "[pnt_pr]"
  },
  "[pied]": {
    "value": 32.48,
    "ucum": "cm"
  },
  "[pouce]": {
    "value": 1,
    "ucum": "[pied]/12"
  },
  "[ligne]": {
    "value": 1,
    "ucum": "[pouce]/12"
  },
  "[didot]": {
    "value": 1,
    "ucum": "[ligne]/6"
  },
  "[cicero]": {
    "value": 12,
    "ucum": "[didot]"
  },
  "[degF]": {
    "value": null,
    "ucum": "degf(5 K/9)"
  },
  "[degR]": {
    "value": 5,
    "ucum": "K/9"
  },
  "cal_[15]": {
    "value": 4.1858,
    "ucum": "J"
  },
  "cal_[20]": {
    "value": 4.1819,
    "ucum": "J"
  },
  "cal_m": {
    "value": 4.19002,
    "ucum": "J"
  },
  "cal_IT": {
    "value": 4.1868,
    "ucum": "J"
  },
  "cal_th": {
    "value": 4.184,
    "ucum": "J"
  },
  "cal": {
    "value": 1,
    "ucum": "cal_th"
  },
  "[Cal]": {
    "value": 1,
    "ucum": "kcal_th"
  },
  "[Btu_39]": {
    "value": 1.05967,
    "ucum": "kJ"
  },
  "[Btu_59]": {
    "value": 1.0548,
    "ucum": "kJ"
  },
  "[Btu_60]": {
    "value": 1.05468,
    "ucum": "kJ"
  },
  "[Btu_m]": {
    "value": 1.05587,
    "ucum": "kJ"
  },
  "[Btu_IT]": {
    "value": 1.05505585262,
    "ucum": "kJ"
  },
  "[Btu_th]": {
    "value": 1.05435,
    "ucum": "kJ"
  },
  "[Btu]": {
    "value": 1,
    "ucum": "[Btu_th]"
  },
  "[HP]": {
    "value": 550,
    "ucum": "[ft_i].[lbf_av]/s"
  },
  "tex": {
    "value": 1,
    "ucum": "g/km"
  },
  "[den]": {
    "value": 1,
    "ucum": "g/9/km"
  },
  "m[H2O]": {
    "value": 9.80665,
    "ucum": "kPa"
  },
  "m[Hg]": {
    "value": 133.322,
    "ucum": "kPa"
  },
  "[in_i'H2O]": {
    "value": 1,
    "ucum": "m[H2O].[in_i]/m"
  },
  "[in_i'Hg]": {
    "value": 1,
    "ucum": "m[Hg].[in_i]/m"
  },
  "[PRU]": {
    "value": 1,
    "ucum": "mm[Hg].s/ml"
  },
  "[wood'U]": {
    "value": 1,
    "ucum": "mm[Hg].min/L"
  },
  "[diop]": {
    "value": 1,
    "ucum": "/m"
  },
  "[p'diop]": {
    "value": null,
    "ucum": "100tan(1 rad)"
  },
  "%[slope]": {
    "value": null,
    "ucum": "100tan(1 rad)"
  },
  "[mesh_i]": {
    "value": 1,
    "ucum": "/[in_i]"
  },
  "[Ch]": {
    "value": 1,
    "ucum": "mm/3"
  },
  "[drp]": {
    "value": 1,
    "ucum": "ml/20"
  },
  "[hnsf'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[MET]": {
    "value": 3.5,
    "ucum": "mL/min/kg"
  },
  "[hp'_X]": {
    "value": null,
    "ucum": "hpX(1 1)"
  },
  "[hp'_C]": {
    "value": null,
    "ucum": "hpC(1 1)"
  },
  "[hp'_M]": {
    "value": null,
    "ucum": "hpM(1 1)"
  },
  "[hp'_Q]": {
    "value": null,
    "ucum": "hpQ(1 1)"
  },
  "[hp_X]": {
    "value": 1,
    "ucum": "1"
  },
  "[hp_C]": {
    "value": 1,
    "ucum": "1"
  },
  "[hp_M]": {
    "value": 1,
    "ucum": "1"
  },
  "[hp_Q]": {
    "value": 1,
    "ucum": "1"
  },
  "[kp_X]": {
    "value": 1,
    "ucum": "1"
  },
  "[kp_C]": {
    "value": 1,
    "ucum": "1"
  },
  "[kp_M]": {
    "value": 1,
    "ucum": "1"
  },
  "[kp_Q]": {
    "value": 1,
    "ucum": "1"
  },
  "eq": {
    "value": 1,
    "ucum": "mol"
  },
  "osm": {
    "value": 1,
    "ucum": "mol"
  },
  "[pH]": {
    "value": null,
    "ucum": "pH(1 mol/l)"
  },
  "g%": {
    "value": 1,
    "ucum": "g/dl"
  },
  "[S]": {
    "value": 1,
    "ucum": "10*-13.s"
  },
  "[HPF]": {
    "value": 1,
    "ucum": "1"
  },
  "[LPF]": {
    "value": 100,
    "ucum": "1"
  },
  "kat": {
    "value": 1,
    "ucum": "mol/s"
  },
  "U": {
    "value": 1,
    "ucum": "umol/min"
  },
  "[iU]": {
    "value": 1,
    "ucum": "1"
  },
  "[IU]": {
    "value": 1,
    "ucum": "[iU]"
  },
  "[arb'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[USP'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[GPL'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[MPL'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[APL'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[beth'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[anti'Xa'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[todd'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[dye'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[smgy'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[bdsk'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[ka'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[knk'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[mclg'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[tb'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[CCID_50]": {
    "value": 1,
    "ucum": "1"
  },
  "[TCID_50]": {
    "value": 1,
    "ucum": "1"
  },
  "[EID_50]": {
    "value": 1,
    "ucum": "1"
  },
  "[PFU]": {
    "value": 1,
    "ucum": "1"
  },
  "[FFU]": {
    "value": 1,
    "ucum": "1"
  },
  "[CFU]": {
    "value": 1,
    "ucum": "1"
  },
  "[BAU]": {
    "value": 1,
    "ucum": "1"
  },
  "[AU]": {
    "value": 1,
    "ucum": "1"
  },
  "[Amb'a'1'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[PNU]": {
    "value": 1,
    "ucum": "1"
  },
  "[Lf]": {
    "value": 1,
    "ucum": "1"
  },
  "[D'ag'U]": {
    "value": 1,
    "ucum": "1"
  },
  "[FEU]": {
    "value": 1,
    "ucum": "1"
  },
  "[ELU]": {
    "value": 1,
    "ucum": "1"
  },
  "[EU]": {
    "value": 1,
    "ucum": "1"
  },
  "Np": {
    "value": null,
    "ucum": "ln(1 1)"
  },
  "B": {
    "value": null,
    "ucum": "lg(1 1)"
  },
  "B[SPL]": {
    "value": null,
    "ucum": "2lg(2 10*-5.Pa)"
  },
  "B[V]": {
    "value": null,
    "ucum": "2lg(1 V)"
  },
  "B[mV]": {
    "value": null,
    "ucum": "2lg(1 mV)"
  },
  "B[uV]": {
    "value": null,
    "ucum": "2lg(1 uV)"
  },
  "B[10.nV]": {
    "value": null,
    "ucum": "2lg(10 nV)"
  },
  "B[W]": {
    "value": null,
    "ucum": "lg(1 W)"
  },
  "B[kW]": {
    "value": null,
    "ucum": "lg(1 kW)"
  },
  "st": {
    "value": 1,
    "ucum": "m3"
  },
  "Ao": {
    "value": 0.1,
    "ucum": "nm"
  },
  "b": {
    "value": 100,
    "ucum": "fm2"
  },
  "att": {
    "value": 1,
    "ucum": "kgf/cm2"
  },
  "mho": {
    "value": 1,
    "ucum": "S"
  },
  "[psi]": {
    "value": 1,
    "ucum": "[lbf_av]/[in_i]2"
  },
  "circ": {
    "value": 2,
    "ucum": "[pi].rad"
  },
  "sph": {
    "value": 4,
    "ucum": "[pi].sr"
  },
  "[car_m]": {
    "value": 0.2,
    "ucum": "g"
  },
  "[car_Au]": {
    "value": 1,
    "ucum": "/24"
  },
  "[smoot]": {
    "value": 67,
    "ucum": "[in_i]"
  },
  "bit_s": {
    "value": null,
    "ucum": "ld(1 1)"
  },
  "bit": {
    "value": 1,
    "ucum": "1"
  },
  "By": {
    "value": 8,
    "ucum": "bit"
  },
  "Bd": {
    "value": 1,
    "ucum": "/s"
  }
}

},{}],51:[function(require,module,exports){
module.exports={"mol":true,"sr":true,"Hz":true,"N":true,"Pa":true,"J":true,"W":true,"A":true,"V":true,"F":true,"Ohm":true,"S":true,"Wb":true,"Cel":true,"T":true,"H":true,"lm":true,"lx":true,"Bq":true,"Gy":true,"Sv":true,"l":true,"L":true,"ar":true,"t":true,"bar":true,"u":true,"eV":true,"pc":true,"[c]":true,"[h]":true,"[k]":true,"[eps_0]":true,"[mu_0]":true,"[e]":true,"[m_e]":true,"[m_p]":true,"[G]":true,"[g]":true,"[ly]":true,"gf":true,"Ky":true,"Gal":true,"dyn":true,"erg":true,"P":true,"Bi":true,"St":true,"Mx":true,"G":true,"Oe":true,"Gb":true,"sb":true,"Lmb":true,"ph":true,"Ci":true,"R":true,"RAD":true,"REM":true,"cal_[15]":true,"cal_[20]":true,"cal_m":true,"cal_IT":true,"cal_th":true,"cal":true,"tex":true,"m[H2O]":true,"m[Hg]":true,"eq":true,"osm":true,"g%":true,"kat":true,"U":true,"[iU]":true,"[IU]":true,"Np":true,"B":true,"B[SPL]":true,"B[V]":true,"B[mV]":true,"B[uV]":true,"B[10.nV]":true,"B[W]":true,"B[kW]":true,"st":true,"mho":true,"bit":true,"By":true,"Bd":true,"m":true,"s":true,"g":true,"rad":true,"K":true,"C":true,"cd":true}

},{}],52:[function(require,module,exports){
module.exports={
  "Y": {
    "CODE": "YA",
    "names": [
      "yotta"
    ],
    "printSymbols": [
      "Y"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>24</sup>",
        "numeric": 1e+24
      }
    ]
  },
  "Z": {
    "CODE": "ZA",
    "names": [
      "zetta"
    ],
    "printSymbols": [
      "Z"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>21</sup>",
        "numeric": 1e+21
      }
    ]
  },
  "E": {
    "CODE": "EX",
    "names": [
      "exa"
    ],
    "printSymbols": [
      "E"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>18</sup>",
        "numeric": 1000000000000000000
      }
    ]
  },
  "P": {
    "CODE": "PT",
    "names": [
      "peta"
    ],
    "printSymbols": [
      "P"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>15</sup>",
        "numeric": 1000000000000000
      }
    ]
  },
  "T": {
    "CODE": "TR",
    "names": [
      "tera"
    ],
    "printSymbols": [
      "T"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>12</sup>",
        "numeric": 1000000000000
      }
    ]
  },
  "G": {
    "CODE": "GA",
    "names": [
      "giga"
    ],
    "printSymbols": [
      "G"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>9</sup>",
        "numeric": 1000000000
      }
    ]
  },
  "M": {
    "CODE": "MA",
    "names": [
      "mega"
    ],
    "printSymbols": [
      "M"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>6</sup>",
        "numeric": 1000000
      }
    ]
  },
  "k": {
    "CODE": "K",
    "names": [
      "kilo"
    ],
    "printSymbols": [
      "k"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>3</sup>",
        "numeric": 1000
      }
    ]
  },
  "h": {
    "CODE": "H",
    "names": [
      "hecto"
    ],
    "printSymbols": [
      "h"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>2</sup>",
        "numeric": 100
      }
    ]
  },
  "da": {
    "CODE": "DA",
    "names": [
      "deka"
    ],
    "printSymbols": [
      "da"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>1</sup>",
        "numeric": 10
      }
    ]
  },
  "d": {
    "CODE": "D",
    "names": [
      "deci"
    ],
    "printSymbols": [
      "d"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-1</sup>",
        "numeric": 0.1
      }
    ]
  },
  "c": {
    "CODE": "C",
    "names": [
      "centi"
    ],
    "printSymbols": [
      "c"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-2</sup>",
        "numeric": 0.01
      }
    ]
  },
  "m": {
    "CODE": "M",
    "names": [
      "milli"
    ],
    "printSymbols": [
      "m"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-3</sup>",
        "numeric": 0.001
      }
    ]
  },
  "u": {
    "CODE": "U",
    "names": [
      "micro"
    ],
    "printSymbols": [
      "&#956;"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-6</sup>",
        "numeric": 0.000001
      }
    ]
  },
  "n": {
    "CODE": "N",
    "names": [
      "nano"
    ],
    "printSymbols": [
      "n"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-9</sup>",
        "numeric": 1e-9
      }
    ]
  },
  "p": {
    "CODE": "P",
    "names": [
      "pico"
    ],
    "printSymbols": [
      "p"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-12</sup>",
        "numeric": 1e-12
      }
    ]
  },
  "f": {
    "CODE": "F",
    "names": [
      "femto"
    ],
    "printSymbols": [
      "f"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-15</sup>",
        "numeric": 1e-15
      }
    ]
  },
  "a": {
    "CODE": "A",
    "names": [
      "atto"
    ],
    "printSymbols": [
      "a"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-18</sup>",
        "numeric": 1e-18
      }
    ]
  },
  "z": {
    "CODE": "ZO",
    "names": [
      "zepto"
    ],
    "printSymbols": [
      "z"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-21</sup>",
        "numeric": 1e-21
      }
    ]
  },
  "y": {
    "CODE": "YO",
    "names": [
      "yocto"
    ],
    "printSymbols": [
      "y"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-24</sup>",
        "numeric": 1e-24
      }
    ]
  },
  "Ki": {
    "CODE": "KIB",
    "names": [
      "kibi"
    ],
    "printSymbols": [
      "Ki"
    ],
    "values": [
      {
        "printable": "1024",
        "numeric": 1024
      }
    ]
  },
  "Mi": {
    "CODE": "MIB",
    "names": [
      "mebi"
    ],
    "printSymbols": [
      "Mi"
    ],
    "values": [
      {
        "printable": "1048576",
        "numeric": 1048576
      }
    ]
  },
  "Gi": {
    "CODE": "GIB",
    "names": [
      "gibi"
    ],
    "printSymbols": [
      "Gi"
    ],
    "values": [
      {
        "printable": "1073741824",
        "numeric": 1073741824
      }
    ]
  },
  "Ti": {
    "CODE": "TIB",
    "names": [
      "tebi"
    ],
    "printSymbols": [
      "Ti"
    ],
    "values": [
      {
        "printable": "1099511627776",
        "numeric": 1099511627776
      }
    ]
  }
}

},{}],53:[function(require,module,exports){
module.exports={
  "Y": 1e+24,
  "Z": 1e+21,
  "E": 1000000000000000000,
  "P": 1000000000000000,
  "T": 1000000000000,
  "G": 1000000000,
  "M": 1000000,
  "k": 1000,
  "h": 100,
  "da": 10,
  "d": 0.1,
  "c": 0.01,
  "m": 0.001,
  "u": 0.000001,
  "n": 1e-9,
  "p": 1e-12,
  "f": 1e-15,
  "a": 1e-18,
  "z": 1e-21,
  "y": 1e-24,
  "Ki": 1024,
  "Mi": 1048576,
  "Gi": 1073741824,
  "Ti": 1099511627776
}

},{}],54:[function(require,module,exports){
module.exports = function () {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.offset = offset;
    this.line = line;
    this.column = column;

    this.name = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        peg$FAILED = {},
        peg$startRuleIndices = { start: 0 },
        peg$startRuleIndex = 0,
        peg$consts = [function (e) {
      return e; // cleanup(e);
    }, peg$FAILED, "/", { type: "literal", value: "/", description: "\"/\"" }, function (e) {
      return multiply({ value: 1, units: {} }, [["/", e]]);
    }, ".", { type: "literal", value: ".", description: "\".\"" }, [], function (t, ms) {
      return multiply(t, ms);
    }, null, function (e, exp) {
      return e.ann && exp;
    }, void 0, function (e, exp) {
      return topower(e, exp);
    }, function (d) {
      var ret = {
        value: d,
        units: {}
      };
      return ret;
    }, function (u) {
      return u;
    }, "(", { type: "literal", value: "(", description: "\"(\"" }, ")", { type: "literal", value: ")", description: "\")\"" }, function (e) {
      return e;
    }, /^[+\-]/, { type: "class", value: "[+\\-]", description: "[+\\-]" }, function (s, d) {
      return s == "-" ? -1 * d : d;
    }, function (p, a) {
      return p && !ismetric(a);
    }, function (p, a) {
      var ret = a;
      var u = Object.keys(ret.units)[0];

      // console.log("simpleUnit: p:", JSON.stringify(p, null, 2), "a: ", JSON.stringify(a, null, 2));

      if (p) {
        ret.value = ret.value * prefixes[p];
        ret.metadata = {};
        if (prefixMetadata[p]) {
          // if this prefix has metadata, augment the return with it
          Object.keys(prefixMetadata[p]).forEach(function (key) {
            if (!ret.metadata[u]) {
              ret.metadata[u] = { prefix: {} };
            }
            ret.metadata[u].prefix[key] = prefixMetadata[p][key];
          });
        }

        // merge in the unit metadata
        if (unitMetadata[u]) {
          //console.log("simpleUnit: ", JSON.stringify(unitMetadata[u], null ,2));
          Object.keys(unitMetadata[u]).forEach(function (key) {
            if (!ret.metadata[u]) {
              ret.metadata[u] = {};
            }
            ret.metadata[u][key] = unitMetadata[u][key];
          });
        }
      }

      //console.log("simpleUnit: ret: ", JSON.stringify(ret, null ,2));
      return ret;
    }, /^[0-9]/, { type: "class", value: "[0-9]", description: "[0-9]" }, "e", { type: "literal", value: "e", description: "\"e\"" }, function (v, epresent, e) {
      return !epresent && !!e;
    }, function (v, epresent, e) {
      return parseInt(v.join("")) * Math.pow(10, e || 0);
    }, "{", { type: "literal", value: "{", description: "\"{\"" }, /^[^}]/, { type: "class", value: "[^}]", description: "[^}]" }, "}", { type: "literal", value: "}", description: "\"}\"" }, function (m) {
      return (/[^\x00-\x7F]/.test(m)
      );
    }, function (m) {
      return { value: 1, units: {}, ann: m };
    }, "[anti'Xa'U]", { type: "literal", value: "[anti'Xa'U]", description: "\"[anti'Xa'U]\"" }, function (u) {
      return { "value": 1, "units": { "[anti'Xa'U]": 1 }, "metadata": { "[anti'Xa'U]": { "isBase": false, "CODE": "[ANTI'XA'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["anti factor Xa unit"], "properties": ["biologic activity of factor Xa inhibitor (heparin)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[Amb'a'1'U]", { type: "literal", value: "[Amb'a'1'U]", description: "\"[Amb'a'1'U]\"" }, function (u) {
      return { "value": 1, "units": { "[Amb'a'1'U]": 1 }, "metadata": { "[Amb'a'1'U]": { "isBase": false, "CODE": "[AMB'A'1'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["allergen unit for Ambrosia artemisiifolia"], "printSymbols": ["Amb a 1 U"], "properties": ["procedure defined amount of the major allergen of ragweed."], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[stone_av]", { type: "literal", value: "[stone_av]", description: "\"[stone_av]\"" }, function (u) {
      return { "value": 1, "units": { "[stone_av]": 1 }, "metadata": { "[stone_av]": { "isBase": false, "CODE": "[STONE_AV]", "isMetric": "no", "class": "avoirdupois", "names": ["stone", "British stone"], "properties": ["mass"], "values": [{ "printable": "14", "numeric": 14 }] } } };
    }, "[in_i'H2O]", { type: "literal", value: "[in_i'H2O]", description: "\"[in_i'H2O]\"" }, function (u) {
      return { "value": 1, "units": { "[in_i'H2O]": 1 }, "metadata": { "[in_i'H2O]": { "isBase": false, "CODE": "[IN_I'H2O]", "isMetric": "no", "class": "clinical", "names": ["inch of water column"], "printSymbols": ["in&#160;H<sub>\n            <r>2</r>\n         </sub>O"], "properties": ["pressure"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[ston_av]", { type: "literal", value: "[ston_av]", description: "\"[ston_av]\"" }, function (u) {
      return { "value": 1, "units": { "[ston_av]": 1 }, "metadata": { "[ston_av]": { "isBase": false, "CODE": "[STON_AV]", "isMetric": "no", "class": "avoirdupois", "names": ["short ton", "U.S. ton"], "properties": ["mass"], "values": [{ "printable": "20", "numeric": 20 }] } } };
    }, "[TCID_50]", { type: "literal", value: "[TCID_50]", description: "\"[TCID_50]\"" }, function (u) {
      return { "value": 1, "units": { "[TCID_50]": 1 }, "metadata": { "[TCID_50]": { "isBase": false, "CODE": "[TCID_50]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["50% tissue culture infectious dose"], "printSymbols": ["TCID<sub>50</sub>"], "properties": ["biologic activity (infectivity) of an infectious agent preparation"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[CCID_50]", { type: "literal", value: "[CCID_50]", description: "\"[CCID_50]\"" }, function (u) {
      return { "value": 1, "units": { "[CCID_50]": 1 }, "metadata": { "[CCID_50]": { "isBase": false, "CODE": "[CCID_50]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["50% cell culture infectious dose"], "printSymbols": ["CCID<sub>50</sub>"], "properties": ["biologic activity (infectivity) of an infectious agent preparation"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[scwt_av]", { type: "literal", value: "[scwt_av]", description: "\"[scwt_av]\"" }, function (u) {
      return { "value": 1, "units": { "[scwt_av]": 1 }, "metadata": { "[scwt_av]": { "isBase": false, "CODE": "[SCWT_AV]", "isMetric": "no", "class": "avoirdupois", "names": ["short hundredweight", "U.S. hundredweight"], "properties": ["mass"], "values": [{ "printable": "100", "numeric": 100 }] } } };
    }, "[lcwt_av]", { type: "literal", value: "[lcwt_av]", description: "\"[lcwt_av]\"" }, function (u) {
      return { "value": 1, "units": { "[lcwt_av]": 1 }, "metadata": { "[lcwt_av]": { "isBase": false, "CODE": "[LCWT_AV]", "isMetric": "no", "class": "avoirdupois", "names": ["long hunderdweight", "British hundredweight"], "properties": ["mass"], "values": [{ "printable": "112", "numeric": 112 }] } } };
    }, "[lton_av]", { type: "literal", value: "[lton_av]", description: "\"[lton_av]\"" }, function (u) {
      return { "value": 1, "units": { "[lton_av]": 1 }, "metadata": { "[lton_av]": { "isBase": false, "CODE": "[LTON_AV]", "isMetric": "no", "class": "avoirdupois", "names": ["long ton", "British ton"], "properties": ["mass"], "values": [{ "printable": "20", "numeric": 20 }] } } };
    }, "[in_i'Hg]", { type: "literal", value: "[in_i'Hg]", description: "\"[in_i'Hg]\"" }, function (u) {
      return { "value": 1, "units": { "[in_i'Hg]": 1 }, "metadata": { "[in_i'Hg]": { "isBase": false, "CODE": "[IN_I'HG]", "isMetric": "no", "class": "clinical", "names": ["inch of mercury column"], "printSymbols": ["in&#160;Hg"], "properties": ["pressure"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[tbs_us]", { type: "literal", value: "[tbs_us]", description: "\"[tbs_us]\"" }, function (u) {
      return { "value": 1, "units": { "[tbs_us]": 1 }, "metadata": { "[tbs_us]": { "isBase": false, "CODE": "[TBS_US]", "isMetric": "no", "class": "us-volumes", "names": ["tablespoon"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[dpt_us]", { type: "literal", value: "[dpt_us]", description: "\"[dpt_us]\"" }, function (u) {
      return { "value": 1, "units": { "[dpt_us]": 1 }, "metadata": { "[dpt_us]": { "isBase": false, "CODE": "[DPT_US]", "isMetric": "no", "class": "us-volumes", "names": ["dry pint"], "properties": ["dry volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[bdsk'U]", { type: "literal", value: "[bdsk'U]", description: "\"[bdsk'U]\"" }, function (u) {
      return { "value": 1, "units": { "[bdsk'U]": 1 }, "metadata": { "[bdsk'U]": { "isBase": false, "CODE": "[BDSK'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Bodansky unit"], "properties": ["biologic activity of phosphatase"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[smgy'U]", { type: "literal", value: "[smgy'U]", description: "\"[smgy'U]\"" }, function (u) {
      return { "value": 1, "units": { "[smgy'U]": 1 }, "metadata": { "[smgy'U]": { "isBase": false, "CODE": "[SMGY'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Somogyi unit"], "properties": ["biologic activity of amylase"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[dqt_us]", { type: "literal", value: "[dqt_us]", description: "\"[dqt_us]\"" }, function (u) {
      return { "value": 1, "units": { "[dqt_us]": 1 }, "metadata": { "[dqt_us]": { "isBase": false, "CODE": "[DQT_US]", "isMetric": "no", "class": "us-volumes", "names": ["dry quart"], "properties": ["dry volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[todd'U]", { type: "literal", value: "[todd'U]", description: "\"[todd'U]\"" }, function (u) {
      return { "value": 1, "units": { "[todd'U]": 1 }, "metadata": { "[todd'U]": { "isBase": false, "CODE": "[TODD'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Todd unit"], "properties": ["biologic activity antistreptolysin O"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[D'ag'U]", { type: "literal", value: "[D'ag'U]", description: "\"[D'ag'U]\"" }, function (u) {
      return { "value": 1, "units": { "[D'ag'U]": 1 }, "metadata": { "[D'ag'U]": { "isBase": false, "CODE": "[D'AG'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["D-antigen unit"], "printSymbols": [""], "properties": ["procedure defined amount of a poliomyelitis d-antigen substance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[beth'U]", { type: "literal", value: "[beth'U]", description: "\"[beth'U]\"" }, function (u) {
      return { "value": 1, "units": { "[beth'U]": 1 }, "metadata": { "[beth'U]": { "isBase": false, "CODE": "[BETH'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Bethesda unit"], "properties": ["biologic activity of factor VIII inhibitor"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[gal_wi]", { type: "literal", value: "[gal_wi]", description: "\"[gal_wi]\"" }, function (u) {
      return { "value": 1, "units": { "[gal_wi]": 1 }, "metadata": { "[gal_wi]": { "isBase": false, "CODE": "[GAL_WI]", "isMetric": "no", "class": "us-volumes", "names": ["historical winchester gallon"], "properties": ["dry volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[crd_us]", { type: "literal", value: "[crd_us]", description: "\"[crd_us]\"" }, function (u) {
      return { "value": 1, "units": { "[crd_us]": 1 }, "metadata": { "[crd_us]": { "isBase": false, "CODE": "[CRD_US]", "isMetric": "no", "class": "us-volumes", "names": ["cord"], "properties": ["fluid volume"], "values": [{ "printable": "128", "numeric": 128 }] } } };
    }, "[min_us]", { type: "literal", value: "[min_us]", description: "\"[min_us]\"" }, function (u) {
      return { "value": 1, "units": { "[min_us]": 1 }, "metadata": { "[min_us]": { "isBase": false, "CODE": "[MIN_US]", "isMetric": "no", "class": "us-volumes", "names": ["minim"], "properties": ["fluid volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[fdr_us]", { type: "literal", value: "[fdr_us]", description: "\"[fdr_us]\"" }, function (u) {
      return { "value": 1, "units": { "[fdr_us]": 1 }, "metadata": { "[fdr_us]": { "isBase": false, "CODE": "[FDR_US]", "isMetric": "no", "class": "us-volumes", "names": ["fluid dram"], "properties": ["fluid volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[foz_us]", { type: "literal", value: "[foz_us]", description: "\"[foz_us]\"" }, function (u) {
      return { "value": 1, "units": { "[foz_us]": 1 }, "metadata": { "[foz_us]": { "isBase": false, "CODE": "[FOZ_US]", "isMetric": "no", "class": "us-volumes", "names": ["fluid ounce"], "printSymbols": ["oz fl"], "properties": ["fluid volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[gil_us]", { type: "literal", value: "[gil_us]", description: "\"[gil_us]\"" }, function (u) {
      return { "value": 1, "units": { "[gil_us]": 1 }, "metadata": { "[gil_us]": { "isBase": false, "CODE": "[GIL_US]", "isMetric": "no", "class": "us-volumes", "names": ["gill"], "properties": ["fluid volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[bbl_us]", { type: "literal", value: "[bbl_us]", description: "\"[bbl_us]\"" }, function (u) {
      return { "value": 1, "units": { "[bbl_us]": 1 }, "metadata": { "[bbl_us]": { "isBase": false, "CODE": "[BBL_US]", "isMetric": "no", "class": "us-volumes", "names": ["barrel"], "properties": ["fluid volume"], "values": [{ "printable": "42", "numeric": 42 }] } } };
    }, "[gal_us]", { type: "literal", value: "[gal_us]", description: "\"[gal_us]\"" }, function (u) {
      return { "value": 1, "units": { "[gal_us]": 1 }, "metadata": { "[gal_us]": { "isBase": false, "CODE": "[GAL_US]", "isMetric": "no", "class": "us-volumes", "names": ["Queen Anne's wine gallon"], "properties": ["fluid volume"], "values": [{ "printable": "231", "numeric": 231 }] } } };
    }, "[acr_br]", { type: "literal", value: "[acr_br]", description: "\"[acr_br]\"" }, function (u) {
      return { "value": 1, "units": { "[acr_br]": 1 }, "metadata": { "[acr_br]": { "isBase": false, "CODE": "[ACR_BR]", "isMetric": "no", "class": "brit-length", "names": ["acre"], "properties": ["area"], "values": [{ "printable": "4840", "numeric": 4840 }] } } };
    }, "[nmi_br]", { type: "literal", value: "[nmi_br]", description: "\"[nmi_br]\"" }, function (u) {
      return { "value": 1, "units": { "[nmi_br]": 1 }, "metadata": { "[nmi_br]": { "isBase": false, "CODE": "[NMI_BR]", "isMetric": "no", "class": "brit-length", "names": ["nautical mile"], "properties": ["length"], "values": [{ "printable": "6080", "numeric": 6080 }] } } };
    }, "[fth_br]", { type: "literal", value: "[fth_br]", description: "\"[fth_br]\"" }, function (u) {
      return { "value": 1, "units": { "[fth_br]": 1 }, "metadata": { "[fth_br]": { "isBase": false, "CODE": "[FTH_BR]", "isMetric": "no", "class": "brit-length", "names": ["fathom"], "properties": ["length"], "values": [{ "printable": "6", "numeric": 6 }] } } };
    }, "[mil_us]", { type: "literal", value: "[mil_us]", description: "\"[mil_us]\"" }, function (u) {
      return { "value": 1, "units": { "[mil_us]": 1 }, "metadata": { "[mil_us]": { "isBase": false, "CODE": "[MIL_US]", "isMetric": "no", "class": "us-lengths", "names": ["mil"], "properties": ["length"], "values": [{ "printable": "1 &#215; 10<sup>-3</sup>", "numeric": 0.001 }] } } };
    }, "[smi_us]", { type: "literal", value: "[smi_us]", description: "\"[smi_us]\"" }, function (u) {
      return { "value": 1, "units": { "[smi_us]": 1 }, "metadata": { "[smi_us]": { "isBase": false, "CODE": "[SMI_US]", "isMetric": "no", "class": "us-lengths", "names": ["square mile"], "properties": ["area"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[acr_us]", { type: "literal", value: "[acr_us]", description: "\"[acr_us]\"" }, function (u) {
      return { "value": 1, "units": { "[acr_us]": 1 }, "metadata": { "[acr_us]": { "isBase": false, "CODE": "[ACR_US]", "isMetric": "no", "class": "us-lengths", "names": ["acre"], "properties": ["area"], "values": [{ "printable": "160", "numeric": 160 }] } } };
    }, "[fur_us]", { type: "literal", value: "[fur_us]", description: "\"[fur_us]\"" }, function (u) {
      return { "value": 1, "units": { "[fur_us]": 1 }, "metadata": { "[fur_us]": { "isBase": false, "CODE": "[FUR_US]", "isMetric": "no", "class": "us-lengths", "names": ["furlong"], "properties": ["length"], "values": [{ "printable": "40", "numeric": 40 }] } } };
    }, "[fth_us]", { type: "literal", value: "[fth_us]", description: "\"[fth_us]\"" }, function (u) {
      return { "value": 1, "units": { "[fth_us]": 1 }, "metadata": { "[fth_us]": { "isBase": false, "CODE": "[FTH_US]", "isMetric": "no", "class": "us-lengths", "names": ["fathom"], "properties": ["length"], "values": [{ "printable": "6", "numeric": 6 }] } } };
    }, "[rlk_us]", { type: "literal", value: "[rlk_us]", description: "\"[rlk_us]\"" }, function (u) {
      return { "value": 1, "units": { "[rlk_us]": 1 }, "metadata": { "[rlk_us]": { "isBase": false, "CODE": "[RLK_US]", "isMetric": "no", "class": "us-lengths", "names": ["link for Ramden's chain"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[rch_us]", { type: "literal", value: "[rch_us]", description: "\"[rch_us]\"" }, function (u) {
      return { "value": 1, "units": { "[rch_us]": 1 }, "metadata": { "[rch_us]": { "isBase": false, "CODE": "[RCH_US]", "isMetric": "no", "class": "us-lengths", "names": ["Ramden's chain", "Engineer's chain"], "properties": ["length"], "values": [{ "printable": "100", "numeric": 100 }] } } };
    }, "[lbf_av]", { type: "literal", value: "[lbf_av]", description: "\"[lbf_av]\"" }, function (u) {
      return { "value": 1, "units": { "[lbf_av]": 1 }, "metadata": { "[lbf_av]": { "isBase": false, "CODE": "[LBF_AV]", "isMetric": "no", "class": "const", "names": ["pound force"], "printSymbols": ["lbf"], "properties": ["force"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[hnsf'U]", { type: "literal", value: "[hnsf'U]", description: "\"[hnsf'U]\"" }, function (u) {
      return { "value": 1, "units": { "[hnsf'U]": 1 }, "metadata": { "[hnsf'U]": { "isBase": false, "CODE": "[HNSF'U]", "isMetric": "no", "class": "clinical", "names": ["Hounsfield unit"], "printSymbols": ["HF"], "properties": ["x-ray attenuation"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[mesh_i]", { type: "literal", value: "[mesh_i]", description: "\"[mesh_i]\"" }, function (u) {
      return { "value": 1, "units": { "[mesh_i]": 1 }, "metadata": { "[mesh_i]": { "isBase": false, "CODE": "[MESH_I]", "isMetric": "no", "class": "clinical", "names": ["mesh"], "properties": ["lineic number"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "%[slope]", { type: "literal", value: "%[slope]", description: "\"%[slope]\"" }, function (u) {
      return { "value": 1, "units": { "%[slope]": 1 }, "metadata": { "%[slope]": { "isBase": false, "CODE": "%[SLOPE]", "isMetric": "no", "isSpecial": "yes", "class": "clinical", "names": ["percent of slope"], "printSymbols": ["%"], "properties": ["slope"], "values": [{ "printable": "<function name=\"100tan\" value=\"1\" Unit=\"deg\"/>", "numeric": null }] } } };
    }, "[p'diop]", { type: "literal", value: "[p'diop]", description: "\"[p'diop]\"" }, function (u) {
      return { "value": 1, "units": { "[p'diop]": 1 }, "metadata": { "[p'diop]": { "isBase": false, "CODE": "[P'DIOP]", "isMetric": "no", "isSpecial": "yes", "class": "clinical", "names": ["prism diopter"], "printSymbols": ["PD"], "properties": ["refraction of a prism"], "values": [{ "printable": "<function name=\"tanTimes100\" value=\"1\" Unit=\"deg\"/>", "numeric": null }] } } };
    }, "[gil_br]", { type: "literal", value: "[gil_br]", description: "\"[gil_br]\"" }, function (u) {
      return { "value": 1, "units": { "[gil_br]": 1 }, "metadata": { "[gil_br]": { "isBase": false, "CODE": "[GIL_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["gill"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[wood'U]", { type: "literal", value: "[wood'U]", description: "\"[wood'U]\"" }, function (u) {
      return { "value": 1, "units": { "[wood'U]": 1 }, "metadata": { "[wood'U]": { "isBase": false, "CODE": "[WOOD'U]", "isMetric": "no", "class": "clinical", "names": ["Wood unit"], "printSymbols": ["Wood U."], "properties": ["fluid resistance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "cal_[15]", { type: "literal", value: "cal_[15]", description: "\"cal_[15]\"" }, function (u) {
      return { "value": 1, "units": { "cal_[15]": 1 }, "metadata": { "cal_[15]": { "isBase": false, "CODE": "CAL_[15]", "isMetric": "yes", "class": "heat", "names": ["calorie at 15 °C"], "printSymbols": ["cal<sub>15&#176;C</sub>"], "properties": ["energy"], "values": [{ "printable": "4.18580", "numeric": 4.1858 }] } } };
    }, "cal_[20]", { type: "literal", value: "cal_[20]", description: "\"cal_[20]\"" }, function (u) {
      return { "value": 1, "units": { "cal_[20]": 1 }, "metadata": { "cal_[20]": { "isBase": false, "CODE": "CAL_[20]", "isMetric": "yes", "class": "heat", "names": ["calorie at 20 °C"], "printSymbols": ["cal<sub>20&#176;C</sub>"], "properties": ["energy"], "values": [{ "printable": "4.18190", "numeric": 4.1819 }] } } };
    }, "[foz_br]", { type: "literal", value: "[foz_br]", description: "\"[foz_br]\"" }, function (u) {
      return { "value": 1, "units": { "[foz_br]": 1 }, "metadata": { "[foz_br]": { "isBase": false, "CODE": "[FOZ_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["fluid ounce"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[fdr_br]", { type: "literal", value: "[fdr_br]", description: "\"[fdr_br]\"" }, function (u) {
      return { "value": 1, "units": { "[fdr_br]": 1 }, "metadata": { "[fdr_br]": { "isBase": false, "CODE": "[FDR_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["fluid dram"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[srd_us]", { type: "literal", value: "[srd_us]", description: "\"[srd_us]\"" }, function (u) {
      return { "value": 1, "units": { "[srd_us]": 1 }, "metadata": { "[srd_us]": { "isBase": false, "CODE": "[SRD_US]", "isMetric": "no", "class": "us-lengths", "names": ["square rod"], "properties": ["area"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[min_br]", { type: "literal", value: "[min_br]", description: "\"[min_br]\"" }, function (u) {
      return { "value": 1, "units": { "[min_br]": 1 }, "metadata": { "[min_br]": { "isBase": false, "CODE": "[MIN_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["minim"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[EID_50]", { type: "literal", value: "[EID_50]", description: "\"[EID_50]\"" }, function (u) {
      return { "value": 1, "units": { "[EID_50]": 1 }, "metadata": { "[EID_50]": { "isBase": false, "CODE": "[EID_50]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["50% embryo infectious dose"], "printSymbols": ["EID<sub>50</sub>"], "properties": ["biologic activity (infectivity) of an infectious agent preparation"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[Btu_th]", { type: "literal", value: "[Btu_th]", description: "\"[Btu_th]\"" }, function (u) {
      return { "value": 1, "units": { "[Btu_th]": 1 }, "metadata": { "[Btu_th]": { "isBase": false, "CODE": "[BTU_TH]", "isMetric": "no", "class": "heat", "names": ["thermochemical British thermal unit"], "printSymbols": ["Btu<sub>th</sub>"], "properties": ["energy"], "values": [{ "printable": "1.054350", "numeric": 1.05435 }] } } };
    }, "[Btu_IT]", { type: "literal", value: "[Btu_IT]", description: "\"[Btu_IT]\"" }, function (u) {
      return { "value": 1, "units": { "[Btu_IT]": 1 }, "metadata": { "[Btu_IT]": { "isBase": false, "CODE": "[BTU_IT]", "isMetric": "no", "class": "heat", "names": ["international table British thermal unit"], "printSymbols": ["Btu<sub>IT</sub>"], "properties": ["energy"], "values": [{ "printable": "1.05505585262", "numeric": 1.05505585262 }] } } };
    }, "[car_Au]", { type: "literal", value: "[car_Au]", description: "\"[car_Au]\"" }, function (u) {
      return { "value": 1, "units": { "[car_Au]": 1 }, "metadata": { "[car_Au]": { "isBase": false, "CODE": "[CAR_AU]", "isMetric": "no", "class": "misc", "names": ["carat of gold alloys"], "printSymbols": ["ct<sub>\n            <r>Au</r>\n         </sub>"], "properties": ["mass fraction"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[Btu_60]", { type: "literal", value: "[Btu_60]", description: "\"[Btu_60]\"" }, function (u) {
      return { "value": 1, "units": { "[Btu_60]": 1 }, "metadata": { "[Btu_60]": { "isBase": false, "CODE": "[BTU_60]", "isMetric": "no", "class": "heat", "names": ["British thermal unit at 60 °F"], "printSymbols": ["Btu<sub>60&#176;F</sub>"], "properties": ["energy"], "values": [{ "printable": "1.05468", "numeric": 1.05468 }] } } };
    }, "[Btu_59]", { type: "literal", value: "[Btu_59]", description: "\"[Btu_59]\"" }, function (u) {
      return { "value": 1, "units": { "[Btu_59]": 1 }, "metadata": { "[Btu_59]": { "isBase": false, "CODE": "[BTU_59]", "isMetric": "no", "class": "heat", "names": ["British thermal unit at 59 °F"], "printSymbols": ["Btu<sub>59&#176;F</sub>"], "properties": ["energy"], "values": [{ "printable": "1.05480", "numeric": 1.0548 }] } } };
    }, "[Btu_39]", { type: "literal", value: "[Btu_39]", description: "\"[Btu_39]\"" }, function (u) {
      return { "value": 1, "units": { "[Btu_39]": 1 }, "metadata": { "[Btu_39]": { "isBase": false, "CODE": "[BTU_39]", "isMetric": "no", "class": "heat", "names": ["British thermal unit at 39 °F"], "printSymbols": ["Btu<sub>39&#176;F</sub>"], "properties": ["energy"], "values": [{ "printable": "1.05967", "numeric": 1.05967 }] } } };
    }, "[cup_us]", { type: "literal", value: "[cup_us]", description: "\"[cup_us]\"" }, function (u) {
      return { "value": 1, "units": { "[cup_us]": 1 }, "metadata": { "[cup_us]": { "isBase": false, "CODE": "[CUP_US]", "isMetric": "no", "class": "us-volumes", "names": ["cup"], "properties": ["volume"], "values": [{ "printable": "16", "numeric": 16 }] } } };
    }, "B[10.nV]", { type: "literal", value: "B[10.nV]", description: "\"B[10.nV]\"" }, function (u) {
      return { "value": 1, "units": { "B[10.nV]": 1 }, "metadata": { "B[10.nV]": { "isBase": false, "CODE": "B[10.NV]", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["bel 10 nanovolt"], "printSymbols": ["B(10 nV)"], "properties": ["electric potential level"], "values": [{ "printable": "<function name=\"lgTimes2\" value=\"10\" Unit=\"nV\"/>", "numeric": null }] } } };
    }, "[tsp_us]", { type: "literal", value: "[tsp_us]", description: "\"[tsp_us]\"" }, function (u) {
      return { "value": 1, "units": { "[tsp_us]": 1 }, "metadata": { "[tsp_us]": { "isBase": false, "CODE": "[TSP_US]", "isMetric": "no", "class": "us-volumes", "names": ["teaspoon"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[mclg'U]", { type: "literal", value: "[mclg'U]", description: "\"[mclg'U]\"" }, function (u) {
      return { "value": 1, "units": { "[mclg'U]": 1 }, "metadata": { "[mclg'U]": { "isBase": false, "CODE": "[MCLG'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Mac Lagan unit"], "properties": ["arbitrary biologic activity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[cicero]", { type: "literal", value: "[cicero]", description: "\"[cicero]\"" }, function (u) {
      return { "value": 1, "units": { "[cicero]": 1 }, "metadata": { "[cicero]": { "isBase": false, "CODE": "[CICERO]", "isMetric": "no", "class": "typeset", "names": ["cicero", "Didot's pica"], "properties": ["length"], "values": [{ "printable": "12", "numeric": 12 }] } } };
    }, "[pwt_tr]", { type: "literal", value: "[pwt_tr]", description: "\"[pwt_tr]\"" }, function (u) {
      return { "value": 1, "units": { "[pwt_tr]": 1 }, "metadata": { "[pwt_tr]": { "isBase": false, "CODE": "[PWT_TR]", "isMetric": "no", "class": "troy", "names": ["pennyweight"], "printSymbols": ["dwt"], "properties": ["mass"], "values": [{ "printable": "24", "numeric": 24 }] } } };
    }, "[pnt_pr]", { type: "literal", value: "[pnt_pr]", description: "\"[pnt_pr]\"" }, function (u) {
      return { "value": 1, "units": { "[pnt_pr]": 1 }, "metadata": { "[pnt_pr]": { "isBase": false, "CODE": "[PNT_PR]", "isMetric": "no", "class": "typeset", "names": ["Printer's point"], "properties": ["length"], "values": [{ "printable": "0.013837", "numeric": 0.013837 }] } } };
    }, "[pca_pr]", { type: "literal", value: "[pca_pr]", description: "\"[pca_pr]\"" }, function (u) {
      return { "value": 1, "units": { "[pca_pr]": 1 }, "metadata": { "[pca_pr]": { "isBase": false, "CODE": "[PCA_PR]", "isMetric": "no", "class": "typeset", "names": ["Printer's pica"], "properties": ["length"], "values": [{ "printable": "12", "numeric": 12 }] } } };
    }, "[gal_br]", { type: "literal", value: "[gal_br]", description: "\"[gal_br]\"" }, function (u) {
      return { "value": 1, "units": { "[gal_br]": 1 }, "metadata": { "[gal_br]": { "isBase": false, "CODE": "[GAL_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["gallon"], "properties": ["volume"], "values": [{ "printable": "4.54609", "numeric": 4.54609 }] } } };
    }, "[yd_us]", { type: "literal", value: "[yd_us]", description: "\"[yd_us]\"" }, function (u) {
      return { "value": 1, "units": { "[yd_us]": 1 }, "metadata": { "[yd_us]": { "isBase": false, "CODE": "[YD_US]", "isMetric": "no", "class": "us-lengths", "names": ["yard"], "properties": ["length"], "values": [{ "printable": "3", "numeric": 3 }] } } };
    }, "[ligne]", { type: "literal", value: "[ligne]", description: "\"[ligne]\"" }, function (u) {
      return { "value": 1, "units": { "[ligne]": 1 }, "metadata": { "[ligne]": { "isBase": false, "CODE": "[LIGNE]", "isMetric": "no", "class": "typeset", "names": ["ligne", "French line"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[tbs_m]", { type: "literal", value: "[tbs_m]", description: "\"[tbs_m]\"" }, function (u) {
      return { "value": 1, "units": { "[tbs_m]": 1 }, "metadata": { "[tbs_m]": { "isBase": false, "CODE": "[TBS_M]", "isMetric": "no", "class": "us-volumes", "names": ["metric tablespoon"], "properties": ["volume"], "values": [{ "printable": "15", "numeric": 15 }] } } };
    }, "[lb_ap]", { type: "literal", value: "[lb_ap]", description: "\"[lb_ap]\"" }, function (u) {
      return { "value": 1, "units": { "[lb_ap]": 1 }, "metadata": { "[lb_ap]": { "isBase": false, "CODE": "[LB_AP]", "isMetric": "no", "class": "apoth", "names": ["pound"], "printSymbols": ["<strike>lb</strike>"], "properties": ["mass"], "values": [{ "printable": "12", "numeric": 12 }] } } };
    }, "[oz_ap]", { type: "literal", value: "[oz_ap]", description: "\"[oz_ap]\"" }, function (u) {
      return { "value": 1, "units": { "[oz_ap]": 1 }, "metadata": { "[oz_ap]": { "isBase": false, "CODE": "[OZ_AP]", "isMetric": "no", "class": "apoth", "names": ["ounce"], "printSymbols": ["&#8485;"], "properties": ["mass"], "values": [{ "printable": "8", "numeric": 8 }] } } };
    }, "[dr_ap]", { type: "literal", value: "[dr_ap]", description: "\"[dr_ap]\"" }, function (u) {
      return { "value": 1, "units": { "[dr_ap]": 1 }, "metadata": { "[dr_ap]": { "isBase": false, "CODE": "[DR_AP]", "isMetric": "no", "class": "apoth", "names": ["dram", "drachm"], "printSymbols": ["&#658;"], "properties": ["mass"], "values": [{ "printable": "3", "numeric": 3 }] } } };
    }, "[sc_ap]", { type: "literal", value: "[sc_ap]", description: "\"[sc_ap]\"" }, function (u) {
      return { "value": 1, "units": { "[sc_ap]": 1 }, "metadata": { "[sc_ap]": { "isBase": false, "CODE": "[SC_AP]", "isMetric": "no", "class": "apoth", "names": ["scruple"], "printSymbols": ["&#8456;"], "properties": ["mass"], "values": [{ "printable": "20", "numeric": 20 }] } } };
    }, "[tsp_m]", { type: "literal", value: "[tsp_m]", description: "\"[tsp_m]\"" }, function (u) {
      return { "value": 1, "units": { "[tsp_m]": 1 }, "metadata": { "[tsp_m]": { "isBase": false, "CODE": "[TSP_M]", "isMetric": "no", "class": "us-volumes", "names": ["metric teaspoon"], "properties": ["volume"], "values": [{ "printable": "5", "numeric": 5 }] } } };
    }, "[cup_m]", { type: "literal", value: "[cup_m]", description: "\"[cup_m]\"" }, function (u) {
      return { "value": 1, "units": { "[cup_m]": 1 }, "metadata": { "[cup_m]": { "isBase": false, "CODE": "[CUP_M]", "isMetric": "no", "class": "us-volumes", "names": ["metric cup"], "properties": ["volume"], "values": [{ "printable": "240", "numeric": 240 }] } } };
    }, "[lb_tr]", { type: "literal", value: "[lb_tr]", description: "\"[lb_tr]\"" }, function (u) {
      return { "value": 1, "units": { "[lb_tr]": 1 }, "metadata": { "[lb_tr]": { "isBase": false, "CODE": "[LB_TR]", "isMetric": "no", "class": "troy", "names": ["troy pound"], "printSymbols": ["lb t"], "properties": ["mass"], "values": [{ "printable": "12", "numeric": 12 }] } } };
    }, "[oz_tr]", { type: "literal", value: "[oz_tr]", description: "\"[oz_tr]\"" }, function (u) {
      return { "value": 1, "units": { "[oz_tr]": 1 }, "metadata": { "[oz_tr]": { "isBase": false, "CODE": "[OZ_TR]", "isMetric": "no", "class": "troy", "names": ["troy ounce"], "printSymbols": ["oz t"], "properties": ["mass"], "values": [{ "printable": "20", "numeric": 20 }] } } };
    }, "[didot]", { type: "literal", value: "[didot]", description: "\"[didot]\"" }, function (u) {
      return { "value": 1, "units": { "[didot]": 1 }, "metadata": { "[didot]": { "isBase": false, "CODE": "[DIDOT]", "isMetric": "no", "class": "typeset", "names": ["didot", "Didot's point"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[foz_m]", { type: "literal", value: "[foz_m]", description: "\"[foz_m]\"" }, function (u) {
      return { "value": 1, "units": { "[foz_m]": 1 }, "metadata": { "[foz_m]": { "isBase": false, "CODE": "[FOZ_M]", "isMetric": "no", "class": "us-volumes", "names": ["metric fluid ounce"], "printSymbols": ["oz fl"], "properties": ["fluid volume"], "values": [{ "printable": "30", "numeric": 30 }] } } };
    }, "[car_m]", { type: "literal", value: "[car_m]", description: "\"[car_m]\"" }, function (u) {
      return { "value": 1, "units": { "[car_m]": 1 }, "metadata": { "[car_m]": { "isBase": false, "CODE": "[CAR_M]", "isMetric": "no", "class": "misc", "names": ["metric carat"], "printSymbols": ["ct<sub>m</sub>"], "properties": ["mass"], "values": [{ "printable": "0.2", "numeric": 0.2 }] } } };
    }, "[smoot]", { type: "literal", value: "[smoot]", description: "\"[smoot]\"" }, function (u) {
      return { "value": 1, "units": { "[smoot]": 1 }, "metadata": { "[smoot]": { "isBase": false, "CODE": "[SMOOT]", "isMetric": "no", "class": "misc", "names": ["Smoot"], "printSymbols": [""], "properties": ["length"], "values": [{ "printable": "67", "numeric": 67 }] } } };
    }, "[knk'U]", { type: "literal", value: "[knk'U]", description: "\"[knk'U]\"" }, function (u) {
      return { "value": 1, "units": { "[knk'U]": 1 }, "metadata": { "[knk'U]": { "isBase": false, "CODE": "[KNK'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Kunkel unit"], "properties": ["arbitrary biologic activity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[Btu_m]", { type: "literal", value: "[Btu_m]", description: "\"[Btu_m]\"" }, function (u) {
      return { "value": 1, "units": { "[Btu_m]": 1 }, "metadata": { "[Btu_m]": { "isBase": false, "CODE": "[BTU_M]", "isMetric": "no", "class": "heat", "names": ["mean British thermal unit"], "printSymbols": ["Btu<sub>m</sub>"], "properties": ["energy"], "values": [{ "printable": "1.05587", "numeric": 1.05587 }] } } };
    }, "[dr_av]", { type: "literal", value: "[dr_av]", description: "\"[dr_av]\"" }, function (u) {
      return { "value": 1, "units": { "[dr_av]": 1 }, "metadata": { "[dr_av]": { "isBase": false, "CODE": "[DR_AV]", "isMetric": "no", "class": "avoirdupois", "names": ["dram"], "properties": ["mass"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[oz_av]", { type: "literal", value: "[oz_av]", description: "\"[oz_av]\"" }, function (u) {
      return { "value": 1, "units": { "[oz_av]": 1 }, "metadata": { "[oz_av]": { "isBase": false, "CODE": "[OZ_AV]", "isMetric": "no", "class": "avoirdupois", "names": ["ounce"], "printSymbols": ["oz"], "properties": ["mass"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[lb_av]", { type: "literal", value: "[lb_av]", description: "\"[lb_av]\"" }, function (u) {
      return { "value": 1, "units": { "[lb_av]": 1 }, "metadata": { "[lb_av]": { "isBase": false, "CODE": "[LB_AV]", "isMetric": "no", "class": "avoirdupois", "names": ["pound"], "printSymbols": ["lb"], "properties": ["mass"], "values": [{ "printable": "7000", "numeric": 7000 }] } } };
    }, "[dye'U]", { type: "literal", value: "[dye'U]", description: "\"[dye'U]\"" }, function (u) {
      return { "value": 1, "units": { "[dye'U]": 1 }, "metadata": { "[dye'U]": { "isBase": false, "CODE": "[DYE'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Dye unit"], "properties": ["biologic activity of amylase"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[pk_us]", { type: "literal", value: "[pk_us]", description: "\"[pk_us]\"" }, function (u) {
      return { "value": 1, "units": { "[pk_us]": 1 }, "metadata": { "[pk_us]": { "isBase": false, "CODE": "[PK_US]", "isMetric": "no", "class": "us-volumes", "names": ["peck"], "properties": ["dry volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[APL'U]", { type: "literal", value: "[APL'U]", description: "\"[APL'U]\"" }, function (u) {
      return { "value": 1, "units": { "[APL'U]": 1 }, "metadata": { "[APL'U]": { "isBase": false, "CODE": "[APL'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["APL unit"], "properties": ["biologic activity of anticardiolipin IgA"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[bu_us]", { type: "literal", value: "[bu_us]", description: "\"[bu_us]\"" }, function (u) {
      return { "value": 1, "units": { "[bu_us]": 1 }, "metadata": { "[bu_us]": { "isBase": false, "CODE": "[BU_US]", "isMetric": "no", "class": "us-volumes", "names": ["bushel"], "properties": ["dry volume"], "values": [{ "printable": "2150.42", "numeric": 2150.42 }] } } };
    }, "[pt_br]", { type: "literal", value: "[pt_br]", description: "\"[pt_br]\"" }, function (u) {
      return { "value": 1, "units": { "[pt_br]": 1 }, "metadata": { "[pt_br]": { "isBase": false, "CODE": "[PT_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["pint"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[qt_br]", { type: "literal", value: "[qt_br]", description: "\"[qt_br]\"" }, function (u) {
      return { "value": 1, "units": { "[qt_br]": 1 }, "metadata": { "[qt_br]": { "isBase": false, "CODE": "[QT_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["quart"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[bu_br]", { type: "literal", value: "[bu_br]", description: "\"[bu_br]\"" }, function (u) {
      return { "value": 1, "units": { "[bu_br]": 1 }, "metadata": { "[bu_br]": { "isBase": false, "CODE": "[BU_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["bushel"], "properties": ["volume"], "values": [{ "printable": "4", "numeric": 4 }] } } };
    }, "[hp'_X]", { type: "literal", value: "[hp'_X]", description: "\"[hp'_X]\"" }, function (u) {
      return { "value": 1, "units": { "[hp'_X]": 1 }, "metadata": { "[hp'_X]": { "isBase": false, "CODE": "[HP'_X]", "isMetric": "no", "isSpecial": "yes", "class": "clinical", "names": ["homeopathic potency of decimal series (retired)"], "printSymbols": ["X"], "properties": ["homeopathic potency (retired)"], "values": [{ "printable": "<function name=\"hpX\" value=\"1\" Unit=\"1\"/>", "numeric": null }] } } };
    }, "[MPL'U]", { type: "literal", value: "[MPL'U]", description: "\"[MPL'U]\"" }, function (u) {
      return { "value": 1, "units": { "[MPL'U]": 1 }, "metadata": { "[MPL'U]": { "isBase": false, "CODE": "[MPL'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["MPL unit"], "properties": ["biologic activity of anticardiolipin IgM"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[GPL'U]", { type: "literal", value: "[GPL'U]", description: "\"[GPL'U]\"" }, function (u) {
      return { "value": 1, "units": { "[GPL'U]": 1 }, "metadata": { "[GPL'U]": { "isBase": false, "CODE": "[GPL'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["GPL unit"], "properties": ["biologic activity of anticardiolipin IgG"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[USP'U]", { type: "literal", value: "[USP'U]", description: "\"[USP'U]\"" }, function (u) {
      return { "value": 1, "units": { "[USP'U]": 1 }, "metadata": { "[USP'U]": { "isBase": false, "CODE": "[USP'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["United States Pharmacopeia unit"], "printSymbols": ["U.S.P."], "properties": ["arbitrary"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[eps_0]", { type: "literal", value: "[eps_0]", description: "\"[eps_0]\"" }, function (u) {
      return { "value": 1, "units": { "[eps_0]": 1 }, "metadata": { "[eps_0]": { "isBase": false, "CODE": "[EPS_0]", "isMetric": "yes", "class": "const", "names": ["permittivity of vacuum"], "printSymbols": ["<i>&#949;<sub>\n               <r>0</r>\n            </sub>\n         </i>"], "properties": ["electric permittivity"], "values": [{ "printable": "8.854187817 &#215; 10<sup>-12</sup>", "numeric": 8.854187817e-12 }] } } };
    }, "[fth_i]", { type: "literal", value: "[fth_i]", description: "\"[fth_i]\"" }, function (u) {
      return { "value": 1, "units": { "[fth_i]": 1 }, "metadata": { "[fth_i]": { "isBase": false, "CODE": "[FTH_I]", "isMetric": "no", "class": "intcust", "names": ["fathom"], "printSymbols": ["fth"], "properties": ["depth of water"], "values": [{ "printable": "6", "numeric": 6 }] } } };
    }, "[nmi_i]", { type: "literal", value: "[nmi_i]", description: "\"[nmi_i]\"" }, function (u) {
      return { "value": 1, "units": { "[nmi_i]": 1 }, "metadata": { "[nmi_i]": { "isBase": false, "CODE": "[NMI_I]", "isMetric": "no", "class": "intcust", "names": ["nautical mile"], "printSymbols": ["n.mi"], "properties": ["length"], "values": [{ "printable": "1852", "numeric": 1852 }] } } };
    }, "[pt_us]", { type: "literal", value: "[pt_us]", description: "\"[pt_us]\"" }, function (u) {
      return { "value": 1, "units": { "[pt_us]": 1 }, "metadata": { "[pt_us]": { "isBase": false, "CODE": "[PT_US]", "isMetric": "no", "class": "us-volumes", "names": ["pint"], "properties": ["fluid volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[sin_i]", { type: "literal", value: "[sin_i]", description: "\"[sin_i]\"" }, function (u) {
      return { "value": 1, "units": { "[sin_i]": 1 }, "metadata": { "[sin_i]": { "isBase": false, "CODE": "[SIN_I]", "isMetric": "no", "class": "intcust", "names": ["square inch"], "properties": ["area"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[sft_i]", { type: "literal", value: "[sft_i]", description: "\"[sft_i]\"" }, function (u) {
      return { "value": 1, "units": { "[sft_i]": 1 }, "metadata": { "[sft_i]": { "isBase": false, "CODE": "[SFT_I]", "isMetric": "no", "class": "intcust", "names": ["square foot"], "properties": ["area"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[syd_i]", { type: "literal", value: "[syd_i]", description: "\"[syd_i]\"" }, function (u) {
      return { "value": 1, "units": { "[syd_i]": 1 }, "metadata": { "[syd_i]": { "isBase": false, "CODE": "[SYD_I]", "isMetric": "no", "class": "intcust", "names": ["square yard"], "properties": ["area"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[cin_i]", { type: "literal", value: "[cin_i]", description: "\"[cin_i]\"" }, function (u) {
      return { "value": 1, "units": { "[cin_i]": 1 }, "metadata": { "[cin_i]": { "isBase": false, "CODE": "[CIN_I]", "isMetric": "no", "class": "intcust", "names": ["cubic inch"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[cft_i]", { type: "literal", value: "[cft_i]", description: "\"[cft_i]\"" }, function (u) {
      return { "value": 1, "units": { "[cft_i]": 1 }, "metadata": { "[cft_i]": { "isBase": false, "CODE": "[CFT_I]", "isMetric": "no", "class": "intcust", "names": ["cubic foot"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[cyd_i]", { type: "literal", value: "[cyd_i]", description: "\"[cyd_i]\"" }, function (u) {
      return { "value": 1, "units": { "[cyd_i]": 1 }, "metadata": { "[cyd_i]": { "isBase": false, "CODE": "[CYD_I]", "isMetric": "no", "class": "intcust", "names": ["cubic yard"], "printSymbols": ["cu.yd"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[qt_us]", { type: "literal", value: "[qt_us]", description: "\"[qt_us]\"" }, function (u) {
      return { "value": 1, "units": { "[qt_us]": 1 }, "metadata": { "[qt_us]": { "isBase": false, "CODE": "[QT_US]", "isMetric": "no", "class": "us-volumes", "names": ["quart"], "properties": ["fluid volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[arb'U]", { type: "literal", value: "[arb'U]", description: "\"[arb'U]\"" }, function (u) {
      return { "value": 1, "units": { "[arb'U]": 1 }, "metadata": { "[arb'U]": { "isBase": false, "CODE": "[ARB'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["arbitary unit"], "printSymbols": ["arb. U"], "properties": ["arbitrary"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[mil_i]", { type: "literal", value: "[mil_i]", description: "\"[mil_i]\"" }, function (u) {
      return { "value": 1, "units": { "[mil_i]": 1 }, "metadata": { "[mil_i]": { "isBase": false, "CODE": "[MIL_I]", "isMetric": "no", "class": "intcust", "names": ["mil"], "printSymbols": ["mil"], "properties": ["length"], "values": [{ "printable": "1 &#215; 10<sup>-3</sup>", "numeric": 0.001 }] } } };
    }, "[cml_i]", { type: "literal", value: "[cml_i]", description: "\"[cml_i]\"" }, function (u) {
      return { "value": 1, "units": { "[cml_i]": 1 }, "metadata": { "[cml_i]": { "isBase": false, "CODE": "[CML_I]", "isMetric": "no", "class": "intcust", "names": ["circular mil"], "printSymbols": ["circ.mil"], "properties": ["area"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[kn_br]", { type: "literal", value: "[kn_br]", description: "\"[kn_br]\"" }, function (u) {
      return { "value": 1, "units": { "[kn_br]": 1 }, "metadata": { "[kn_br]": { "isBase": false, "CODE": "[KN_BR]", "isMetric": "no", "class": "brit-length", "names": ["knot"], "properties": ["velocity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[ft_us]", { type: "literal", value: "[ft_us]", description: "\"[ft_us]\"" }, function (u) {
      return { "value": 1, "units": { "[ft_us]": 1 }, "metadata": { "[ft_us]": { "isBase": false, "CODE": "[FT_US]", "isMetric": "no", "class": "us-lengths", "names": ["foot"], "printSymbols": ["ft<sub>us</sub>"], "properties": ["length"], "values": [{ "printable": "1200", "numeric": 1200 }] } } };
    }, "[pouce]", { type: "literal", value: "[pouce]", description: "\"[pouce]\"" }, function (u) {
      return { "value": 1, "units": { "[pouce]": 1 }, "metadata": { "[pouce]": { "isBase": false, "CODE": "[POUCE]", "isMetric": "no", "class": "typeset", "names": ["pouce", "French inch"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[in_us]", { type: "literal", value: "[in_us]", description: "\"[in_us]\"" }, function (u) {
      return { "value": 1, "units": { "[in_us]": 1 }, "metadata": { "[in_us]": { "isBase": false, "CODE": "[IN_US]", "isMetric": "no", "class": "us-lengths", "names": ["inch"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[rd_us]", { type: "literal", value: "[rd_us]", description: "\"[rd_us]\"" }, function (u) {
      return { "value": 1, "units": { "[rd_us]": 1 }, "metadata": { "[rd_us]": { "isBase": false, "CODE": "[RD_US]", "isMetric": "no", "class": "us-lengths", "names": ["rod"], "properties": ["length"], "values": [{ "printable": "16.5", "numeric": 16.5 }] } } };
    }, "[ch_us]", { type: "literal", value: "[ch_us]", description: "\"[ch_us]\"" }, function (u) {
      return { "value": 1, "units": { "[ch_us]": 1 }, "metadata": { "[ch_us]": { "isBase": false, "CODE": "[CH_US]", "isMetric": "no", "class": "us-lengths", "names": ["Gunter's chain", "Surveyor's chain"], "properties": ["length"], "values": [{ "printable": "4", "numeric": 4 }] } } };
    }, "[lk_us]", { type: "literal", value: "[lk_us]", description: "\"[lk_us]\"" }, function (u) {
      return { "value": 1, "units": { "[lk_us]": 1 }, "metadata": { "[lk_us]": { "isBase": false, "CODE": "[LK_US]", "isMetric": "no", "class": "us-lengths", "names": ["link for Gunter's chain"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[hp'_C]", { type: "literal", value: "[hp'_C]", description: "\"[hp'_C]\"" }, function (u) {
      return { "value": 1, "units": { "[hp'_C]": 1 }, "metadata": { "[hp'_C]": { "isBase": false, "CODE": "[HP'_C]", "isMetric": "no", "isSpecial": "yes", "class": "clinical", "names": ["homeopathic potency of centesimal series (retired)"], "printSymbols": ["C"], "properties": ["homeopathic potency (retired)"], "values": [{ "printable": "<function name=\"hpC\" value=\"1\" Unit=\"1\"/>", "numeric": null }] } } };
    }, "[hp'_M]", { type: "literal", value: "[hp'_M]", description: "\"[hp'_M]\"" }, function (u) {
      return { "value": 1, "units": { "[hp'_M]": 1 }, "metadata": { "[hp'_M]": { "isBase": false, "CODE": "[HP'_M]", "isMetric": "no", "isSpecial": "yes", "class": "clinical", "names": ["homeopathic potency of millesimal series (retired)"], "printSymbols": ["M"], "properties": ["homeopathic potency (retired)"], "values": [{ "printable": "<function name=\"hpM\" value=\"1\" Unit=\"1\"/>", "numeric": null }] } } };
    }, "[hp'_Q]", { type: "literal", value: "[hp'_Q]", description: "\"[hp'_Q]\"" }, function (u) {
      return { "value": 1, "units": { "[hp'_Q]": 1 }, "metadata": { "[hp'_Q]": { "isBase": false, "CODE": "[HP'_Q]", "isMetric": "no", "isSpecial": "yes", "class": "clinical", "names": ["homeopathic potency of quintamillesimal series (retired)"], "printSymbols": ["Q"], "properties": ["homeopathic potency (retired)"], "values": [{ "printable": "<function name=\"hpQ\" value=\"1\" Unit=\"1\"/>", "numeric": null }] } } };
    }, "[mi_br]", { type: "literal", value: "[mi_br]", description: "\"[mi_br]\"" }, function (u) {
      return { "value": 1, "units": { "[mi_br]": 1 }, "metadata": { "[mi_br]": { "isBase": false, "CODE": "[MI_BR]", "isMetric": "no", "class": "brit-length", "names": ["mile"], "properties": ["length"], "values": [{ "printable": "5280", "numeric": 5280 }] } } };
    }, "[mi_us]", { type: "literal", value: "[mi_us]", description: "\"[mi_us]\"" }, function (u) {
      return { "value": 1, "units": { "[mi_us]": 1 }, "metadata": { "[mi_us]": { "isBase": false, "CODE": "[MI_US]", "isMetric": "no", "class": "us-lengths", "names": ["mile"], "properties": ["length"], "values": [{ "printable": "8", "numeric": 8 }] } } };
    }, "[yd_br]", { type: "literal", value: "[yd_br]", description: "\"[yd_br]\"" }, function (u) {
      return { "value": 1, "units": { "[yd_br]": 1 }, "metadata": { "[yd_br]": { "isBase": false, "CODE": "[YD_BR]", "isMetric": "no", "class": "brit-length", "names": ["yard"], "properties": ["length"], "values": [{ "printable": "3", "numeric": 3 }] } } };
    }, "[pk_br]", { type: "literal", value: "[pk_br]", description: "\"[pk_br]\"" }, function (u) {
      return { "value": 1, "units": { "[pk_br]": 1 }, "metadata": { "[pk_br]": { "isBase": false, "CODE": "[PK_BR]", "isMetric": "no", "class": "brit-volumes", "names": ["peck"], "properties": ["volume"], "values": [{ "printable": "2", "numeric": 2 }] } } };
    }, "[pc_br]", { type: "literal", value: "[pc_br]", description: "\"[pc_br]\"" }, function (u) {
      return { "value": 1, "units": { "[pc_br]": 1 }, "metadata": { "[pc_br]": { "isBase": false, "CODE": "[PC_BR]", "isMetric": "no", "class": "brit-length", "names": ["pace"], "properties": ["length"], "values": [{ "printable": "2.5", "numeric": 2.5 }] } } };
    }, "[lk_br]", { type: "literal", value: "[lk_br]", description: "\"[lk_br]\"" }, function (u) {
      return { "value": 1, "units": { "[lk_br]": 1 }, "metadata": { "[lk_br]": { "isBase": false, "CODE": "[LK_BR]", "isMetric": "no", "class": "brit-length", "names": ["link for Gunter's chain"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[in_br]", { type: "literal", value: "[in_br]", description: "\"[in_br]\"" }, function (u) {
      return { "value": 1, "units": { "[in_br]": 1 }, "metadata": { "[in_br]": { "isBase": false, "CODE": "[IN_BR]", "isMetric": "no", "class": "brit-length", "names": ["inch"], "properties": ["length"], "values": [{ "printable": "2.539998", "numeric": 2.539998 }] } } };
    }, "[ft_br]", { type: "literal", value: "[ft_br]", description: "\"[ft_br]\"" }, function (u) {
      return { "value": 1, "units": { "[ft_br]": 1 }, "metadata": { "[ft_br]": { "isBase": false, "CODE": "[FT_BR]", "isMetric": "no", "class": "brit-length", "names": ["foot"], "properties": ["length"], "values": [{ "printable": "12", "numeric": 12 }] } } };
    }, "[rd_br]", { type: "literal", value: "[rd_br]", description: "\"[rd_br]\"" }, function (u) {
      return { "value": 1, "units": { "[rd_br]": 1 }, "metadata": { "[rd_br]": { "isBase": false, "CODE": "[RD_BR]", "isMetric": "no", "class": "brit-length", "names": ["rod"], "properties": ["length"], "values": [{ "printable": "16.5", "numeric": 16.5 }] } } };
    }, "[ch_br]", { type: "literal", value: "[ch_br]", description: "\"[ch_br]\"" }, function (u) {
      return { "value": 1, "units": { "[ch_br]": 1 }, "metadata": { "[ch_br]": { "isBase": false, "CODE": "[CH_BR]", "isMetric": "no", "class": "brit-length", "names": ["Gunter's chain"], "properties": ["length"], "values": [{ "printable": "4", "numeric": 4 }] } } };
    }, "[ft_i]", { type: "literal", value: "[ft_i]", description: "\"[ft_i]\"" }, function (u) {
      return { "value": 1, "units": { "[ft_i]": 1 }, "metadata": { "[ft_i]": { "isBase": false, "CODE": "[FT_I]", "isMetric": "no", "class": "intcust", "names": ["foot"], "printSymbols": ["ft"], "properties": ["length"], "values": [{ "printable": "12", "numeric": 12 }] } } };
    }, "[hp_Q]", { type: "literal", value: "[hp_Q]", description: "\"[hp_Q]\"" }, function (u) {
      return { "value": 1, "units": { "[hp_Q]": 1 }, "metadata": { "[hp_Q]": { "isBase": false, "CODE": "[HP_Q]", "isMetric": "no", "isArbitrary": "yes", "class": "clinical", "names": ["homeopathic potency of quintamillesimal hahnemannian series"], "printSymbols": ["Q"], "properties": ["homeopathic potency (Hahnemann)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[hp_M]", { type: "literal", value: "[hp_M]", description: "\"[hp_M]\"" }, function (u) {
      return { "value": 1, "units": { "[hp_M]": 1 }, "metadata": { "[hp_M]": { "isBase": false, "CODE": "[HP_M]", "isMetric": "no", "isArbitrary": "yes", "class": "clinical", "names": ["homeopathic potency of millesimal hahnemannian series"], "printSymbols": ["M"], "properties": ["homeopathic potency (Hahnemann)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[hp_C]", { type: "literal", value: "[hp_C]", description: "\"[hp_C]\"" }, function (u) {
      return { "value": 1, "units": { "[hp_C]": 1 }, "metadata": { "[hp_C]": { "isBase": false, "CODE": "[HP_C]", "isMetric": "no", "isArbitrary": "yes", "class": "clinical", "names": ["homeopathic potency of centesimal hahnemannian series"], "printSymbols": ["C"], "properties": ["homeopathic potency (Hahnemann)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[hp_X]", { type: "literal", value: "[hp_X]", description: "\"[hp_X]\"" }, function (u) {
      return { "value": 1, "units": { "[hp_X]": 1 }, "metadata": { "[hp_X]": { "isBase": false, "CODE": "[HP_X]", "isMetric": "no", "isArbitrary": "yes", "class": "clinical", "names": ["homeopathic potency of decimal hahnemannian series"], "printSymbols": ["X"], "properties": ["homeopathic potency (Hahnemann)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[kp_C]", { type: "literal", value: "[kp_C]", description: "\"[kp_C]\"" }, function (u) {
      return { "value": 1, "units": { "[kp_C]": 1 }, "metadata": { "[kp_C]": { "isBase": false, "CODE": "[KP_C]", "isMetric": "no", "isArbitrary": "yes", "class": "clinical", "names": ["homeopathic potency of centesimal korsakovian series"], "printSymbols": ["C"], "properties": ["homeopathic potency (Korsakov)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[hd_i]", { type: "literal", value: "[hd_i]", description: "\"[hd_i]\"" }, function (u) {
      return { "value": 1, "units": { "[hd_i]": 1 }, "metadata": { "[hd_i]": { "isBase": false, "CODE": "[HD_I]", "isMetric": "no", "class": "intcust", "names": ["hand"], "printSymbols": ["hd"], "properties": ["height of horses"], "values": [{ "printable": "4", "numeric": 4 }] } } };
    }, "[kp_M]", { type: "literal", value: "[kp_M]", description: "\"[kp_M]\"" }, function (u) {
      return { "value": 1, "units": { "[kp_M]": 1 }, "metadata": { "[kp_M]": { "isBase": false, "CODE": "[KP_M]", "isMetric": "no", "isArbitrary": "yes", "class": "clinical", "names": ["homeopathic potency of millesimal korsakovian series"], "printSymbols": ["M"], "properties": ["homeopathic potency (Korsakov)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[kp_Q]", { type: "literal", value: "[kp_Q]", description: "\"[kp_Q]\"" }, function (u) {
      return { "value": 1, "units": { "[kp_Q]": 1 }, "metadata": { "[kp_Q]": { "isBase": false, "CODE": "[KP_Q]", "isMetric": "no", "isArbitrary": "yes", "class": "clinical", "names": ["homeopathic potency of quintamillesimal korsakovian series"], "printSymbols": ["Q"], "properties": ["homeopathic potency (Korsakov)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[cr_i]", { type: "literal", value: "[cr_i]", description: "\"[cr_i]\"" }, function (u) {
      return { "value": 1, "units": { "[cr_i]": 1 }, "metadata": { "[cr_i]": { "isBase": false, "CODE": "[CR_I]", "isMetric": "no", "class": "intcust", "names": ["cord"], "properties": ["volume"], "values": [{ "printable": "128", "numeric": 128 }] } } };
    }, "[bf_i]", { type: "literal", value: "[bf_i]", description: "\"[bf_i]\"" }, function (u) {
      return { "value": 1, "units": { "[bf_i]": 1 }, "metadata": { "[bf_i]": { "isBase": false, "CODE": "[BF_I]", "isMetric": "no", "class": "intcust", "names": ["board foot"], "properties": ["volume"], "values": [{ "printable": "144", "numeric": 144 }] } } };
    }, "[kn_i]", { type: "literal", value: "[kn_i]", description: "\"[kn_i]\"" }, function (u) {
      return { "value": 1, "units": { "[kn_i]": 1 }, "metadata": { "[kn_i]": { "isBase": false, "CODE": "[KN_I]", "isMetric": "no", "class": "intcust", "names": ["knot"], "printSymbols": ["knot"], "properties": ["velocity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[mu_0]", { type: "literal", value: "[mu_0]", description: "\"[mu_0]\"" }, function (u) {
      return { "value": 1, "units": { "[mu_0]": 1 }, "metadata": { "[mu_0]": { "isBase": false, "CODE": "[MU_0]", "isMetric": "yes", "class": "const", "names": ["permeability of vacuum"], "printSymbols": ["<i>&#956;<sub>\n               <r>0</r>\n            </sub>\n         </i>"], "properties": ["magnetic permeability"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[mi_i]", { type: "literal", value: "[mi_i]", description: "\"[mi_i]\"" }, function (u) {
      return { "value": 1, "units": { "[mi_i]": 1 }, "metadata": { "[mi_i]": { "isBase": false, "CODE": "[MI_I]", "isMetric": "no", "class": "intcust", "names": ["statute mile"], "printSymbols": ["mi"], "properties": ["length"], "values": [{ "printable": "5280", "numeric": 5280 }] } } };
    }, "[yd_i]", { type: "literal", value: "[yd_i]", description: "\"[yd_i]\"" }, function (u) {
      return { "value": 1, "units": { "[yd_i]": 1 }, "metadata": { "[yd_i]": { "isBase": false, "CODE": "[YD_I]", "isMetric": "no", "class": "intcust", "names": ["yard"], "printSymbols": ["yd"], "properties": ["length"], "values": [{ "printable": "3", "numeric": 3 }] } } };
    }, "[kp_X]", { type: "literal", value: "[kp_X]", description: "\"[kp_X]\"" }, function (u) {
      return { "value": 1, "units": { "[kp_X]": 1 }, "metadata": { "[kp_X]": { "isBase": false, "CODE": "[KP_X]", "isMetric": "no", "isArbitrary": "yes", "class": "clinical", "names": ["homeopathic potency of decimal korsakovian series"], "printSymbols": ["X"], "properties": ["homeopathic potency (Korsakov)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[in_i]", { type: "literal", value: "[in_i]", description: "\"[in_i]\"" }, function (u) {
      return { "value": 1, "units": { "[in_i]": 1 }, "metadata": { "[in_i]": { "isBase": false, "CODE": "[IN_I]", "isMetric": "no", "class": "intcust", "names": ["inch"], "printSymbols": ["in"], "properties": ["length"], "values": [{ "printable": "2.54", "numeric": 2.54 }] } } };
    }, "[diop]", { type: "literal", value: "[diop]", description: "\"[diop]\"" }, function (u) {
      return { "value": 1, "units": { "[diop]": 1 }, "metadata": { "[diop]": { "isBase": false, "CODE": "[DIOP]", "isMetric": "no", "class": "clinical", "names": ["diopter"], "printSymbols": ["dpt"], "properties": ["refraction of a lens"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "cal_IT", { type: "literal", value: "cal_IT", description: "\"cal_IT\"" }, function (u) {
      return { "value": 1, "units": { "cal_IT": 1 }, "metadata": { "cal_IT": { "isBase": false, "CODE": "CAL_IT", "isMetric": "yes", "class": "heat", "names": ["international table calorie"], "printSymbols": ["cal<sub>IT</sub>"], "properties": ["energy"], "values": [{ "printable": "4.1868", "numeric": 4.1868 }] } } };
    }, "cal_th", { type: "literal", value: "cal_th", description: "\"cal_th\"" }, function (u) {
      return { "value": 1, "units": { "cal_th": 1 }, "metadata": { "cal_th": { "isBase": false, "CODE": "CAL_TH", "isMetric": "yes", "class": "heat", "names": ["thermochemical calorie"], "printSymbols": ["cal<sub>th</sub>"], "properties": ["energy"], "values": [{ "printable": "4.184", "numeric": 4.184 }] } } };
    }, "m[H2O]", { type: "literal", value: "m[H2O]", description: "\"m[H2O]\"" }, function (u) {
      return { "value": 1, "units": { "m[H2O]": 1 }, "metadata": { "m[H2O]": { "isBase": false, "CODE": "M[H2O]", "isMetric": "yes", "class": "clinical", "names": ["meter of water column"], "printSymbols": ["m&#160;H<sub>\n            <r>2</r>\n         </sub>O"], "properties": ["pressure"], "values": [{ "printable": "9.80665", "numeric": 9.80665 }] } } };
    }, "[ka'U]", { type: "literal", value: "[ka'U]", description: "\"[ka'U]\"" }, function (u) {
      return { "value": 1, "units": { "[ka'U]": 1 }, "metadata": { "[ka'U]": { "isBase": false, "CODE": "[KA'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["King-Armstrong unit"], "properties": ["biologic activity of phosphatase"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "B[SPL]", { type: "literal", value: "B[SPL]", description: "\"B[SPL]\"" }, function (u) {
      return { "value": 1, "units": { "B[SPL]": 1 }, "metadata": { "B[SPL]": { "isBase": false, "CODE": "B[SPL]", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["bel sound pressure"], "printSymbols": ["B(SPL)"], "properties": ["pressure level"], "values": [{ "printable": "<function name=\"lgTimes2\" value=\"2\" Unit=\"10*-5.Pa\"/>", "numeric": null }] } } };
    }, "[tb'U]", { type: "literal", value: "[tb'U]", description: "\"[tb'U]\"" }, function (u) {
      return { "value": 1, "units": { "[tb'U]": 1 }, "metadata": { "[tb'U]": { "isBase": false, "CODE": "[TB'U]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["tuberculin unit"], "properties": ["biologic activity of tuberculin"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[degR]", { type: "literal", value: "[degR]", description: "\"[degR]\"" }, function (u) {
      return { "value": 1, "units": { "[degR]": 1 }, "metadata": { "[degR]": { "isBase": false, "CODE": "[degR]", "isMetric": "no", "class": "heat", "names": ["degree Rankine"], "printSymbols": ["&#176;R"], "properties": ["temperature"], "values": [{ "printable": "5", "numeric": 5 }] } } };
    }, "[degF]", { type: "literal", value: "[degF]", description: "\"[degF]\"" }, function (u) {
      return { "value": 1, "units": { "[degF]": 1 }, "metadata": { "[degF]": { "isBase": false, "CODE": "[DEGF]", "isMetric": "no", "isSpecial": "yes", "class": "heat", "names": ["degree Fahrenheit"], "printSymbols": ["&#176;F"], "properties": ["temperature"], "values": [{ "printable": "<function name=\"degF\" value=\"5\" Unit=\"K/9\"/>", "numeric": null }] } } };
    }, "[pptr]", { type: "literal", value: "[pptr]", description: "\"[pptr]\"" }, function (u) {
      return { "value": 1, "units": { "[pptr]": 1 }, "metadata": { "[pptr]": { "isBase": false, "CODE": "[PPTR]", "isMetric": "no", "class": "dimless", "names": ["parts per trillion"], "printSymbols": ["pptr"], "properties": ["fraction"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[ppth]", { type: "literal", value: "[ppth]", description: "\"[ppth]\"" }, function (u) {
      return { "value": 1, "units": { "[ppth]": 1 }, "metadata": { "[ppth]": { "isBase": false, "CODE": "[PPTH]", "isMetric": "no", "class": "dimless", "names": ["parts per thousand"], "printSymbols": ["ppth"], "properties": ["fraction"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[oz_m]", { type: "literal", value: "[oz_m]", description: "\"[oz_m]\"" }, function (u) {
      return { "value": 1, "units": { "[oz_m]": 1 }, "metadata": { "[oz_m]": { "isBase": false, "CODE": "[OZ_M]", "isMetric": "no", "class": "apoth", "names": ["metric ounce"], "properties": ["mass"], "values": [{ "printable": "28", "numeric": 28 }] } } };
    }, "[pied]", { type: "literal", value: "[pied]", description: "\"[pied]\"" }, function (u) {
      return { "value": 1, "units": { "[pied]": 1 }, "metadata": { "[pied]": { "isBase": false, "CODE": "[PIED]", "isMetric": "no", "class": "typeset", "names": ["pied", "French foot"], "properties": ["length"], "values": [{ "printable": "32.48", "numeric": 32.48 }] } } };
    }, "[ppm]", { type: "literal", value: "[ppm]", description: "\"[ppm]\"" }, function (u) {
      return { "value": 1, "units": { "[ppm]": 1 }, "metadata": { "[ppm]": { "isBase": false, "CODE": "[PPM]", "isMetric": "no", "class": "dimless", "names": ["parts per million"], "printSymbols": ["ppm"], "properties": ["fraction"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[ppb]", { type: "literal", value: "[ppb]", description: "\"[ppb]\"" }, function (u) {
      return { "value": 1, "units": { "[ppb]": 1 }, "metadata": { "[ppb]": { "isBase": false, "CODE": "[PPB]", "isMetric": "no", "class": "dimless", "names": ["parts per billion"], "printSymbols": ["ppb"], "properties": ["fraction"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "bit_s", { type: "literal", value: "bit_s", description: "\"bit_s\"" }, function (u) {
      return { "value": 1, "units": { "bit_s": 1 }, "metadata": { "bit_s": { "isBase": false, "CODE": "BIT_S", "isMetric": "no", "isSpecial": "yes", "class": "infotech", "names": ["bit"], "printSymbols": ["bit<sub>s</sub>"], "properties": ["amount of information"], "values": [{ "printable": "<function name=\"ld\" value=\"1\" Unit=\"1\"/>", "numeric": null }] } } };
    }, "[PNU]", { type: "literal", value: "[PNU]", description: "\"[PNU]\"" }, function (u) {
      return { "value": 1, "units": { "[PNU]": 1 }, "metadata": { "[PNU]": { "isBase": false, "CODE": "[PNU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["protein nitrogen unit"], "printSymbols": ["PNU"], "properties": ["procedure defined amount of a protein substance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[psi]", { type: "literal", value: "[psi]", description: "\"[psi]\"" }, function (u) {
      return { "value": 1, "units": { "[psi]": 1 }, "metadata": { "[psi]": { "isBase": false, "CODE": "[PSI]", "isMetric": "no", "class": "misc", "names": ["pound per sqare inch"], "printSymbols": ["psi"], "properties": ["pressure"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[BAU]", { type: "literal", value: "[BAU]", description: "\"[BAU]\"" }, function (u) {
      return { "value": 1, "units": { "[BAU]": 1 }, "metadata": { "[BAU]": { "isBase": false, "CODE": "[BAU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["bioequivalent allergen unit"], "printSymbols": ["BAU"], "properties": ["amount of an allergen callibrated through in-vivo testing based on the ID50EAL method of (intradermal dilution for 50mm sum of erythema diameters"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[Cal]", { type: "literal", value: "[Cal]", description: "\"[Cal]\"" }, function (u) {
      return { "value": 1, "units": { "[Cal]": 1 }, "metadata": { "[Cal]": { "isBase": false, "CODE": "[CAL]", "isMetric": "no", "class": "heat", "names": ["nutrition label Calories"], "printSymbols": ["Cal"], "properties": ["energy"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "B[mV]", { type: "literal", value: "B[mV]", description: "\"B[mV]\"" }, function (u) {
      return { "value": 1, "units": { "B[mV]": 1 }, "metadata": { "B[mV]": { "isBase": false, "CODE": "B[MV]", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["bel millivolt"], "printSymbols": ["B(mV)"], "properties": ["electric potential level"], "values": [{ "printable": "<function name=\"lgTimes2\" value=\"1\" Unit=\"mV\"/>", "numeric": null }] } } };
    }, "B[uV]", { type: "literal", value: "B[uV]", description: "\"B[uV]\"" }, function (u) {
      return { "value": 1, "units": { "B[uV]": 1 }, "metadata": { "B[uV]": { "isBase": false, "CODE": "B[UV]", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["bel microvolt"], "printSymbols": ["B(&#956;V)"], "properties": ["electric potential level"], "values": [{ "printable": "<function name=\"lgTimes2\" value=\"1\" Unit=\"uV\"/>", "numeric": null }] } } };
    }, "[CFU]", { type: "literal", value: "[CFU]", description: "\"[CFU]\"" }, function (u) {
      return { "value": 1, "units": { "[CFU]": 1 }, "metadata": { "[CFU]": { "isBase": false, "CODE": "[CFU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["colony forming units"], "printSymbols": ["CFU"], "properties": ["amount of a proliferating organism"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[FFU]", { type: "literal", value: "[FFU]", description: "\"[FFU]\"" }, function (u) {
      return { "value": 1, "units": { "[FFU]": 1 }, "metadata": { "[FFU]": { "isBase": false, "CODE": "[FFU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["focus forming units"], "printSymbols": ["FFU"], "properties": ["amount of an infectious agent"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "B[kW]", { type: "literal", value: "B[kW]", description: "\"B[kW]\"" }, function (u) {
      return { "value": 1, "units": { "B[kW]": 1 }, "metadata": { "B[kW]": { "isBase": false, "CODE": "B[KW]", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["bel kilowatt"], "printSymbols": ["B(kW)"], "properties": ["power level"], "values": [{ "printable": "<function name=\"lg\" value=\"1\" Unit=\"kW\"/>", "numeric": null }] } } };
    }, "[PFU]", { type: "literal", value: "[PFU]", description: "\"[PFU]\"" }, function (u) {
      return { "value": 1, "units": { "[PFU]": 1 }, "metadata": { "[PFU]": { "isBase": false, "CODE": "[PFU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["plaque forming units"], "printSymbols": ["PFU"], "properties": ["amount of an infectious agent"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "cal_m", { type: "literal", value: "cal_m", description: "\"cal_m\"" }, function (u) {
      return { "value": 1, "units": { "cal_m": 1 }, "metadata": { "cal_m": { "isBase": false, "CODE": "CAL_M", "isMetric": "yes", "class": "heat", "names": ["mean calorie"], "printSymbols": ["cal<sub>m</sub>"], "properties": ["energy"], "values": [{ "printable": "4.19002", "numeric": 4.19002 }] } } };
    }, "[ELU]", { type: "literal", value: "[ELU]", description: "\"[ELU]\"" }, function (u) {
      return { "value": 1, "units": { "[ELU]": 1 }, "metadata": { "[ELU]": { "isBase": false, "CODE": "[ELU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["ELISA unit"], "printSymbols": [""], "properties": ["arbitrary ELISA unit"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[FEU]", { type: "literal", value: "[FEU]", description: "\"[FEU]\"" }, function (u) {
      return { "value": 1, "units": { "[FEU]": 1 }, "metadata": { "[FEU]": { "isBase": false, "CODE": "[FEU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["fibrinogen equivalent unit"], "printSymbols": [""], "properties": ["amount of fibrinogen broken down into the measured d-dimers"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[PRU]", { type: "literal", value: "[PRU]", description: "\"[PRU]\"" }, function (u) {
      return { "value": 1, "units": { "[PRU]": 1 }, "metadata": { "[PRU]": { "isBase": false, "CODE": "[PRU]", "isMetric": "no", "class": "clinical", "names": ["peripheral vascular resistance unit"], "printSymbols": ["P.R.U."], "properties": ["fluid resistance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[m_e]", { type: "literal", value: "[m_e]", description: "\"[m_e]\"" }, function (u) {
      return { "value": 1, "units": { "[m_e]": 1 }, "metadata": { "[m_e]": { "isBase": false, "CODE": "[M_E]", "isMetric": "yes", "class": "const", "names": ["electron mass"], "printSymbols": ["<i>m<sub>\n               <r>e</r>\n            </sub>\n         </i>"], "properties": ["mass"], "values": [{ "printable": "9.1093897 &#215; 10<sup>-28</sup>", "numeric": 9.1093897e-28 }] } } };
    }, "[m_p]", { type: "literal", value: "[m_p]", description: "\"[m_p]\"" }, function (u) {
      return { "value": 1, "units": { "[m_p]": 1 }, "metadata": { "[m_p]": { "isBase": false, "CODE": "[M_P]", "isMetric": "yes", "class": "const", "names": ["proton mass"], "printSymbols": ["<i>m<sub>\n               <r>p</r>\n            </sub>\n         </i>"], "properties": ["mass"], "values": [{ "printable": "1.6726231 &#215; 10<sup>-24</sup>", "numeric": 1.6726231e-24 }] } } };
    }, "m[Hg]", { type: "literal", value: "m[Hg]", description: "\"m[Hg]\"" }, function (u) {
      return { "value": 1, "units": { "m[Hg]": 1 }, "metadata": { "m[Hg]": { "isBase": false, "CODE": "M[HG]", "isMetric": "yes", "class": "clinical", "names": ["meter of mercury column"], "printSymbols": ["m&#160;Hg"], "properties": ["pressure"], "values": [{ "printable": "133.3220", "numeric": 133.322 }] } } };
    }, "[pca]", { type: "literal", value: "[pca]", description: "\"[pca]\"" }, function (u) {
      return { "value": 1, "units": { "[pca]": 1 }, "metadata": { "[pca]": { "isBase": false, "CODE": "[PCA]", "isMetric": "no", "class": "typeset", "names": ["pica"], "properties": ["length"], "values": [{ "printable": "12", "numeric": 12 }] } } };
    }, "[pnt]", { type: "literal", value: "[pnt]", description: "\"[pnt]\"" }, function (u) {
      return { "value": 1, "units": { "[pnt]": 1 }, "metadata": { "[pnt]": { "isBase": false, "CODE": "[PNT]", "isMetric": "no", "class": "typeset", "names": ["point"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[lne]", { type: "literal", value: "[lne]", description: "\"[lne]\"" }, function (u) {
      return { "value": 1, "units": { "[lne]": 1 }, "metadata": { "[lne]": { "isBase": false, "CODE": "[LNE]", "isMetric": "no", "class": "typeset", "names": ["line"], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[LPF]", { type: "literal", value: "[LPF]", description: "\"[LPF]\"" }, function (u) {
      return { "value": 1, "units": { "[LPF]": 1 }, "metadata": { "[LPF]": { "isBase": false, "CODE": "[LPF]", "isMetric": "no", "class": "chemical", "names": ["low power field"], "printSymbols": ["LPF"], "properties": ["view area in microscope"], "values": [{ "printable": "100", "numeric": 100 }] } } };
    }, "[den]", { type: "literal", value: "[den]", description: "\"[den]\"" }, function (u) {
      return { "value": 1, "units": { "[den]": 1 }, "metadata": { "[den]": { "isBase": false, "CODE": "[DEN]", "isMetric": "no", "class": "heat", "names": ["Denier"], "printSymbols": ["den"], "properties": ["linear mass density (of textile thread)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[sct]", { type: "literal", value: "[sct]", description: "\"[sct]\"" }, function (u) {
      return { "value": 1, "units": { "[sct]": 1 }, "metadata": { "[sct]": { "isBase": false, "CODE": "[SCT]", "isMetric": "no", "class": "us-lengths", "names": ["section"], "properties": ["area"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[twp]", { type: "literal", value: "[twp]", description: "\"[twp]\"" }, function (u) {
      return { "value": 1, "units": { "[twp]": 1 }, "metadata": { "[twp]": { "isBase": false, "CODE": "[TWP]", "isMetric": "no", "class": "us-lengths", "names": ["township"], "properties": ["area"], "values": [{ "printable": "36", "numeric": 36 }] } } };
    }, "[Btu]", { type: "literal", value: "[Btu]", description: "\"[Btu]\"" }, function (u) {
      return { "value": 1, "units": { "[Btu]": 1 }, "metadata": { "[Btu]": { "isBase": false, "CODE": "[BTU]", "isMetric": "no", "class": "heat", "names": ["British thermal unit"], "printSymbols": ["btu"], "properties": ["energy"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[MET]", { type: "literal", value: "[MET]", description: "\"[MET]\"" }, function (u) {
      return { "value": 1, "units": { "[MET]": 1 }, "metadata": { "[MET]": { "isBase": false, "CODE": "[MET]", "isMetric": "no", "class": "clinical", "names": ["metabolic equivalent"], "printSymbols": ["MET"], "properties": ["metabolic cost of physical activity"], "values": [{ "printable": "3.5", "numeric": 3.5 }] } } };
    }, "[HPF]", { type: "literal", value: "[HPF]", description: "\"[HPF]\"" }, function (u) {
      return { "value": 1, "units": { "[HPF]": 1 }, "metadata": { "[HPF]": { "isBase": false, "CODE": "[HPF]", "isMetric": "no", "class": "chemical", "names": ["high power field"], "printSymbols": ["HPF"], "properties": ["view area in microscope"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[drp]", { type: "literal", value: "[drp]", description: "\"[drp]\"" }, function (u) {
      return { "value": 1, "units": { "[drp]": 1 }, "metadata": { "[drp]": { "isBase": false, "CODE": "[DRP]", "isMetric": "no", "class": "clinical", "names": ["drop"], "printSymbols": ["drp"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[AU]", { type: "literal", value: "[AU]", description: "\"[AU]\"" }, function (u) {
      return { "value": 1, "units": { "[AU]": 1 }, "metadata": { "[AU]": { "isBase": false, "CODE": "[AU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["allergen unit"], "printSymbols": ["AU"], "properties": ["procedure defined amount of an allergen using some reference standard"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[IU]", { type: "literal", value: "[IU]", description: "\"[IU]\"" }, function (u) {
      return { "value": 1, "units": { "[IU]": 1 }, "metadata": { "[IU]": { "isBase": false, "CODE": "[IU]", "isMetric": "yes", "isArbitrary": "yes", "class": "chemical", "names": ["international unit"], "printSymbols": ["i.U."], "properties": ["arbitrary"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "mo_s", { type: "literal", value: "mo_s", description: "\"mo_s\"" }, function (u) {
      return { "value": 1, "units": { "mo_s": 1 }, "metadata": { "mo_s": { "isBase": false, "CODE": "MO_S", "isMetric": "no", "class": "iso1000", "names": ["synodal month"], "printSymbols": ["mo<sub>s</sub>"], "properties": ["time"], "values": [{ "printable": "29.53059", "numeric": 29.53059 }] } } };
    }, "[gr]", { type: "literal", value: "[gr]", description: "\"[gr]\"" }, function (u) {
      return { "value": 1, "units": { "[gr]": 1 }, "metadata": { "[gr]": { "isBase": false, "CODE": "[GR]", "isMetric": "no", "class": "avoirdupois", "names": ["grain"], "properties": ["mass"], "values": [{ "printable": "64.79891", "numeric": 64.79891 }] } } };
    }, "circ", { type: "literal", value: "circ", description: "\"circ\"" }, function (u) {
      return { "value": 1, "units": { "circ": 1 }, "metadata": { "circ": { "isBase": false, "CODE": "CIRC", "isMetric": "no", "class": "misc", "names": ["circle"], "printSymbols": ["circ"], "properties": ["plane angle"], "values": [{ "printable": "2", "numeric": 2 }] } } };
    }, "[pi]", { type: "literal", value: "[pi]", description: "\"[pi]\"" }, function (u) {
      return { "value": 1, "units": { "[pi]": 1 }, "metadata": { "[pi]": { "isBase": false, "CODE": "[PI]", "isMetric": "no", "class": "dimless", "names": ["the number pi"], "printSymbols": ["&#960;"], "properties": ["number"], "values": [{ "printable": "&#960;", "numeric": 3.141592653589793 }] } } };
    }, "[EU]", { type: "literal", value: "[EU]", description: "\"[EU]\"" }, function (u) {
      return { "value": 1, "units": { "[EU]": 1 }, "metadata": { "[EU]": { "isBase": false, "CODE": "[EU]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Ehrlich unit"], "printSymbols": [""], "properties": ["Ehrlich unit"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[Lf]", { type: "literal", value: "[Lf]", description: "\"[Lf]\"" }, function (u) {
      return { "value": 1, "units": { "[Lf]": 1 }, "metadata": { "[Lf]": { "isBase": false, "CODE": "[LF]", "isMetric": "no", "isArbitrary": "yes", "class": "chemical", "names": ["Limit of flocculation"], "printSymbols": ["Lf"], "properties": ["procedure defined amount of an antigen substance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "mo_j", { type: "literal", value: "mo_j", description: "\"mo_j\"" }, function (u) {
      return { "value": 1, "units": { "mo_j": 1 }, "metadata": { "mo_j": { "isBase": false, "CODE": "MO_J", "isMetric": "no", "class": "iso1000", "names": ["mean Julian month"], "printSymbols": ["mo<sub>j</sub>"], "properties": ["time"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "B[W]", { type: "literal", value: "B[W]", description: "\"B[W]\"" }, function (u) {
      return { "value": 1, "units": { "B[W]": 1 }, "metadata": { "B[W]": { "isBase": false, "CODE": "B[W]", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["bel watt"], "printSymbols": ["B(W)"], "properties": ["power level"], "values": [{ "printable": "<function name=\"lg\" value=\"1\" Unit=\"W\"/>", "numeric": null }] } } };
    }, "B[V]", { type: "literal", value: "B[V]", description: "\"B[V]\"" }, function (u) {
      return { "value": 1, "units": { "B[V]": 1 }, "metadata": { "B[V]": { "isBase": false, "CODE": "B[V]", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["bel volt"], "printSymbols": ["B(V)"], "properties": ["electric potential level"], "values": [{ "printable": "<function name=\"lgTimes2\" value=\"1\" Unit=\"V\"/>", "numeric": null }] } } };
    }, "mo_g", { type: "literal", value: "mo_g", description: "\"mo_g\"" }, function (u) {
      return { "value": 1, "units": { "mo_g": 1 }, "metadata": { "mo_g": { "isBase": false, "CODE": "MO_G", "isMetric": "no", "class": "iso1000", "names": ["mean Gregorian month"], "printSymbols": ["mo<sub>g</sub>"], "properties": ["time"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[iU]", { type: "literal", value: "[iU]", description: "\"[iU]\"" }, function (u) {
      return { "value": 1, "units": { "[iU]": 1 }, "metadata": { "[iU]": { "isBase": false, "CODE": "[IU]", "isMetric": "yes", "isArbitrary": "yes", "class": "chemical", "names": ["international unit"], "printSymbols": ["IU"], "properties": ["arbitrary"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[HP]", { type: "literal", value: "[HP]", description: "\"[HP]\"" }, function (u) {
      return { "value": 1, "units": { "[HP]": 1 }, "metadata": { "[HP]": { "isBase": false, "CODE": "[HP]", "isMetric": "no", "class": "heat", "names": ["horsepower"], "properties": ["power"], "values": [{ "printable": "550", "numeric": 550 }] } } };
    }, "[Ch]", { type: "literal", value: "[Ch]", description: "\"[Ch]\"" }, function (u) {
      return { "value": 1, "units": { "[Ch]": 1 }, "metadata": { "[Ch]": { "isBase": false, "CODE": "[CH]", "isMetric": "no", "class": "clinical", "names": ["Charrière", "french"], "printSymbols": ["Ch"], "properties": ["gauge of catheters"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[ly]", { type: "literal", value: "[ly]", description: "\"[ly]\"" }, function (u) {
      return { "value": 1, "units": { "[ly]": 1 }, "metadata": { "[ly]": { "isBase": false, "CODE": "[LY]", "isMetric": "yes", "class": "const", "names": ["light-year"], "printSymbols": ["l.y."], "properties": ["length"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[pH]", { type: "literal", value: "[pH]", description: "\"[pH]\"" }, function (u) {
      return { "value": 1, "units": { "[pH]": 1 }, "metadata": { "[pH]": { "isBase": false, "CODE": "[PH]", "isMetric": "no", "isSpecial": "yes", "class": "chemical", "names": ["pH"], "printSymbols": ["pH"], "properties": ["acidity"], "values": [{ "printable": "<function name=\"pH\" value=\"1\" Unit=\"mol/l\"/>", "numeric": null }] } } };
    }, "a_j", { type: "literal", value: "a_j", description: "\"a_j\"" }, function (u) {
      return { "value": 1, "units": { "a_j": 1 }, "metadata": { "a_j": { "isBase": false, "CODE": "ANN_J", "isMetric": "no", "class": "iso1000", "names": ["mean Julian year"], "printSymbols": ["a<sub>j</sub>"], "properties": ["time"], "values": [{ "printable": "365.25", "numeric": 365.25 }] } } };
    }, "rad", { type: "literal", value: "rad", description: "\"rad\"" }, function (u) {
      return { "value": 1, "units": { "rad": 1 }, "metadata": { "rad": { "isBase": true, "CODE": "RAD", "dim": "A", "names": ["radian"], "printSymbols": ["rad"], "properties": ["plane angle"] } } };
    }, "a_t", { type: "literal", value: "a_t", description: "\"a_t\"" }, function (u) {
      return { "value": 1, "units": { "a_t": 1 }, "metadata": { "a_t": { "isBase": false, "CODE": "ANN_T", "isMetric": "no", "class": "iso1000", "names": ["tropical year"], "printSymbols": ["a<sub>t</sub>"], "properties": ["time"], "values": [{ "printable": "365.24219", "numeric": 365.24219 }] } } };
    }, "Ohm", { type: "literal", value: "Ohm", description: "\"Ohm\"" }, function (u) {
      return { "value": 1, "units": { "Ohm": 1 }, "metadata": { "Ohm": { "isBase": false, "CODE": "OHM", "isMetric": "yes", "class": "si", "names": ["Ohm"], "printSymbols": ["&#937;"], "properties": ["electric resistance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "sph", { type: "literal", value: "sph", description: "\"sph\"" }, function (u) {
      return { "value": 1, "units": { "sph": 1 }, "metadata": { "sph": { "isBase": false, "CODE": "SPH", "isMetric": "no", "class": "misc", "names": ["spere"], "printSymbols": ["sph"], "properties": ["solid angle"], "values": [{ "printable": "4", "numeric": 4 }] } } };
    }, "bit", { type: "literal", value: "bit", description: "\"bit\"" }, function (u) {
      return { "value": 1, "units": { "bit": 1 }, "metadata": { "bit": { "isBase": false, "CODE": "BIT", "isMetric": "yes", "class": "infotech", "names": ["bit"], "printSymbols": ["bit"], "properties": ["amount of information"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "mho", { type: "literal", value: "mho", description: "\"mho\"" }, function (u) {
      return { "value": 1, "units": { "mho": 1 }, "metadata": { "mho": { "isBase": false, "CODE": "MHO", "isMetric": "yes", "class": "misc", "names": ["mho"], "printSymbols": ["mho"], "properties": ["electric conductance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "min", { type: "literal", value: "min", description: "\"min\"" }, function (u) {
      return { "value": 1, "units": { "min": 1 }, "metadata": { "min": { "isBase": false, "CODE": "MIN", "isMetric": "no", "class": "iso1000", "names": ["minute"], "printSymbols": ["min"], "properties": ["time"], "values": [{ "printable": "60", "numeric": 60 }] } } };
    }, "mol", { type: "literal", value: "mol", description: "\"mol\"" }, function (u) {
      return { "value": 1, "units": { "mol": 1 }, "metadata": { "mol": { "isBase": false, "CODE": "MOL", "isMetric": "yes", "class": "si", "names": ["mole"], "printSymbols": ["mol"], "properties": ["amount of substance"], "values": [{ "printable": "6.0221367", "numeric": 6.0221367 }] } } };
    }, "deg", { type: "literal", value: "deg", description: "\"deg\"" }, function (u) {
      return { "value": 1, "units": { "deg": 1 }, "metadata": { "deg": { "isBase": false, "CODE": "DEG", "isMetric": "no", "class": "iso1000", "names": ["degree"], "printSymbols": ["&#176;"], "properties": ["plane angle"], "values": [{ "printable": "2", "numeric": 2 }] } } };
    }, "gon", { type: "literal", value: "gon", description: "\"gon\"" }, function (u) {
      return { "value": 1, "units": { "gon": 1 }, "metadata": { "gon": { "isBase": false, "CODE": "GON", "isMetric": "no", "class": "iso1000", "names": ["gon", "grade"], "printSymbols": ["&#9633;<sup>g</sup>"], "properties": ["plane angle"], "values": [{ "printable": "0.9", "numeric": 0.9 }] } } };
    }, "Cel", { type: "literal", value: "Cel", description: "\"Cel\"" }, function (u) {
      return { "value": 1, "units": { "Cel": 1 }, "metadata": { "Cel": { "isBase": false, "CODE": "CEL", "isMetric": "yes", "isSpecial": "yes", "class": "si", "names": ["degree Celsius"], "printSymbols": ["&#176;C"], "properties": ["temperature"], "values": [{ "printable": "<function name=\"Cel\" value=\"1\" Unit=\"K\"/>", "numeric": null }] } } };
    }, "kat", { type: "literal", value: "kat", description: "\"kat\"" }, function (u) {
      return { "value": 1, "units": { "kat": 1 }, "metadata": { "kat": { "isBase": false, "CODE": "KAT", "isMetric": "yes", "class": "chemical", "names": ["katal"], "printSymbols": ["kat"], "properties": ["catalytic activity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "att", { type: "literal", value: "att", description: "\"att\"" }, function (u) {
      return { "value": 1, "units": { "att": 1 }, "metadata": { "att": { "isBase": false, "CODE": "ATT", "isMetric": "no", "class": "misc", "names": ["technical atmosphere"], "printSymbols": ["at"], "properties": ["pressure"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "osm", { type: "literal", value: "osm", description: "\"osm\"" }, function (u) {
      return { "value": 1, "units": { "osm": 1 }, "metadata": { "osm": { "isBase": false, "CODE": "OSM", "isMetric": "yes", "class": "chemical", "names": ["osmole"], "printSymbols": ["osm"], "properties": ["amount of substance (dissolved particles)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "tex", { type: "literal", value: "tex", description: "\"tex\"" }, function (u) {
      return { "value": 1, "units": { "tex": 1 }, "metadata": { "tex": { "isBase": false, "CODE": "TEX", "isMetric": "yes", "class": "heat", "names": ["tex"], "printSymbols": ["tex"], "properties": ["linear mass density (of textile thread)"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "cal", { type: "literal", value: "cal", description: "\"cal\"" }, function (u) {
      return { "value": 1, "units": { "cal": 1 }, "metadata": { "cal": { "isBase": false, "CODE": "CAL", "isMetric": "yes", "class": "heat", "names": ["calorie"], "printSymbols": ["cal"], "properties": ["energy"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "REM", { type: "literal", value: "REM", description: "\"REM\"" }, function (u) {
      return { "value": 1, "units": { "REM": 1 }, "metadata": { "REM": { "isBase": false, "CODE": "[REM]", "isMetric": "yes", "class": "cgs", "names": ["radiation equivalent man"], "printSymbols": ["REM"], "properties": ["dose equivalent"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "RAD", { type: "literal", value: "RAD", description: "\"RAD\"" }, function (u) {
      return { "value": 1, "units": { "RAD": 1 }, "metadata": { "RAD": { "isBase": false, "CODE": "[RAD]", "isMetric": "yes", "class": "cgs", "names": ["radiation absorbed dose"], "printSymbols": ["RAD"], "properties": ["energy dose"], "values": [{ "printable": "100", "numeric": 100 }] } } };
    }, "a_g", { type: "literal", value: "a_g", description: "\"a_g\"" }, function (u) {
      return { "value": 1, "units": { "a_g": 1 }, "metadata": { "a_g": { "isBase": false, "CODE": "ANN_G", "isMetric": "no", "class": "iso1000", "names": ["mean Gregorian year"], "printSymbols": ["a<sub>g</sub>"], "properties": ["time"], "values": [{ "printable": "365.2425", "numeric": 365.2425 }] } } };
    }, "Lmb", { type: "literal", value: "Lmb", description: "\"Lmb\"" }, function (u) {
      return { "value": 1, "units": { "Lmb": 1 }, "metadata": { "Lmb": { "isBase": false, "CODE": "LMB", "isMetric": "yes", "class": "cgs", "names": ["Lambert"], "printSymbols": ["L"], "properties": ["brightness"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "atm", { type: "literal", value: "atm", description: "\"atm\"" }, function (u) {
      return { "value": 1, "units": { "atm": 1 }, "metadata": { "atm": { "isBase": false, "CODE": "ATM", "isMetric": "no", "class": "const", "names": ["standard atmosphere"], "printSymbols": ["atm"], "properties": ["pressure"], "values": [{ "printable": "101325", "numeric": 101325 }] } } };
    }, "erg", { type: "literal", value: "erg", description: "\"erg\"" }, function (u) {
      return { "value": 1, "units": { "erg": 1 }, "metadata": { "erg": { "isBase": false, "CODE": "ERG", "isMetric": "yes", "class": "cgs", "names": ["erg"], "printSymbols": ["erg"], "properties": ["energy"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "dyn", { type: "literal", value: "dyn", description: "\"dyn\"" }, function (u) {
      return { "value": 1, "units": { "dyn": 1 }, "metadata": { "dyn": { "isBase": false, "CODE": "DYN", "isMetric": "yes", "class": "cgs", "names": ["dyne"], "printSymbols": ["dyn"], "properties": ["force"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Gal", { type: "literal", value: "Gal", description: "\"Gal\"" }, function (u) {
      return { "value": 1, "units": { "Gal": 1 }, "metadata": { "Gal": { "isBase": false, "CODE": "GL", "isMetric": "yes", "class": "cgs", "names": ["Gal"], "printSymbols": ["Gal"], "properties": ["acceleration"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "10^", { type: "literal", value: "10^", description: "\"10^\"" }, function (u) {
      return { "value": 1, "units": { "10^": 1 }, "metadata": { "10^": { "isBase": false, "CODE": "10^", "isMetric": "no", "class": "dimless", "names": ["the number ten for arbitrary powers"], "printSymbols": ["10"], "properties": ["number"], "values": [{ "printable": "10", "numeric": 10 }] } } };
    }, "10*", { type: "literal", value: "10*", description: "\"10*\"" }, function (u) {
      return { "value": 1, "units": { "10*": 1 }, "metadata": { "10*": { "isBase": false, "CODE": "10*", "isMetric": "no", "class": "dimless", "names": ["the number ten for arbitrary powers"], "printSymbols": ["10"], "properties": ["number"], "values": [{ "printable": "10", "numeric": 10 }] } } };
    }, "[S]", { type: "literal", value: "[S]", description: "\"[S]\"" }, function (u) {
      return { "value": 1, "units": { "[S]": 1 }, "metadata": { "[S]": { "isBase": false, "CODE": "[S]", "isMetric": "no", "class": "chemical", "names": ["Svedberg unit"], "printSymbols": ["S"], "properties": ["sedimentation coefficient"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "[g]", { type: "literal", value: "[g]", description: "\"[g]\"" }, function (u) {
      return { "value": 1, "units": { "[g]": 1 }, "metadata": { "[g]": { "isBase": false, "CODE": "[G]", "isMetric": "yes", "class": "const", "names": ["standard acceleration of free fall"], "printSymbols": ["<i>g<sub>n</sub>\n         </i>"], "properties": ["acceleration"], "values": [{ "printable": "9.80665", "numeric": 9.80665 }] } } };
    }, "[G]", { type: "literal", value: "[G]", description: "\"[G]\"" }, function (u) {
      return { "value": 1, "units": { "[G]": 1 }, "metadata": { "[G]": { "isBase": false, "CODE": "[GC]", "isMetric": "yes", "class": "const", "names": ["Newtonian constant of gravitation"], "printSymbols": ["<i>G</i>"], "properties": ["(unclassified)"], "values": [{ "printable": "6.67259 &#215; 10<sup>-11</sup>", "numeric": 6.67259e-11 }] } } };
    }, "[e]", { type: "literal", value: "[e]", description: "\"[e]\"" }, function (u) {
      return { "value": 1, "units": { "[e]": 1 }, "metadata": { "[e]": { "isBase": false, "CODE": "[E]", "isMetric": "yes", "class": "const", "names": ["elementary charge"], "printSymbols": ["<i>e</i>"], "properties": ["electric charge"], "values": [{ "printable": "1.60217733 &#215; 10<sup>-19</sup>", "numeric": 1.60217733e-19 }] } } };
    }, "[k]", { type: "literal", value: "[k]", description: "\"[k]\"" }, function (u) {
      return { "value": 1, "units": { "[k]": 1 }, "metadata": { "[k]": { "isBase": false, "CODE": "[K]", "isMetric": "yes", "class": "const", "names": ["Boltzmann constant"], "printSymbols": ["<i>k</i>"], "properties": ["(unclassified)"], "values": [{ "printable": "1.380658 &#215; 10<sup>-23</sup>", "numeric": 1.380658e-23 }] } } };
    }, "[h]", { type: "literal", value: "[h]", description: "\"[h]\"" }, function (u) {
      return { "value": 1, "units": { "[h]": 1 }, "metadata": { "[h]": { "isBase": false, "CODE": "[H]", "isMetric": "yes", "class": "const", "names": ["Planck constant"], "printSymbols": ["<i>h</i>"], "properties": ["action"], "values": [{ "printable": "6.6260755 &#215; 10<sup>-24</sup>", "numeric": 6.6260755e-24 }] } } };
    }, "[c]", { type: "literal", value: "[c]", description: "\"[c]\"" }, function (u) {
      return { "value": 1, "units": { "[c]": 1 }, "metadata": { "[c]": { "isBase": false, "CODE": "[C]", "isMetric": "yes", "class": "const", "names": ["velocity of light"], "printSymbols": ["<i>c</i>"], "properties": ["velocity"], "values": [{ "printable": "299792458", "numeric": 299792458 }] } } };
    }, "bar", { type: "literal", value: "bar", description: "\"bar\"" }, function (u) {
      return { "value": 1, "units": { "bar": 1 }, "metadata": { "bar": { "isBase": false, "CODE": "BAR", "isMetric": "yes", "class": "iso1000", "names": ["bar"], "printSymbols": ["bar"], "properties": ["pressure"], "values": [{ "printable": "1 &#215; 10<sup>5</sup>", "numeric": 100000 }] } } };
    }, "lm", { type: "literal", value: "lm", description: "\"lm\"" }, function (u) {
      return { "value": 1, "units": { "lm": 1 }, "metadata": { "lm": { "isBase": false, "CODE": "LM", "isMetric": "yes", "class": "si", "names": ["lumen"], "printSymbols": ["lm"], "properties": ["luminous flux"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Ci", { type: "literal", value: "Ci", description: "\"Ci\"" }, function (u) {
      return { "value": 1, "units": { "Ci": 1 }, "metadata": { "Ci": { "isBase": false, "CODE": "CI", "isMetric": "yes", "class": "cgs", "names": ["Curie"], "printSymbols": ["Ci"], "properties": ["radioactivity"], "values": [{ "printable": "3.7 &#215; 10<sup>10</sup>", "numeric": 37000000000 }] } } };
    }, "ph", { type: "literal", value: "ph", description: "\"ph\"" }, function (u) {
      return { "value": 1, "units": { "ph": 1 }, "metadata": { "ph": { "isBase": false, "CODE": "PHT", "isMetric": "yes", "class": "cgs", "names": ["phot"], "printSymbols": ["ph"], "properties": ["illuminance"], "values": [{ "printable": "1 &#215; 10<sup>-4</sup>", "numeric": 0.0001 }] } } };
    }, "cd", { type: "literal", value: "cd", description: "\"cd\"" }, function (u) {
      return { "value": 1, "units": { "cd": 1 }, "metadata": { "cd": { "isBase": true, "CODE": "CD", "dim": "F", "names": ["candela"], "printSymbols": ["cd"], "properties": ["luminous intensity"] } } };
    }, "Ao", { type: "literal", value: "Ao", description: "\"Ao\"" }, function (u) {
      return { "value": 1, "units": { "Ao": 1 }, "metadata": { "Ao": { "isBase": false, "CODE": "AO", "isMetric": "no", "class": "misc", "names": ["Ångström"], "printSymbols": ["&#197;"], "properties": ["length"], "values": [{ "printable": "0.1", "numeric": 0.1 }] } } };
    }, "Wb", { type: "literal", value: "Wb", description: "\"Wb\"" }, function (u) {
      return { "value": 1, "units": { "Wb": 1 }, "metadata": { "Wb": { "isBase": false, "CODE": "WB", "isMetric": "yes", "class": "si", "names": ["Weber"], "printSymbols": ["Wb"], "properties": ["magentic flux"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Gb", { type: "literal", value: "Gb", description: "\"Gb\"" }, function (u) {
      return { "value": 1, "units": { "Gb": 1 }, "metadata": { "Gb": { "isBase": false, "CODE": "GB", "isMetric": "yes", "class": "cgs", "names": ["Gilbert"], "printSymbols": ["Gb"], "properties": ["magnetic tension"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Oe", { type: "literal", value: "Oe", description: "\"Oe\"" }, function (u) {
      return { "value": 1, "units": { "Oe": 1 }, "metadata": { "Oe": { "isBase": false, "CODE": "OE", "isMetric": "yes", "class": "cgs", "names": ["Oersted"], "printSymbols": ["Oe"], "properties": ["magnetic field intensity"], "values": [{ "printable": "250", "numeric": 250 }] } } };
    }, "lx", { type: "literal", value: "lx", description: "\"lx\"" }, function (u) {
      return { "value": 1, "units": { "lx": 1 }, "metadata": { "lx": { "isBase": false, "CODE": "LX", "isMetric": "yes", "class": "si", "names": ["lux"], "printSymbols": ["lx"], "properties": ["illuminance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Mx", { type: "literal", value: "Mx", description: "\"Mx\"" }, function (u) {
      return { "value": 1, "units": { "Mx": 1 }, "metadata": { "Mx": { "isBase": false, "CODE": "MX", "isMetric": "yes", "class": "cgs", "names": ["Maxwell"], "printSymbols": ["Mx"], "properties": ["flux of magnetic induction"], "values": [{ "printable": "1 &#215; 10<sup>-8</sup>", "numeric": 1e-8 }] } } };
    }, "St", { type: "literal", value: "St", description: "\"St\"" }, function (u) {
      return { "value": 1, "units": { "St": 1 }, "metadata": { "St": { "isBase": false, "CODE": "ST", "isMetric": "yes", "class": "cgs", "names": ["Stokes"], "printSymbols": ["St"], "properties": ["kinematic viscosity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Bi", { type: "literal", value: "Bi", description: "\"Bi\"" }, function (u) {
      return { "value": 1, "units": { "Bi": 1 }, "metadata": { "Bi": { "isBase": false, "CODE": "BI", "isMetric": "yes", "class": "cgs", "names": ["Biot"], "printSymbols": ["Bi"], "properties": ["electric current"], "values": [{ "printable": "10", "numeric": 10 }] } } };
    }, "Bq", { type: "literal", value: "Bq", description: "\"Bq\"" }, function (u) {
      return { "value": 1, "units": { "Bq": 1 }, "metadata": { "Bq": { "isBase": false, "CODE": "BQ", "isMetric": "yes", "class": "si", "names": ["Becquerel"], "printSymbols": ["Bq"], "properties": ["radioactivity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Np", { type: "literal", value: "Np", description: "\"Np\"" }, function (u) {
      return { "value": 1, "units": { "Np": 1 }, "metadata": { "Np": { "isBase": false, "CODE": "NEP", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["neper"], "printSymbols": ["Np"], "properties": ["level"], "values": [{ "printable": "<function name=\"ln\" value=\"1\" Unit=\"1\"/>", "numeric": null }] } } };
    }, "AU", { type: "literal", value: "AU", description: "\"AU\"" }, function (u) {
      return { "value": 1, "units": { "AU": 1 }, "metadata": { "AU": { "isBase": false, "CODE": "ASU", "isMetric": "no", "class": "iso1000", "names": ["astronomic unit"], "printSymbols": ["AU"], "properties": ["length"], "values": [{ "printable": "149597.870691", "numeric": 149597.870691 }] } } };
    }, "mo", { type: "literal", value: "mo", description: "\"mo\"" }, function (u) {
      return { "value": 1, "units": { "mo": 1 }, "metadata": { "mo": { "isBase": false, "CODE": "MO", "isMetric": "no", "class": "iso1000", "names": ["month"], "printSymbols": ["mo"], "properties": ["time"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Ky", { type: "literal", value: "Ky", description: "\"Ky\"" }, function (u) {
      return { "value": 1, "units": { "Ky": 1 }, "metadata": { "Ky": { "isBase": false, "CODE": "KY", "isMetric": "yes", "class": "cgs", "names": ["Kayser"], "printSymbols": ["K"], "properties": ["lineic number"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "gf", { type: "literal", value: "gf", description: "\"gf\"" }, function (u) {
      return { "value": 1, "units": { "gf": 1 }, "metadata": { "gf": { "isBase": false, "CODE": "GF", "isMetric": "yes", "class": "const", "names": ["gram-force"], "printSymbols": ["gf"], "properties": ["force"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "wk", { type: "literal", value: "wk", description: "\"wk\"" }, function (u) {
      return { "value": 1, "units": { "wk": 1 }, "metadata": { "wk": { "isBase": false, "CODE": "WK", "isMetric": "no", "class": "iso1000", "names": ["week"], "printSymbols": ["wk"], "properties": ["time"], "values": [{ "printable": "7", "numeric": 7 }] } } };
    }, "Pa", { type: "literal", value: "Pa", description: "\"Pa\"" }, function (u) {
      return { "value": 1, "units": { "Pa": 1 }, "metadata": { "Pa": { "isBase": false, "CODE": "PAL", "isMetric": "yes", "class": "si", "names": ["Pascal"], "printSymbols": ["Pa"], "properties": ["pressure"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "g%", { type: "literal", value: "g%", description: "\"g%\"" }, function (u) {
      return { "value": 1, "units": { "g%": 1 }, "metadata": { "g%": { "isBase": false, "CODE": "G%", "isMetric": "yes", "class": "chemical", "names": ["gram percent"], "printSymbols": ["g%"], "properties": ["mass concentration"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "sr", { type: "literal", value: "sr", description: "\"sr\"" }, function (u) {
      return { "value": 1, "units": { "sr": 1 }, "metadata": { "sr": { "isBase": false, "CODE": "SR", "isMetric": "yes", "class": "si", "names": ["steradian"], "printSymbols": ["sr"], "properties": ["solid angle"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Bd", { type: "literal", value: "Bd", description: "\"Bd\"" }, function (u) {
      return { "value": 1, "units": { "Bd": 1 }, "metadata": { "Bd": { "isBase": false, "CODE": "BD", "isMetric": "yes", "class": "infotech", "names": ["baud"], "printSymbols": ["Bd"], "properties": ["signal transmission rate"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "eq", { type: "literal", value: "eq", description: "\"eq\"" }, function (u) {
      return { "value": 1, "units": { "eq": 1 }, "metadata": { "eq": { "isBase": false, "CODE": "EQ", "isMetric": "yes", "class": "chemical", "names": ["equivalents"], "printSymbols": ["eq"], "properties": ["amount of substance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "By", { type: "literal", value: "By", description: "\"By\"" }, function (u) {
      return { "value": 1, "units": { "By": 1 }, "metadata": { "By": { "isBase": false, "CODE": "BY", "isMetric": "yes", "class": "infotech", "names": ["byte"], "printSymbols": ["B"], "properties": ["amount of information"], "values": [{ "printable": "8", "numeric": 8 }] } } };
    }, "Hz", { type: "literal", value: "Hz", description: "\"Hz\"" }, function (u) {
      return { "value": 1, "units": { "Hz": 1 }, "metadata": { "Hz": { "isBase": false, "CODE": "HZ", "isMetric": "yes", "class": "si", "names": ["Hertz"], "printSymbols": ["Hz"], "properties": ["frequency"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "''", { type: "literal", value: "''", description: "\"''\"" }, function (u) {
      return { "value": 1, "units": { "''": 1 }, "metadata": { "''": { "isBase": false, "CODE": "''", "isMetric": "no", "class": "iso1000", "names": ["second"], "printSymbols": ["''"], "properties": ["plane angle"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "pc", { type: "literal", value: "pc", description: "\"pc\"" }, function (u) {
      return { "value": 1, "units": { "pc": 1 }, "metadata": { "pc": { "isBase": false, "CODE": "PRS", "isMetric": "yes", "class": "iso1000", "names": ["parsec"], "printSymbols": ["pc"], "properties": ["length"], "values": [{ "printable": "3.085678 &#215; 10<sup>16</sup>", "numeric": 30856780000000000 }] } } };
    }, "eV", { type: "literal", value: "eV", description: "\"eV\"" }, function (u) {
      return { "value": 1, "units": { "eV": 1 }, "metadata": { "eV": { "isBase": false, "CODE": "EV", "isMetric": "yes", "class": "iso1000", "names": ["electronvolt"], "printSymbols": ["eV"], "properties": ["energy"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Gy", { type: "literal", value: "Gy", description: "\"Gy\"" }, function (u) {
      return { "value": 1, "units": { "Gy": 1 }, "metadata": { "Gy": { "isBase": false, "CODE": "GY", "isMetric": "yes", "class": "si", "names": ["Gray"], "printSymbols": ["Gy"], "properties": ["energy dose"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "st", { type: "literal", value: "st", description: "\"st\"" }, function (u) {
      return { "value": 1, "units": { "st": 1 }, "metadata": { "st": { "isBase": false, "CODE": "STR", "isMetric": "yes", "class": "misc", "names": ["stere"], "printSymbols": ["st"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "Sv", { type: "literal", value: "Sv", description: "\"Sv\"" }, function (u) {
      return { "value": 1, "units": { "Sv": 1 }, "metadata": { "Sv": { "isBase": false, "CODE": "SV", "isMetric": "yes", "class": "si", "names": ["Sievert"], "printSymbols": ["Sv"], "properties": ["dose equivalent"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "ar", { type: "literal", value: "ar", description: "\"ar\"" }, function (u) {
      return { "value": 1, "units": { "ar": 1 }, "metadata": { "ar": { "isBase": false, "CODE": "AR", "isMetric": "yes", "class": "iso1000", "names": ["are"], "printSymbols": ["a"], "properties": ["area"], "values": [{ "printable": "100", "numeric": 100 }] } } };
    }, "sb", { type: "literal", value: "sb", description: "\"sb\"" }, function (u) {
      return { "value": 1, "units": { "sb": 1 }, "metadata": { "sb": { "isBase": false, "CODE": "SB", "isMetric": "yes", "class": "cgs", "names": ["stilb"], "printSymbols": ["sb"], "properties": ["lum. intensity density"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "L", { type: "literal", value: "L", description: "\"L\"" }, function (u) {
      return { "value": 1, "units": { "L": 1 }, "metadata": { "L": { "isBase": false, "isMetric": "yes", "class": "iso1000", "names": ["liter"], "printSymbols": ["L"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "t", { type: "literal", value: "t", description: "\"t\"" }, function (u) {
      return { "value": 1, "units": { "t": 1 }, "metadata": { "t": { "isBase": false, "CODE": "TNE", "isMetric": "yes", "class": "iso1000", "names": ["tonne"], "printSymbols": ["t"], "properties": ["mass"], "values": [{ "printable": "1 &#215; 10<sup>3</sup>", "numeric": 1000 }] } } };
    }, "u", { type: "literal", value: "u", description: "\"u\"" }, function (u) {
      return { "value": 1, "units": { "u": 1 }, "metadata": { "u": { "isBase": false, "CODE": "AMU", "isMetric": "yes", "class": "iso1000", "names": ["unified atomic mass unit"], "printSymbols": ["u"], "properties": ["mass"], "values": [{ "printable": "1.6605402 &#215; 10<sup>-24</sup>", "numeric": 1.6605402e-24 }] } } };
    }, "P", { type: "literal", value: "P", description: "\"P\"" }, function (u) {
      return { "value": 1, "units": { "P": 1 }, "metadata": { "P": { "isBase": false, "CODE": "P", "isMetric": "yes", "class": "cgs", "names": ["Poise"], "printSymbols": ["P"], "properties": ["dynamic viscosity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "G", { type: "literal", value: "G", description: "\"G\"" }, function (u) {
      return { "value": 1, "units": { "G": 1 }, "metadata": { "G": { "isBase": false, "CODE": "GS", "isMetric": "yes", "class": "cgs", "names": ["Gauss"], "printSymbols": ["Gs"], "properties": ["magnetic flux density"], "values": [{ "printable": "1 &#215; 10<sup>-4</sup>", "numeric": 0.0001 }] } } };
    }, "R", { type: "literal", value: "R", description: "\"R\"" }, function (u) {
      return { "value": 1, "units": { "R": 1 }, "metadata": { "R": { "isBase": false, "CODE": "ROE", "isMetric": "yes", "class": "cgs", "names": ["Roentgen"], "printSymbols": ["R"], "properties": ["ion dose"], "values": [{ "printable": "2.58 &#215; 10<sup>-4</sup>", "numeric": 0.000258 }] } } };
    }, "H", { type: "literal", value: "H", description: "\"H\"" }, function (u) {
      return { "value": 1, "units": { "H": 1 }, "metadata": { "H": { "isBase": false, "CODE": "H", "isMetric": "yes", "class": "si", "names": ["Henry"], "printSymbols": ["H"], "properties": ["inductance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "T", { type: "literal", value: "T", description: "\"T\"" }, function (u) {
      return { "value": 1, "units": { "T": 1 }, "metadata": { "T": { "isBase": false, "CODE": "T", "isMetric": "yes", "class": "si", "names": ["Tesla"], "printSymbols": ["T"], "properties": ["magnetic flux density"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "U", { type: "literal", value: "U", description: "\"U\"" }, function (u) {
      return { "value": 1, "units": { "U": 1 }, "metadata": { "U": { "isBase": false, "CODE": "U", "isMetric": "yes", "class": "chemical", "names": ["Unit"], "printSymbols": ["U"], "properties": ["catalytic activity"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "B", { type: "literal", value: "B", description: "\"B\"" }, function (u) {
      return { "value": 1, "units": { "B": 1 }, "metadata": { "B": { "isBase": false, "CODE": "B", "isMetric": "yes", "isSpecial": "yes", "class": "levels", "names": ["bel"], "printSymbols": ["B"], "properties": ["level"], "values": [{ "printable": "<function name=\"lg\" value=\"1\" Unit=\"1\"/>", "numeric": null }] } } };
    }, "S", { type: "literal", value: "S", description: "\"S\"" }, function (u) {
      return { "value": 1, "units": { "S": 1 }, "metadata": { "S": { "isBase": false, "CODE": "SIE", "isMetric": "yes", "class": "si", "names": ["Siemens"], "printSymbols": ["S"], "properties": ["electric conductance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "m", { type: "literal", value: "m", description: "\"m\"" }, function (u) {
      return { "value": 1, "units": { "m": 1 }, "metadata": { "m": { "isBase": true, "CODE": "M", "dim": "L", "names": ["meter"], "printSymbols": ["m"], "properties": ["length"] } } };
    }, "s", { type: "literal", value: "s", description: "\"s\"" }, function (u) {
      return { "value": 1, "units": { "s": 1 }, "metadata": { "s": { "isBase": true, "CODE": "S", "dim": "T", "names": ["second"], "printSymbols": ["s"], "properties": ["time"] } } };
    }, "F", { type: "literal", value: "F", description: "\"F\"" }, function (u) {
      return { "value": 1, "units": { "F": 1 }, "metadata": { "F": { "isBase": false, "CODE": "F", "isMetric": "yes", "class": "si", "names": ["Farad"], "printSymbols": ["F"], "properties": ["electric capacitance"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "l", { type: "literal", value: "l", description: "\"l\"" }, function (u) {
      return { "value": 1, "units": { "l": 1 }, "metadata": { "l": { "isBase": false, "CODE": "L", "isMetric": "yes", "class": "iso1000", "names": ["liter"], "printSymbols": ["l"], "properties": ["volume"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "V", { type: "literal", value: "V", description: "\"V\"" }, function (u) {
      return { "value": 1, "units": { "V": 1 }, "metadata": { "V": { "isBase": false, "CODE": "V", "isMetric": "yes", "class": "si", "names": ["Volt"], "printSymbols": ["V"], "properties": ["electric potential"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "A", { type: "literal", value: "A", description: "\"A\"" }, function (u) {
      return { "value": 1, "units": { "A": 1 }, "metadata": { "A": { "isBase": false, "CODE": "A", "isMetric": "yes", "class": "si", "names": ["Ampère"], "printSymbols": ["A"], "properties": ["electric current"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "W", { type: "literal", value: "W", description: "\"W\"" }, function (u) {
      return { "value": 1, "units": { "W": 1 }, "metadata": { "W": { "isBase": false, "CODE": "W", "isMetric": "yes", "class": "si", "names": ["Watt"], "printSymbols": ["W"], "properties": ["power"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "K", { type: "literal", value: "K", description: "\"K\"" }, function (u) {
      return { "value": 1, "units": { "K": 1 }, "metadata": { "K": { "isBase": true, "CODE": "K", "dim": "C", "names": ["Kelvin"], "printSymbols": ["K"], "properties": ["temperature"] } } };
    }, "C", { type: "literal", value: "C", description: "\"C\"" }, function (u) {
      return { "value": 1, "units": { "C": 1 }, "metadata": { "C": { "isBase": true, "CODE": "C", "dim": "Q", "names": ["Coulomb"], "printSymbols": ["C"], "properties": ["electric charge"] } } };
    }, "b", { type: "literal", value: "b", description: "\"b\"" }, function (u) {
      return { "value": 1, "units": { "b": 1 }, "metadata": { "b": { "isBase": false, "CODE": "BRN", "isMetric": "no", "class": "misc", "names": ["barn"], "printSymbols": ["b"], "properties": ["action area"], "values": [{ "printable": "100", "numeric": 100 }] } } };
    }, "%", { type: "literal", value: "%", description: "\"%\"" }, function (u) {
      return { "value": 1, "units": { "%": 1 }, "metadata": { "%": { "isBase": false, "CODE": "%", "isMetric": "no", "class": "dimless", "names": ["percent"], "printSymbols": ["%"], "properties": ["fraction"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "J", { type: "literal", value: "J", description: "\"J\"" }, function (u) {
      return { "value": 1, "units": { "J": 1 }, "metadata": { "J": { "isBase": false, "CODE": "J", "isMetric": "yes", "class": "si", "names": ["Joule"], "printSymbols": ["J"], "properties": ["energy"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "'", { type: "literal", value: "'", description: "\"'\"" }, function (u) {
      return { "value": 1, "units": { "'": 1 }, "metadata": { "'": { "isBase": false, "CODE": "'", "isMetric": "no", "class": "iso1000", "names": ["minute"], "printSymbols": ["'"], "properties": ["plane angle"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "h", { type: "literal", value: "h", description: "\"h\"" }, function (u) {
      return { "value": 1, "units": { "h": 1 }, "metadata": { "h": { "isBase": false, "CODE": "HR", "isMetric": "no", "class": "iso1000", "names": ["hour"], "printSymbols": ["h"], "properties": ["time"], "values": [{ "printable": "60", "numeric": 60 }] } } };
    }, "d", { type: "literal", value: "d", description: "\"d\"" }, function (u) {
      return { "value": 1, "units": { "d": 1 }, "metadata": { "d": { "isBase": false, "CODE": "D", "isMetric": "no", "class": "iso1000", "names": ["day"], "printSymbols": ["d"], "properties": ["time"], "values": [{ "printable": "24", "numeric": 24 }] } } };
    }, "N", { type: "literal", value: "N", description: "\"N\"" }, function (u) {
      return { "value": 1, "units": { "N": 1 }, "metadata": { "N": { "isBase": false, "CODE": "N", "isMetric": "yes", "class": "si", "names": ["Newton"], "printSymbols": ["N"], "properties": ["force"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "a", { type: "literal", value: "a", description: "\"a\"" }, function (u) {
      return { "value": 1, "units": { "a": 1 }, "metadata": { "a": { "isBase": false, "CODE": "ANN", "isMetric": "no", "class": "iso1000", "names": ["year"], "printSymbols": ["a"], "properties": ["time"], "values": [{ "printable": "1", "numeric": 1 }] } } };
    }, "g", { type: "literal", value: "g", description: "\"g\"" }, function (u) {
      return { "value": 1, "units": { "g": 1 }, "metadata": { "g": { "isBase": true, "CODE": "G", "dim": "M", "names": ["gram"], "printSymbols": ["g"], "properties": ["mass"] } } };
    }, "Y", { type: "literal", value: "Y", description: "\"Y\"" }, "Z", { type: "literal", value: "Z", description: "\"Z\"" }, "E", { type: "literal", value: "E", description: "\"E\"" }, "M", { type: "literal", value: "M", description: "\"M\"" }, "k", { type: "literal", value: "k", description: "\"k\"" }, "da", { type: "literal", value: "da", description: "\"da\"" }, "c", { type: "literal", value: "c", description: "\"c\"" }, "n", { type: "literal", value: "n", description: "\"n\"" }, "p", { type: "literal", value: "p", description: "\"p\"" }, "f", { type: "literal", value: "f", description: "\"f\"" }, "z", { type: "literal", value: "z", description: "\"z\"" }, "y", { type: "literal", value: "y", description: "\"y\"" }, "Ki", { type: "literal", value: "Ki", description: "\"Ki\"" }, "Mi", { type: "literal", value: "Mi", description: "\"Mi\"" }, "Gi", { type: "literal", value: "Gi", description: "\"Gi\"" }, "Ti", { type: "literal", value: "Ti", description: "\"Ti\"" }],
        peg$bytecode = [peg$decode("!7!+' 4!6 !! %"), peg$decode("!.\"\"\"2\"3#+2$7#+(%4\"6$\"! %$\"# !\"# !*# \"7#"), peg$decode("!.%\"\"2%3&+-$7$+#%'\"%$\"# !\"# !*> \"!.\"\"\"2\"3#+-$7$+#%'\"%$\"# !\"# !"), peg$decode("!7$+;$ '7\",#&7\"\"+)%4\"6(\"\"! %$\"# !\"# !"), peg$decode("!7%+c$7&*# \" )+S% '7),#&7)\"+A%56* \"\"!)##\" !\" ++)%4$6,$\"#\"%$$# !$## !$\"# !\"# !*E \"!7(+:$ '7),#&7)\"+(%4\"6-\"!!%$\"# !\"# !"), peg$decode("!7'+' 4!6.!! %*Y \"!./\"\"2/30+B$7#+8%.1\"\"2132+(%4#63#!!%$## !$\"# !\"# !*# \"7)"), peg$decode("!04\"\"1!35*# \" )+3$7(+)%4\"66\"\"! %$\"# !\"# !"), peg$decode("!7+*# \" )+K$7*+A%567 \"! )##\" !\" ++)%4#68#\"\"!%$## !$\"# !\"# !*# \"7*"), peg$decode("! '09\"\"1!3:+,$,)&09\"\"1!3:\"\"\" !+i$.;\"\"2;3<*# \" )+S%7&*# \" )+C%56= #\"! )##\" !\" ++*%4$6>$##\"!%$$# !$## !$\"# !\"# !"), peg$decode("!.?\"\"2?3@+t$ '0A\"\"1!3B+,$,)&0A\"\"1!3B\"\"\" !+O%.C\"\"2C3D+?%56E !!)##\" !\" ++(%4$6F$!\"%$$# !$## !$\"# !\"# !"), peg$decode("!.G\"\"2G3H+' 4!6I!! %*\u1CCD \"!.J\"\"2J3K+' 4!6L!! %*\u1CB5 \"!.M\"\"2M3N+' 4!6O!! %*\u1C9D \"!.P\"\"2P3Q+' 4!6R!! %*\u1C85 \"!.S\"\"2S3T+' 4!6U!! %*\u1C6D \"!.V\"\"2V3W+' 4!6X!! %*\u1C55 \"!.Y\"\"2Y3Z+' 4!6[!! %*\u1C3D \"!.\\\"\"2\\3]+' 4!6^!! %*\u1C25 \"!._\"\"2_3`+' 4!6a!! %*\u1C0D \"!.b\"\"2b3c+' 4!6d!! %*\u1BF5 \"!.e\"\"2e3f+' 4!6g!! %*\u1BDD \"!.h\"\"2h3i+' 4!6j!! %*\u1BC5 \"!.k\"\"2k3l+' 4!6m!! %*\u1BAD \"!.n\"\"2n3o+' 4!6p!! %*\u1B95 \"!.q\"\"2q3r+' 4!6s!! %*\u1B7D \"!.t\"\"2t3u+' 4!6v!! %*\u1B65 \"!.w\"\"2w3x+' 4!6y!! %*\u1B4D \"!.z\"\"2z3{+' 4!6|!! %*\u1B35 \"!.}\"\"2}3~+' 4!6!! %*\u1B1D \"!.\x80\"\"2\x803\x81+' 4!6\x82!! %*\u1B05 \"!.\x83\"\"2\x833\x84+' 4!6\x85!! %*\u1AED \"!.\x86\"\"2\x863\x87+' 4!6\x88!! %*\u1AD5 \"!.\x89\"\"2\x893\x8A+' 4!6\x8B!! %*\u1ABD \"!.\x8C\"\"2\x8C3\x8D+' 4!6\x8E!! %*\u1AA5 \"!.\x8F\"\"2\x8F3\x90+' 4!6\x91!! %*\u1A8D \"!.\x92\"\"2\x923\x93+' 4!6\x94!! %*\u1A75 \"!.\x95\"\"2\x953\x96+' 4!6\x97!! %*\u1A5D \"!.\x98\"\"2\x983\x99+' 4!6\x9A!! %*\u1A45 \"!.\x9B\"\"2\x9B3\x9C+' 4!6\x9D!! %*\u1A2D \"!.\x9E\"\"2\x9E3\x9F+' 4!6\xA0!! %*\u1A15 \"!.\xA1\"\"2\xA13\xA2+' 4!6\xA3!! %*\u19FD \"!.\xA4\"\"2\xA43\xA5+' 4!6\xA6!! %*\u19E5 \"!.\xA7\"\"2\xA73\xA8+' 4!6\xA9!! %*\u19CD \"!.\xAA\"\"2\xAA3\xAB+' 4!6\xAC!! %*\u19B5 \"!.\xAD\"\"2\xAD3\xAE+' 4!6\xAF!! %*\u199D \"!.\xB0\"\"2\xB03\xB1+' 4!6\xB2!! %*\u1985 \"!.\xB3\"\"2\xB33\xB4+' 4!6\xB5!! %*\u196D \"!.\xB6\"\"2\xB63\xB7+' 4!6\xB8!! %*\u1955 \"!.\xB9\"\"2\xB93\xBA+' 4!6\xBB!! %*\u193D \"!.\xBC\"\"2\xBC3\xBD+' 4!6\xBE!! %*\u1925 \"!.\xBF\"\"2\xBF3\xC0+' 4!6\xC1!! %*\u190D \"!.\xC2\"\"2\xC23\xC3+' 4!6\xC4!! %*\u18F5 \"!.\xC5\"\"2\xC53\xC6+' 4!6\xC7!! %*\u18DD \"!.\xC8\"\"2\xC83\xC9+' 4!6\xCA!! %*\u18C5 \"!.\xCB\"\"2\xCB3\xCC+' 4!6\xCD!! %*\u18AD \"!.\xCE\"\"2\xCE3\xCF+' 4!6\xD0!! %*\u1895 \"!.\xD1\"\"2\xD13\xD2+' 4!6\xD3!! %*\u187D \"!.\xD4\"\"2\xD43\xD5+' 4!6\xD6!! %*\u1865 \"!.\xD7\"\"2\xD73\xD8+' 4!6\xD9!! %*\u184D \"!.\xDA\"\"2\xDA3\xDB+' 4!6\xDC!! %*\u1835 \"!.\xDD\"\"2\xDD3\xDE+' 4!6\xDF!! %*\u181D \"!.\xE0\"\"2\xE03\xE1+' 4!6\xE2!! %*\u1805 \"!.\xE3\"\"2\xE33\xE4+' 4!6\xE5!! %*\u17ED \"!.\xE6\"\"2\xE63\xE7+' 4!6\xE8!! %*\u17D5 \"!.\xE9\"\"2\xE93\xEA+' 4!6\xEB!! %*\u17BD \"!.\xEC\"\"2\xEC3\xED+' 4!6\xEE!! %*\u17A5 \"!.\xEF\"\"2\xEF3\xF0+' 4!6\xF1!! %*\u178D \"!.\xF2\"\"2\xF23\xF3+' 4!6\xF4!! %*\u1775 \"!.\xF5\"\"2\xF53\xF6+' 4!6\xF7!! %*\u175D \"!.\xF8\"\"2\xF83\xF9+' 4!6\xFA!! %*\u1745 \"!.\xFB\"\"2\xFB3\xFC+' 4!6\xFD!! %*\u172D \"!.\xFE\"\"2\xFE3\xFF+' 4!6\u0100!! %*\u1715 \"!.\u0101\"\"2\u01013\u0102+' 4!6\u0103!! %*\u16FD \"!.\u0104\"\"2\u01043\u0105+' 4!6\u0106!! %*\u16E5 \"!.\u0107\"\"2\u01073\u0108+' 4!6\u0109!! %*\u16CD \"!.\u010A\"\"2\u010A3\u010B+' 4!6\u010C!! %*\u16B5 \"!.\u010D\"\"2\u010D3\u010E+' 4!6\u010F!! %*\u169D \"!.\u0110\"\"2\u01103\u0111+' 4!6\u0112!! %*\u1685 \"!.\u0113\"\"2\u01133\u0114+' 4!6\u0115!! %*\u166D \"!.\u0116\"\"2\u01163\u0117+' 4!6\u0118!! %*\u1655 \"!.\u0119\"\"2\u01193\u011A+' 4!6\u011B!! %*\u163D \"!.\u011C\"\"2\u011C3\u011D+' 4!6\u011E!! %*\u1625 \"!.\u011F\"\"2\u011F3\u0120+' 4!6\u0121!! %*\u160D \"!.\u0122\"\"2\u01223\u0123+' 4!6\u0124!! %*\u15F5 \"!.\u0125\"\"2\u01253\u0126+' 4!6\u0127!! %*\u15DD \"!.\u0128\"\"2\u01283\u0129+' 4!6\u012A!! %*\u15C5 \"!.\u012B\"\"2\u012B3\u012C+' 4!6\u012D!! %*\u15AD \"!.\u012E\"\"2\u012E3\u012F+' 4!6\u0130!! %*\u1595 \"!.\u0131\"\"2\u01313\u0132+' 4!6\u0133!! %*\u157D \"!.\u0134\"\"2\u01343\u0135+' 4!6\u0136!! %*\u1565 \"!.\u0137\"\"2\u01373\u0138+' 4!6\u0139!! %*\u154D \"!.\u013A\"\"2\u013A3\u013B+' 4!6\u013C!! %*\u1535 \"!.\u013D\"\"2\u013D3\u013E+' 4!6\u013F!! %*\u151D \"!.\u0140\"\"2\u01403\u0141+' 4!6\u0142!! %*\u1505 \"!.\u0143\"\"2\u01433\u0144+' 4!6\u0145!! %*\u14ED \"!.\u0146\"\"2\u01463\u0147+' 4!6\u0148!! %*\u14D5 \"!.\u0149\"\"2\u01493\u014A+' 4!6\u014B!! %*\u14BD \"!.\u014C\"\"2\u014C3\u014D+' 4!6\u014E!! %*\u14A5 \"!.\u014F\"\"2\u014F3\u0150+' 4!6\u0151!! %*\u148D \"!.\u0152\"\"2\u01523\u0153+' 4!6\u0154!! %*\u1475 \"!.\u0155\"\"2\u01553\u0156+' 4!6\u0157!! %*\u145D \"!.\u0158\"\"2\u01583\u0159+' 4!6\u015A!! %*\u1445 \"!.\u015B\"\"2\u015B3\u015C+' 4!6\u015D!! %*\u142D \"!.\u015E\"\"2\u015E3\u015F+' 4!6\u0160!! %*\u1415 \"!.\u0161\"\"2\u01613\u0162+' 4!6\u0163!! %*\u13FD \"!.\u0164\"\"2\u01643\u0165+' 4!6\u0166!! %*\u13E5 \"!.\u0167\"\"2\u01673\u0168+' 4!6\u0169!! %*\u13CD \"!.\u016A\"\"2\u016A3\u016B+' 4!6\u016C!! %*\u13B5 \"!.\u016D\"\"2\u016D3\u016E+' 4!6\u016F!! %*\u139D \"!.\u0170\"\"2\u01703\u0171+' 4!6\u0172!! %*\u1385 \"!.\u0173\"\"2\u01733\u0174+' 4!6\u0175!! %*\u136D \"!.\u0176\"\"2\u01763\u0177+' 4!6\u0178!! %*\u1355 \"!.\u0179\"\"2\u01793\u017A+' 4!6\u017B!! %*\u133D \"!.\u017C\"\"2\u017C3\u017D+' 4!6\u017E!! %*\u1325 \"!.\u017F\"\"2\u017F3\u0180+' 4!6\u0181!! %*\u130D \"!.\u0182\"\"2\u01823\u0183+' 4!6\u0184!! %*\u12F5 \"!.\u0185\"\"2\u01853\u0186+' 4!6\u0187!! %*\u12DD \"!.\u0188\"\"2\u01883\u0189+' 4!6\u018A!! %*\u12C5 \"!.\u018B\"\"2\u018B3\u018C+' 4!6\u018D!! %*\u12AD \"!.\u018E\"\"2\u018E3\u018F+' 4!6\u0190!! %*\u1295 \"!.\u0191\"\"2\u01913\u0192+' 4!6\u0193!! %*\u127D \"!.\u0194\"\"2\u01943\u0195+' 4!6\u0196!! %*\u1265 \"!.\u0197\"\"2\u01973\u0198+' 4!6\u0199!! %*\u124D \"!.\u019A\"\"2\u019A3\u019B+' 4!6\u019C!! %*\u1235 \"!.\u019D\"\"2\u019D3\u019E+' 4!6\u019F!! %*\u121D \"!.\u01A0\"\"2\u01A03\u01A1+' 4!6\u01A2!! %*\u1205 \"!.\u01A3\"\"2\u01A33\u01A4+' 4!6\u01A5!! %*\u11ED \"!.\u01A6\"\"2\u01A63\u01A7+' 4!6\u01A8!! %*\u11D5 \"!.\u01A9\"\"2\u01A93\u01AA+' 4!6\u01AB!! %*\u11BD \"!.\u01AC\"\"2\u01AC3\u01AD+' 4!6\u01AE!! %*\u11A5 \"!.\u01AF\"\"2\u01AF3\u01B0+' 4!6\u01B1!! %*\u118D \"!.\u01B2\"\"2\u01B23\u01B3+' 4!6\u01B4!! %*\u1175 \"!.\u01B5\"\"2\u01B53\u01B6+' 4!6\u01B7!! %*\u115D \"!.\u01B8\"\"2\u01B83\u01B9+' 4!6\u01BA!! %*\u1145 \"!.\u01BB\"\"2\u01BB3\u01BC+' 4!6\u01BD!! %*\u112D \"!.\u01BE\"\"2\u01BE3\u01BF+' 4!6\u01C0!! %*\u1115 \"!.\u01C1\"\"2\u01C13\u01C2+' 4!6\u01C3!! %*\u10FD \"!.\u01C4\"\"2\u01C43\u01C5+' 4!6\u01C6!! %*\u10E5 \"!.\u01C7\"\"2\u01C73\u01C8+' 4!6\u01C9!! %*\u10CD \"!.\u01CA\"\"2\u01CA3\u01CB+' 4!6\u01CC!! %*\u10B5 \"!.\u01CD\"\"2\u01CD3\u01CE+' 4!6\u01CF!! %*\u109D \"!.\u01D0\"\"2\u01D03\u01D1+' 4!6\u01D2!! %*\u1085 \"!.\u01D3\"\"2\u01D33\u01D4+' 4!6\u01D5!! %*\u106D \"!.\u01D6\"\"2\u01D63\u01D7+' 4!6\u01D8!! %*\u1055 \"!.\u01D9\"\"2\u01D93\u01DA+' 4!6\u01DB!! %*\u103D \"!.\u01DC\"\"2\u01DC3\u01DD+' 4!6\u01DE!! %*\u1025 \"!.\u01DF\"\"2\u01DF3\u01E0+' 4!6\u01E1!! %*\u100D \"!.\u01E2\"\"2\u01E23\u01E3+' 4!6\u01E4!! %*\u0FF5 \"!.\u01E5\"\"2\u01E53\u01E6+' 4!6\u01E7!! %*\u0FDD \"!.\u01E8\"\"2\u01E83\u01E9+' 4!6\u01EA!! %*\u0FC5 \"!.\u01EB\"\"2\u01EB3\u01EC+' 4!6\u01ED!! %*\u0FAD \"!.\u01EE\"\"2\u01EE3\u01EF+' 4!6\u01F0!! %*\u0F95 \"!.\u01F1\"\"2\u01F13\u01F2+' 4!6\u01F3!! %*\u0F7D \"!.\u01F4\"\"2\u01F43\u01F5+' 4!6\u01F6!! %*\u0F65 \"!.\u01F7\"\"2\u01F73\u01F8+' 4!6\u01F9!! %*\u0F4D \"!.\u01FA\"\"2\u01FA3\u01FB+' 4!6\u01FC!! %*\u0F35 \"!.\u01FD\"\"2\u01FD3\u01FE+' 4!6\u01FF!! %*\u0F1D \"!.\u0200\"\"2\u02003\u0201+' 4!6\u0202!! %*\u0F05 \"!.\u0203\"\"2\u02033\u0204+' 4!6\u0205!! %*\u0EED \"!.\u0206\"\"2\u02063\u0207+' 4!6\u0208!! %*\u0ED5 \"!.\u0209\"\"2\u02093\u020A+' 4!6\u020B!! %*\u0EBD \"!.\u020C\"\"2\u020C3\u020D+' 4!6\u020E!! %*\u0EA5 \"!.\u020F\"\"2\u020F3\u0210+' 4!6\u0211!! %*\u0E8D \"!.\u0212\"\"2\u02123\u0213+' 4!6\u0214!! %*\u0E75 \"!.\u0215\"\"2\u02153\u0216+' 4!6\u0217!! %*\u0E5D \"!.\u0218\"\"2\u02183\u0219+' 4!6\u021A!! %*\u0E45 \"!.\u021B\"\"2\u021B3\u021C+' 4!6\u021D!! %*\u0E2D \"!.\u021E\"\"2\u021E3\u021F+' 4!6\u0220!! %*\u0E15 \"!.\u0221\"\"2\u02213\u0222+' 4!6\u0223!! %*\u0DFD \"!.\u0224\"\"2\u02243\u0225+' 4!6\u0226!! %*\u0DE5 \"!.\u0227\"\"2\u02273\u0228+' 4!6\u0229!! %*\u0DCD \"!.\u022A\"\"2\u022A3\u022B+' 4!6\u022C!! %*\u0DB5 \"!.\u022D\"\"2\u022D3\u022E+' 4!6\u022F!! %*\u0D9D \"!.\u0230\"\"2\u02303\u0231+' 4!6\u0232!! %*\u0D85 \"!.\u0233\"\"2\u02333\u0234+' 4!6\u0235!! %*\u0D6D \"!.\u0236\"\"2\u02363\u0237+' 4!6\u0238!! %*\u0D55 \"!.\u0239\"\"2\u02393\u023A+' 4!6\u023B!! %*\u0D3D \"!.\u023C\"\"2\u023C3\u023D+' 4!6\u023E!! %*\u0D25 \"!.\u023F\"\"2\u023F3\u0240+' 4!6\u0241!! %*\u0D0D \"!.\u0242\"\"2\u02423\u0243+' 4!6\u0244!! %*\u0CF5 \"!.\u0245\"\"2\u02453\u0246+' 4!6\u0247!! %*\u0CDD \"!.\u0248\"\"2\u02483\u0249+' 4!6\u024A!! %*\u0CC5 \"!.\u024B\"\"2\u024B3\u024C+' 4!6\u024D!! %*\u0CAD \"!.\u024E\"\"2\u024E3\u024F+' 4!6\u0250!! %*\u0C95 \"!.\u0251\"\"2\u02513\u0252+' 4!6\u0253!! %*\u0C7D \"!.\u0254\"\"2\u02543\u0255+' 4!6\u0256!! %*\u0C65 \"!.\u0257\"\"2\u02573\u0258+' 4!6\u0259!! %*\u0C4D \"!.\u025A\"\"2\u025A3\u025B+' 4!6\u025C!! %*\u0C35 \"!.\u025D\"\"2\u025D3\u025E+' 4!6\u025F!! %*\u0C1D \"!.\u0260\"\"2\u02603\u0261+' 4!6\u0262!! %*\u0C05 \"!.\u0263\"\"2\u02633\u0264+' 4!6\u0265!! %*\u0BED \"!.\u0266\"\"2\u02663\u0267+' 4!6\u0268!! %*\u0BD5 \"!.\u0269\"\"2\u02693\u026A+' 4!6\u026B!! %*\u0BBD \"!.\u026C\"\"2\u026C3\u026D+' 4!6\u026E!! %*\u0BA5 \"!.\u026F\"\"2\u026F3\u0270+' 4!6\u0271!! %*\u0B8D \"!.\u0272\"\"2\u02723\u0273+' 4!6\u0274!! %*\u0B75 \"!.\u0275\"\"2\u02753\u0276+' 4!6\u0277!! %*\u0B5D \"!.\u0278\"\"2\u02783\u0279+' 4!6\u027A!! %*\u0B45 \"!.\u027B\"\"2\u027B3\u027C+' 4!6\u027D!! %*\u0B2D \"!.\u027E\"\"2\u027E3\u027F+' 4!6\u0280!! %*\u0B15 \"!.\u0281\"\"2\u02813\u0282+' 4!6\u0283!! %*\u0AFD \"!.\u0284\"\"2\u02843\u0285+' 4!6\u0286!! %*\u0AE5 \"!.\u0287\"\"2\u02873\u0288+' 4!6\u0289!! %*\u0ACD \"!.\u028A\"\"2\u028A3\u028B+' 4!6\u028C!! %*\u0AB5 \"!.\u028D\"\"2\u028D3\u028E+' 4!6\u028F!! %*\u0A9D \"!.\u0290\"\"2\u02903\u0291+' 4!6\u0292!! %*\u0A85 \"!.\u0293\"\"2\u02933\u0294+' 4!6\u0295!! %*\u0A6D \"!.\u0296\"\"2\u02963\u0297+' 4!6\u0298!! %*\u0A55 \"!.\u0299\"\"2\u02993\u029A+' 4!6\u029B!! %*\u0A3D \"!.\u029C\"\"2\u029C3\u029D+' 4!6\u029E!! %*\u0A25 \"!.\u029F\"\"2\u029F3\u02A0+' 4!6\u02A1!! %*\u0A0D \"!.\u02A2\"\"2\u02A23\u02A3+' 4!6\u02A4!! %*\u09F5 \"!.\u02A5\"\"2\u02A53\u02A6+' 4!6\u02A7!! %*\u09DD \"!.\u02A8\"\"2\u02A83\u02A9+' 4!6\u02AA!! %*\u09C5 \"!.\u02AB\"\"2\u02AB3\u02AC+' 4!6\u02AD!! %*\u09AD \"!.\u02AE\"\"2\u02AE3\u02AF+' 4!6\u02B0!! %*\u0995 \"!.\u02B1\"\"2\u02B13\u02B2+' 4!6\u02B3!! %*\u097D \"!.\u02B4\"\"2\u02B43\u02B5+' 4!6\u02B6!! %*\u0965 \"!.\u02B7\"\"2\u02B73\u02B8+' 4!6\u02B9!! %*\u094D \"!.\u02BA\"\"2\u02BA3\u02BB+' 4!6\u02BC!! %*\u0935 \"!.\u02BD\"\"2\u02BD3\u02BE+' 4!6\u02BF!! %*\u091D \"!.\u02C0\"\"2\u02C03\u02C1+' 4!6\u02C2!! %*\u0905 \"!.\u02C3\"\"2\u02C33\u02C4+' 4!6\u02C5!! %*\u08ED \"!.\u02C6\"\"2\u02C63\u02C7+' 4!6\u02C8!! %*\u08D5 \"!.\u02C9\"\"2\u02C93\u02CA+' 4!6\u02CB!! %*\u08BD \"!.\u02CC\"\"2\u02CC3\u02CD+' 4!6\u02CE!! %*\u08A5 \"!.\u02CF\"\"2\u02CF3\u02D0+' 4!6\u02D1!! %*\u088D \"!.\u02D2\"\"2\u02D23\u02D3+' 4!6\u02D4!! %*\u0875 \"!.\u02D5\"\"2\u02D53\u02D6+' 4!6\u02D7!! %*\u085D \"!.\u02D8\"\"2\u02D83\u02D9+' 4!6\u02DA!! %*\u0845 \"!.\u02DB\"\"2\u02DB3\u02DC+' 4!6\u02DD!! %*\u082D \"!.\u02DE\"\"2\u02DE3\u02DF+' 4!6\u02E0!! %*\u0815 \"!.\u02E1\"\"2\u02E13\u02E2+' 4!6\u02E3!! %*\u07FD \"!.\u02E4\"\"2\u02E43\u02E5+' 4!6\u02E6!! %*\u07E5 \"!.\u02E7\"\"2\u02E73\u02E8+' 4!6\u02E9!! %*\u07CD \"!.\u02EA\"\"2\u02EA3\u02EB+' 4!6\u02EC!! %*\u07B5 \"!.\u02ED\"\"2\u02ED3\u02EE+' 4!6\u02EF!! %*\u079D \"!.\u02F0\"\"2\u02F03\u02F1+' 4!6\u02F2!! %*\u0785 \"!.\u02F3\"\"2\u02F33\u02F4+' 4!6\u02F5!! %*\u076D \"!.\u02F6\"\"2\u02F63\u02F7+' 4!6\u02F8!! %*\u0755 \"!.\u02F9\"\"2\u02F93\u02FA+' 4!6\u02FB!! %*\u073D \"!.\u02FC\"\"2\u02FC3\u02FD+' 4!6\u02FE!! %*\u0725 \"!.\u02FF\"\"2\u02FF3\u0300+' 4!6\u0301!! %*\u070D \"!.\u0302\"\"2\u03023\u0303+' 4!6\u0304!! %*\u06F5 \"!.\u0305\"\"2\u03053\u0306+' 4!6\u0307!! %*\u06DD \"!.\u0308\"\"2\u03083\u0309+' 4!6\u030A!! %*\u06C5 \"!.\u030B\"\"2\u030B3\u030C+' 4!6\u030D!! %*\u06AD \"!.\u030E\"\"2\u030E3\u030F+' 4!6\u0310!! %*\u0695 \"!.\u0311\"\"2\u03113\u0312+' 4!6\u0313!! %*\u067D \"!.\u0314\"\"2\u03143\u0315+' 4!6\u0316!! %*\u0665 \"!.\u0317\"\"2\u03173\u0318+' 4!6\u0319!! %*\u064D \"!.\u031A\"\"2\u031A3\u031B+' 4!6\u031C!! %*\u0635 \"!.\u031D\"\"2\u031D3\u031E+' 4!6\u031F!! %*\u061D \"!.\u0320\"\"2\u03203\u0321+' 4!6\u0322!! %*\u0605 \"!.\u0323\"\"2\u03233\u0324+' 4!6\u0325!! %*\u05ED \"!.\u0326\"\"2\u03263\u0327+' 4!6\u0328!! %*\u05D5 \"!.\u0329\"\"2\u03293\u032A+' 4!6\u032B!! %*\u05BD \"!.\u032C\"\"2\u032C3\u032D+' 4!6\u032E!! %*\u05A5 \"!.\u032F\"\"2\u032F3\u0330+' 4!6\u0331!! %*\u058D \"!.\u0332\"\"2\u03323\u0333+' 4!6\u0334!! %*\u0575 \"!.\u0335\"\"2\u03353\u0336+' 4!6\u0337!! %*\u055D \"!.\u0338\"\"2\u03383\u0339+' 4!6\u033A!! %*\u0545 \"!.\u033B\"\"2\u033B3\u033C+' 4!6\u033D!! %*\u052D \"!.\u033E\"\"2\u033E3\u033F+' 4!6\u0340!! %*\u0515 \"!.\u0341\"\"2\u03413\u0342+' 4!6\u0343!! %*\u04FD \"!.\u0344\"\"2\u03443\u0345+' 4!6\u0346!! %*\u04E5 \"!.\u0347\"\"2\u03473\u0348+' 4!6\u0349!! %*\u04CD \"!.\u034A\"\"2\u034A3\u034B+' 4!6\u034C!! %*\u04B5 \"!.\u034D\"\"2\u034D3\u034E+' 4!6\u034F!! %*\u049D \"!.\u0350\"\"2\u03503\u0351+' 4!6\u0352!! %*\u0485 \"!.\u0353\"\"2\u03533\u0354+' 4!6\u0355!! %*\u046D \"!.\u0356\"\"2\u03563\u0357+' 4!6\u0358!! %*\u0455 \"!.\u0359\"\"2\u03593\u035A+' 4!6\u035B!! %*\u043D \"!.\u035C\"\"2\u035C3\u035D+' 4!6\u035E!! %*\u0425 \"!.\u035F\"\"2\u035F3\u0360+' 4!6\u0361!! %*\u040D \"!.\u0362\"\"2\u03623\u0363+' 4!6\u0364!! %*\u03F5 \"!.\u0365\"\"2\u03653\u0366+' 4!6\u0367!! %*\u03DD \"!.\u0368\"\"2\u03683\u0369+' 4!6\u036A!! %*\u03C5 \"!.\u036B\"\"2\u036B3\u036C+' 4!6\u036D!! %*\u03AD \"!.\u036E\"\"2\u036E3\u036F+' 4!6\u0370!! %*\u0395 \"!.\u0371\"\"2\u03713\u0372+' 4!6\u0373!! %*\u037D \"!.\u0374\"\"2\u03743\u0375+' 4!6\u0376!! %*\u0365 \"!.\u0377\"\"2\u03773\u0378+' 4!6\u0379!! %*\u034D \"!.\u037A\"\"2\u037A3\u037B+' 4!6\u037C!! %*\u0335 \"!.\u037D\"\"2\u037D3\u037E+' 4!6\u037F!! %*\u031D \"!.\u0380\"\"2\u03803\u0381+' 4!6\u0382!! %*\u0305 \"!.\u0383\"\"2\u03833\u0384+' 4!6\u0385!! %*\u02ED \"!.\u0386\"\"2\u03863\u0387+' 4!6\u0388!! %*\u02D5 \"!.\u0389\"\"2\u03893\u038A+' 4!6\u038B!! %*\u02BD \"!.\u038C\"\"2\u038C3\u038D+' 4!6\u038E!! %*\u02A5 \"!.\u038F\"\"2\u038F3\u0390+' 4!6\u0391!! %*\u028D \"!.\u0392\"\"2\u03923\u0393+' 4!6\u0394!! %*\u0275 \"!.\u0395\"\"2\u03953\u0396+' 4!6\u0397!! %*\u025D \"!.\u0398\"\"2\u03983\u0399+' 4!6\u039A!! %*\u0245 \"!.\u039B\"\"2\u039B3\u039C+' 4!6\u039D!! %*\u022D \"!.\u039E\"\"2\u039E3\u039F+' 4!6\u03A0!! %*\u0215 \"!.\u03A1\"\"2\u03A13\u03A2+' 4!6\u03A3!! %*\u01FD \"!.\u03A4\"\"2\u03A43\u03A5+' 4!6\u03A6!! %*\u01E5 \"!.\u03A7\"\"2\u03A73\u03A8+' 4!6\u03A9!! %*\u01CD \"!.\u03AA\"\"2\u03AA3\u03AB+' 4!6\u03AC!! %*\u01B5 \"!.\u03AD\"\"2\u03AD3\u03AE+' 4!6\u03AF!! %*\u019D \"!.\u03B0\"\"2\u03B03\u03B1+' 4!6\u03B2!! %*\u0185 \"!.\u03B3\"\"2\u03B33\u03B4+' 4!6\u03B5!! %*\u016D \"!.\u03B6\"\"2\u03B63\u03B7+' 4!6\u03B8!! %*\u0155 \"!.\u03B9\"\"2\u03B93\u03BA+' 4!6\u03BB!! %*\u013D \"!.\u03BC\"\"2\u03BC3\u03BD+' 4!6\u03BE!! %*\u0125 \"!.\u03BF\"\"2\u03BF3\u03C0+' 4!6\u03C1!! %*\u010D \"!.\u03C2\"\"2\u03C23\u03C3+' 4!6\u03C4!! %*\xF5 \"!.\u03C5\"\"2\u03C53\u03C6+' 4!6\u03C7!! %*\xDD \"!.\u03C8\"\"2\u03C83\u03C9+' 4!6\u03CA!! %*\xC5 \"!.\u03CB\"\"2\u03CB3\u03CC+' 4!6\u03CD!! %*\xAD \"!.\u03CE\"\"2\u03CE3\u03CF+' 4!6\u03D0!! %*\x95 \"!.\u03D1\"\"2\u03D13\u03D2+' 4!6\u03D3!! %*} \"!.\u03D4\"\"2\u03D43\u03D5+' 4!6\u03D6!! %*e \"!.\u03D7\"\"2\u03D73\u03D8+' 4!6\u03D9!! %*M \"!.\u03DA\"\"2\u03DA3\u03DB+' 4!6\u03DC!! %*5 \"!.\u03DD\"\"2\u03DD3\u03DE+' 4!6\u03DF!! %"), peg$decode(".\u03E0\"\"2\u03E03\u03E1*\u0131 \".\u03E2\"\"2\u03E23\u03E3*\u0125 \".\u03E4\"\"2\u03E43\u03E5*\u0119 \".\u0392\"\"2\u03923\u0393*\u010D \".\u039E\"\"2\u039E3\u039F*\u0101 \".\u0395\"\"2\u03953\u0396*\xF5 \".\u03E6\"\"2\u03E63\u03E7*\xE9 \".\u03E8\"\"2\u03E83\u03E9*\xDD \".\u03D1\"\"2\u03D13\u03D2*\xD1 \".\u03EA\"\"2\u03EA3\u03EB*\xC5 \".\u03D4\"\"2\u03D43\u03D5*\xB9 \".\u03EC\"\"2\u03EC3\u03ED*\xAD \".\u03AA\"\"2\u03AA3\u03AB*\xA1 \".\u038F\"\"2\u038F3\u0390*\x95 \".\u03EE\"\"2\u03EE3\u03EF*\x89 \".\u03F0\"\"2\u03F03\u03F1*} \".\u03F2\"\"2\u03F23\u03F3*q \".\u03DA\"\"2\u03DA3\u03DB*e \".\u03F4\"\"2\u03F43\u03F5*Y \".\u03F6\"\"2\u03F63\u03F7*M \".\u03F8\"\"2\u03F83\u03F9*A \".\u03FA\"\"2\u03FA3\u03FB*5 \".\u03FC\"\"2\u03FC3\u03FD*) \".\u03FE\"\"2\u03FE3\u03FF")],
        peg$currPos = 0,
        peg$reportedPos = 0,
        peg$cachedPos = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleIndices)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(null, [{ type: "other", description: description }], peg$reportedPos);
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) {
              details.line++;
            }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function (a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }

          return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
            return '\\x' + hex(ch);
          }).replace(/[\u0180-\u0FFF]/g, function (ch) {
            return '\\u0' + hex(ch);
          }).replace(/[\u1080-\uFFFF]/g, function (ch) {
            return '\\u' + hex(ch);
          });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
    }

    function peg$decode(s) {
      var bc = new Array(s.length),
          i;

      for (i = 0; i < s.length; i++) {
        bc[i] = s.charCodeAt(i) - 32;
      }

      return bc;
    }

    function peg$parseRule(index) {
      var bc = peg$bytecode[index],
          ip = 0,
          ips = [],
          end = bc.length,
          ends = [],
          stack = [],
          params,
          i;

      function protect(object) {
        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
      }

      while (true) {
        while (ip < end) {
          switch (bc[ip]) {
            case 0:
              stack.push(protect(peg$consts[bc[ip + 1]]));
              ip += 2;
              break;

            case 1:
              stack.push(peg$currPos);
              ip++;
              break;

            case 2:
              stack.pop();
              ip++;
              break;

            case 3:
              peg$currPos = stack.pop();
              ip++;
              break;

            case 4:
              stack.length -= bc[ip + 1];
              ip += 2;
              break;

            case 5:
              stack.splice(-2, 1);
              ip++;
              break;

            case 6:
              stack[stack.length - 2].push(stack.pop());
              ip++;
              break;

            case 7:
              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
              ip += 2;
              break;

            case 8:
              stack.pop();
              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
              ip++;
              break;

            case 9:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1]) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 10:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] === peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 11:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] !== peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 12:
              if (stack[stack.length - 1] !== peg$FAILED) {
                ends.push(end);
                ips.push(ip);

                end = ip + 2 + bc[ip + 1];
                ip += 2;
              } else {
                ip += 2 + bc[ip + 1];
              }

              break;

            case 13:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (input.length > peg$currPos) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 14:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 15:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 16:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 17:
              stack.push(input.substr(peg$currPos, bc[ip + 1]));
              peg$currPos += bc[ip + 1];
              ip += 2;
              break;

            case 18:
              stack.push(peg$consts[bc[ip + 1]]);
              peg$currPos += peg$consts[bc[ip + 1]].length;
              ip += 2;
              break;

            case 19:
              stack.push(peg$FAILED);
              if (peg$silentFails === 0) {
                peg$fail(peg$consts[bc[ip + 1]]);
              }
              ip += 2;
              break;

            case 20:
              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
              ip += 2;
              break;

            case 21:
              peg$reportedPos = peg$currPos;
              ip++;
              break;

            case 22:
              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
              for (i = 0; i < bc[ip + 3]; i++) {
                params[i] = stack[stack.length - 1 - params[i]];
              }

              stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));

              ip += 4 + bc[ip + 3];
              break;

            case 23:
              stack.push(peg$parseRule(bc[ip + 1]));
              ip += 2;
              break;

            case 24:
              peg$silentFails++;
              ip++;
              break;

            case 25:
              peg$silentFails--;
              ip++;
              break;

            default:
              throw new Error("Invalid opcode: " + bc[ip] + ".");
          }
        }

        if (ends.length > 0) {
          end = ends.pop();
          ip = ips.pop();
        } else {
          break;
        }
      }

      return stack[0];
    }

    helpers = require('../lib/helpers');
    prefixes = require('./prefixes.json');
    prefixMetadata = require('./prefixMetadata.json');
    unitMetadata = require('./unitMetadata.json');
    metrics = require('./metrics.json');
    multiply = helpers.multiply;
    topower = helpers.topower;
    cleanup = helpers.cleanup;
    ismetric = helpers.ismetric(metrics);

    peg$result = peg$parseRule(peg$startRuleIndex);

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse: parse
  };
}();

},{"../lib/helpers":56,"./metrics.json":51,"./prefixMetadata.json":52,"./prefixes.json":53,"./unitMetadata.json":55}],55:[function(require,module,exports){
module.exports={
  "10*": {
    "isBase": false,
    "CODE": "10*",
    "isMetric": "no",
    "class": "dimless",
    "names": [
      "the number ten for arbitrary powers"
    ],
    "printSymbols": [
      "10"
    ],
    "properties": [
      "number"
    ],
    "values": [
      {
        "printable": "10",
        "numeric": 10
      }
    ]
  },
  "10^": {
    "isBase": false,
    "CODE": "10^",
    "isMetric": "no",
    "class": "dimless",
    "names": [
      "the number ten for arbitrary powers"
    ],
    "printSymbols": [
      "10"
    ],
    "properties": [
      "number"
    ],
    "values": [
      {
        "printable": "10",
        "numeric": 10
      }
    ]
  },
  "[pi]": {
    "isBase": false,
    "CODE": "[PI]",
    "isMetric": "no",
    "class": "dimless",
    "names": [
      "the number pi"
    ],
    "printSymbols": [
      "&#960;"
    ],
    "properties": [
      "number"
    ],
    "values": [
      {
        "printable": "&#960;",
        "numeric": 3.141592653589793
      }
    ]
  },
  "%": {
    "isBase": false,
    "CODE": "%",
    "isMetric": "no",
    "class": "dimless",
    "names": [
      "percent"
    ],
    "printSymbols": [
      "%"
    ],
    "properties": [
      "fraction"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[ppth]": {
    "isBase": false,
    "CODE": "[PPTH]",
    "isMetric": "no",
    "class": "dimless",
    "names": [
      "parts per thousand"
    ],
    "printSymbols": [
      "ppth"
    ],
    "properties": [
      "fraction"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[ppm]": {
    "isBase": false,
    "CODE": "[PPM]",
    "isMetric": "no",
    "class": "dimless",
    "names": [
      "parts per million"
    ],
    "printSymbols": [
      "ppm"
    ],
    "properties": [
      "fraction"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[ppb]": {
    "isBase": false,
    "CODE": "[PPB]",
    "isMetric": "no",
    "class": "dimless",
    "names": [
      "parts per billion"
    ],
    "printSymbols": [
      "ppb"
    ],
    "properties": [
      "fraction"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[pptr]": {
    "isBase": false,
    "CODE": "[PPTR]",
    "isMetric": "no",
    "class": "dimless",
    "names": [
      "parts per trillion"
    ],
    "printSymbols": [
      "pptr"
    ],
    "properties": [
      "fraction"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "mol": {
    "isBase": false,
    "CODE": "MOL",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "mole"
    ],
    "printSymbols": [
      "mol"
    ],
    "properties": [
      "amount of substance"
    ],
    "values": [
      {
        "printable": "6.0221367",
        "numeric": 6.0221367
      }
    ]
  },
  "sr": {
    "isBase": false,
    "CODE": "SR",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "steradian"
    ],
    "printSymbols": [
      "sr"
    ],
    "properties": [
      "solid angle"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Hz": {
    "isBase": false,
    "CODE": "HZ",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Hertz"
    ],
    "printSymbols": [
      "Hz"
    ],
    "properties": [
      "frequency"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "N": {
    "isBase": false,
    "CODE": "N",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Newton"
    ],
    "printSymbols": [
      "N"
    ],
    "properties": [
      "force"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Pa": {
    "isBase": false,
    "CODE": "PAL",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Pascal"
    ],
    "printSymbols": [
      "Pa"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "J": {
    "isBase": false,
    "CODE": "J",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Joule"
    ],
    "printSymbols": [
      "J"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "W": {
    "isBase": false,
    "CODE": "W",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Watt"
    ],
    "printSymbols": [
      "W"
    ],
    "properties": [
      "power"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "A": {
    "isBase": false,
    "CODE": "A",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Ampère"
    ],
    "printSymbols": [
      "A"
    ],
    "properties": [
      "electric current"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "V": {
    "isBase": false,
    "CODE": "V",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Volt"
    ],
    "printSymbols": [
      "V"
    ],
    "properties": [
      "electric potential"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "F": {
    "isBase": false,
    "CODE": "F",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Farad"
    ],
    "printSymbols": [
      "F"
    ],
    "properties": [
      "electric capacitance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Ohm": {
    "isBase": false,
    "CODE": "OHM",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Ohm"
    ],
    "printSymbols": [
      "&#937;"
    ],
    "properties": [
      "electric resistance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "S": {
    "isBase": false,
    "CODE": "SIE",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Siemens"
    ],
    "printSymbols": [
      "S"
    ],
    "properties": [
      "electric conductance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Wb": {
    "isBase": false,
    "CODE": "WB",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Weber"
    ],
    "printSymbols": [
      "Wb"
    ],
    "properties": [
      "magentic flux"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Cel": {
    "isBase": false,
    "CODE": "CEL",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "si",
    "names": [
      "degree Celsius"
    ],
    "printSymbols": [
      "&#176;C"
    ],
    "properties": [
      "temperature"
    ],
    "values": [
      {
        "printable": "<function name=\"Cel\" value=\"1\" Unit=\"K\"/>",
        "numeric": null
      }
    ]
  },
  "T": {
    "isBase": false,
    "CODE": "T",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Tesla"
    ],
    "printSymbols": [
      "T"
    ],
    "properties": [
      "magnetic flux density"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "H": {
    "isBase": false,
    "CODE": "H",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Henry"
    ],
    "printSymbols": [
      "H"
    ],
    "properties": [
      "inductance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "lm": {
    "isBase": false,
    "CODE": "LM",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "lumen"
    ],
    "printSymbols": [
      "lm"
    ],
    "properties": [
      "luminous flux"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "lx": {
    "isBase": false,
    "CODE": "LX",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "lux"
    ],
    "printSymbols": [
      "lx"
    ],
    "properties": [
      "illuminance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Bq": {
    "isBase": false,
    "CODE": "BQ",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Becquerel"
    ],
    "printSymbols": [
      "Bq"
    ],
    "properties": [
      "radioactivity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Gy": {
    "isBase": false,
    "CODE": "GY",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Gray"
    ],
    "printSymbols": [
      "Gy"
    ],
    "properties": [
      "energy dose"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Sv": {
    "isBase": false,
    "CODE": "SV",
    "isMetric": "yes",
    "class": "si",
    "names": [
      "Sievert"
    ],
    "printSymbols": [
      "Sv"
    ],
    "properties": [
      "dose equivalent"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "gon": {
    "isBase": false,
    "CODE": "GON",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "gon",
      "grade"
    ],
    "printSymbols": [
      "&#9633;<sup>g</sup>"
    ],
    "properties": [
      "plane angle"
    ],
    "values": [
      {
        "printable": "0.9",
        "numeric": 0.9
      }
    ]
  },
  "deg": {
    "isBase": false,
    "CODE": "DEG",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "degree"
    ],
    "printSymbols": [
      "&#176;"
    ],
    "properties": [
      "plane angle"
    ],
    "values": [
      {
        "printable": "2",
        "numeric": 2
      }
    ]
  },
  "'": {
    "isBase": false,
    "CODE": "'",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "minute"
    ],
    "printSymbols": [
      "'"
    ],
    "properties": [
      "plane angle"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "''": {
    "isBase": false,
    "CODE": "''",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "second"
    ],
    "printSymbols": [
      "''"
    ],
    "properties": [
      "plane angle"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "l": {
    "isBase": false,
    "CODE": "L",
    "isMetric": "yes",
    "class": "iso1000",
    "names": [
      "liter"
    ],
    "printSymbols": [
      "l"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "L": {
    "isBase": false,
    "isMetric": "yes",
    "class": "iso1000",
    "names": [
      "liter"
    ],
    "printSymbols": [
      "L"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "ar": {
    "isBase": false,
    "CODE": "AR",
    "isMetric": "yes",
    "class": "iso1000",
    "names": [
      "are"
    ],
    "printSymbols": [
      "a"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "100",
        "numeric": 100
      }
    ]
  },
  "min": {
    "isBase": false,
    "CODE": "MIN",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "minute"
    ],
    "printSymbols": [
      "min"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "60",
        "numeric": 60
      }
    ]
  },
  "h": {
    "isBase": false,
    "CODE": "HR",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "hour"
    ],
    "printSymbols": [
      "h"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "60",
        "numeric": 60
      }
    ]
  },
  "d": {
    "isBase": false,
    "CODE": "D",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "day"
    ],
    "printSymbols": [
      "d"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "24",
        "numeric": 24
      }
    ]
  },
  "a_t": {
    "isBase": false,
    "CODE": "ANN_T",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "tropical year"
    ],
    "printSymbols": [
      "a<sub>t</sub>"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "365.24219",
        "numeric": 365.24219
      }
    ]
  },
  "a_j": {
    "isBase": false,
    "CODE": "ANN_J",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "mean Julian year"
    ],
    "printSymbols": [
      "a<sub>j</sub>"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "365.25",
        "numeric": 365.25
      }
    ]
  },
  "a_g": {
    "isBase": false,
    "CODE": "ANN_G",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "mean Gregorian year"
    ],
    "printSymbols": [
      "a<sub>g</sub>"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "365.2425",
        "numeric": 365.2425
      }
    ]
  },
  "a": {
    "isBase": false,
    "CODE": "ANN",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "year"
    ],
    "printSymbols": [
      "a"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "wk": {
    "isBase": false,
    "CODE": "WK",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "week"
    ],
    "printSymbols": [
      "wk"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "7",
        "numeric": 7
      }
    ]
  },
  "mo_s": {
    "isBase": false,
    "CODE": "MO_S",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "synodal month"
    ],
    "printSymbols": [
      "mo<sub>s</sub>"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "29.53059",
        "numeric": 29.53059
      }
    ]
  },
  "mo_j": {
    "isBase": false,
    "CODE": "MO_J",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "mean Julian month"
    ],
    "printSymbols": [
      "mo<sub>j</sub>"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "mo_g": {
    "isBase": false,
    "CODE": "MO_G",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "mean Gregorian month"
    ],
    "printSymbols": [
      "mo<sub>g</sub>"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "mo": {
    "isBase": false,
    "CODE": "MO",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "month"
    ],
    "printSymbols": [
      "mo"
    ],
    "properties": [
      "time"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "t": {
    "isBase": false,
    "CODE": "TNE",
    "isMetric": "yes",
    "class": "iso1000",
    "names": [
      "tonne"
    ],
    "printSymbols": [
      "t"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>3</sup>",
        "numeric": 1000
      }
    ]
  },
  "bar": {
    "isBase": false,
    "CODE": "BAR",
    "isMetric": "yes",
    "class": "iso1000",
    "names": [
      "bar"
    ],
    "printSymbols": [
      "bar"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>5</sup>",
        "numeric": 100000
      }
    ]
  },
  "u": {
    "isBase": false,
    "CODE": "AMU",
    "isMetric": "yes",
    "class": "iso1000",
    "names": [
      "unified atomic mass unit"
    ],
    "printSymbols": [
      "u"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "1.6605402 &#215; 10<sup>-24</sup>",
        "numeric": 1.6605402e-24
      }
    ]
  },
  "eV": {
    "isBase": false,
    "CODE": "EV",
    "isMetric": "yes",
    "class": "iso1000",
    "names": [
      "electronvolt"
    ],
    "printSymbols": [
      "eV"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "AU": {
    "isBase": false,
    "CODE": "ASU",
    "isMetric": "no",
    "class": "iso1000",
    "names": [
      "astronomic unit"
    ],
    "printSymbols": [
      "AU"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "149597.870691",
        "numeric": 149597.870691
      }
    ]
  },
  "pc": {
    "isBase": false,
    "CODE": "PRS",
    "isMetric": "yes",
    "class": "iso1000",
    "names": [
      "parsec"
    ],
    "printSymbols": [
      "pc"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "3.085678 &#215; 10<sup>16</sup>",
        "numeric": 30856780000000000
      }
    ]
  },
  "[c]": {
    "isBase": false,
    "CODE": "[C]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "velocity of light"
    ],
    "printSymbols": [
      "<i>c</i>"
    ],
    "properties": [
      "velocity"
    ],
    "values": [
      {
        "printable": "299792458",
        "numeric": 299792458
      }
    ]
  },
  "[h]": {
    "isBase": false,
    "CODE": "[H]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "Planck constant"
    ],
    "printSymbols": [
      "<i>h</i>"
    ],
    "properties": [
      "action"
    ],
    "values": [
      {
        "printable": "6.6260755 &#215; 10<sup>-24</sup>",
        "numeric": 6.6260755e-24
      }
    ]
  },
  "[k]": {
    "isBase": false,
    "CODE": "[K]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "Boltzmann constant"
    ],
    "printSymbols": [
      "<i>k</i>"
    ],
    "properties": [
      "(unclassified)"
    ],
    "values": [
      {
        "printable": "1.380658 &#215; 10<sup>-23</sup>",
        "numeric": 1.380658e-23
      }
    ]
  },
  "[eps_0]": {
    "isBase": false,
    "CODE": "[EPS_0]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "permittivity of vacuum"
    ],
    "printSymbols": [
      "<i>&#949;<sub>\n               <r>0</r>\n            </sub>\n         </i>"
    ],
    "properties": [
      "electric permittivity"
    ],
    "values": [
      {
        "printable": "8.854187817 &#215; 10<sup>-12</sup>",
        "numeric": 8.854187817e-12
      }
    ]
  },
  "[mu_0]": {
    "isBase": false,
    "CODE": "[MU_0]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "permeability of vacuum"
    ],
    "printSymbols": [
      "<i>&#956;<sub>\n               <r>0</r>\n            </sub>\n         </i>"
    ],
    "properties": [
      "magnetic permeability"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[e]": {
    "isBase": false,
    "CODE": "[E]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "elementary charge"
    ],
    "printSymbols": [
      "<i>e</i>"
    ],
    "properties": [
      "electric charge"
    ],
    "values": [
      {
        "printable": "1.60217733 &#215; 10<sup>-19</sup>",
        "numeric": 1.60217733e-19
      }
    ]
  },
  "[m_e]": {
    "isBase": false,
    "CODE": "[M_E]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "electron mass"
    ],
    "printSymbols": [
      "<i>m<sub>\n               <r>e</r>\n            </sub>\n         </i>"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "9.1093897 &#215; 10<sup>-28</sup>",
        "numeric": 9.1093897e-28
      }
    ]
  },
  "[m_p]": {
    "isBase": false,
    "CODE": "[M_P]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "proton mass"
    ],
    "printSymbols": [
      "<i>m<sub>\n               <r>p</r>\n            </sub>\n         </i>"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "1.6726231 &#215; 10<sup>-24</sup>",
        "numeric": 1.6726231e-24
      }
    ]
  },
  "[G]": {
    "isBase": false,
    "CODE": "[GC]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "Newtonian constant of gravitation"
    ],
    "printSymbols": [
      "<i>G</i>"
    ],
    "properties": [
      "(unclassified)"
    ],
    "values": [
      {
        "printable": "6.67259 &#215; 10<sup>-11</sup>",
        "numeric": 6.67259e-11
      }
    ]
  },
  "[g]": {
    "isBase": false,
    "CODE": "[G]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "standard acceleration of free fall"
    ],
    "printSymbols": [
      "<i>g<sub>n</sub>\n         </i>"
    ],
    "properties": [
      "acceleration"
    ],
    "values": [
      {
        "printable": "9.80665",
        "numeric": 9.80665
      }
    ]
  },
  "atm": {
    "isBase": false,
    "CODE": "ATM",
    "isMetric": "no",
    "class": "const",
    "names": [
      "standard atmosphere"
    ],
    "printSymbols": [
      "atm"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "101325",
        "numeric": 101325
      }
    ]
  },
  "[ly]": {
    "isBase": false,
    "CODE": "[LY]",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "light-year"
    ],
    "printSymbols": [
      "l.y."
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "gf": {
    "isBase": false,
    "CODE": "GF",
    "isMetric": "yes",
    "class": "const",
    "names": [
      "gram-force"
    ],
    "printSymbols": [
      "gf"
    ],
    "properties": [
      "force"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[lbf_av]": {
    "isBase": false,
    "CODE": "[LBF_AV]",
    "isMetric": "no",
    "class": "const",
    "names": [
      "pound force"
    ],
    "printSymbols": [
      "lbf"
    ],
    "properties": [
      "force"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Ky": {
    "isBase": false,
    "CODE": "KY",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Kayser"
    ],
    "printSymbols": [
      "K"
    ],
    "properties": [
      "lineic number"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Gal": {
    "isBase": false,
    "CODE": "GL",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Gal"
    ],
    "printSymbols": [
      "Gal"
    ],
    "properties": [
      "acceleration"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "dyn": {
    "isBase": false,
    "CODE": "DYN",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "dyne"
    ],
    "printSymbols": [
      "dyn"
    ],
    "properties": [
      "force"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "erg": {
    "isBase": false,
    "CODE": "ERG",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "erg"
    ],
    "printSymbols": [
      "erg"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "P": {
    "isBase": false,
    "CODE": "P",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Poise"
    ],
    "printSymbols": [
      "P"
    ],
    "properties": [
      "dynamic viscosity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Bi": {
    "isBase": false,
    "CODE": "BI",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Biot"
    ],
    "printSymbols": [
      "Bi"
    ],
    "properties": [
      "electric current"
    ],
    "values": [
      {
        "printable": "10",
        "numeric": 10
      }
    ]
  },
  "St": {
    "isBase": false,
    "CODE": "ST",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Stokes"
    ],
    "printSymbols": [
      "St"
    ],
    "properties": [
      "kinematic viscosity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Mx": {
    "isBase": false,
    "CODE": "MX",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Maxwell"
    ],
    "printSymbols": [
      "Mx"
    ],
    "properties": [
      "flux of magnetic induction"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-8</sup>",
        "numeric": 1e-8
      }
    ]
  },
  "G": {
    "isBase": false,
    "CODE": "GS",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Gauss"
    ],
    "printSymbols": [
      "Gs"
    ],
    "properties": [
      "magnetic flux density"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-4</sup>",
        "numeric": 0.0001
      }
    ]
  },
  "Oe": {
    "isBase": false,
    "CODE": "OE",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Oersted"
    ],
    "printSymbols": [
      "Oe"
    ],
    "properties": [
      "magnetic field intensity"
    ],
    "values": [
      {
        "printable": "250",
        "numeric": 250
      }
    ]
  },
  "Gb": {
    "isBase": false,
    "CODE": "GB",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Gilbert"
    ],
    "printSymbols": [
      "Gb"
    ],
    "properties": [
      "magnetic tension"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "sb": {
    "isBase": false,
    "CODE": "SB",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "stilb"
    ],
    "printSymbols": [
      "sb"
    ],
    "properties": [
      "lum. intensity density"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Lmb": {
    "isBase": false,
    "CODE": "LMB",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Lambert"
    ],
    "printSymbols": [
      "L"
    ],
    "properties": [
      "brightness"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "ph": {
    "isBase": false,
    "CODE": "PHT",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "phot"
    ],
    "printSymbols": [
      "ph"
    ],
    "properties": [
      "illuminance"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-4</sup>",
        "numeric": 0.0001
      }
    ]
  },
  "Ci": {
    "isBase": false,
    "CODE": "CI",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Curie"
    ],
    "printSymbols": [
      "Ci"
    ],
    "properties": [
      "radioactivity"
    ],
    "values": [
      {
        "printable": "3.7 &#215; 10<sup>10</sup>",
        "numeric": 37000000000
      }
    ]
  },
  "R": {
    "isBase": false,
    "CODE": "ROE",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "Roentgen"
    ],
    "printSymbols": [
      "R"
    ],
    "properties": [
      "ion dose"
    ],
    "values": [
      {
        "printable": "2.58 &#215; 10<sup>-4</sup>",
        "numeric": 0.000258
      }
    ]
  },
  "RAD": {
    "isBase": false,
    "CODE": "[RAD]",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "radiation absorbed dose"
    ],
    "printSymbols": [
      "RAD"
    ],
    "properties": [
      "energy dose"
    ],
    "values": [
      {
        "printable": "100",
        "numeric": 100
      }
    ]
  },
  "REM": {
    "isBase": false,
    "CODE": "[REM]",
    "isMetric": "yes",
    "class": "cgs",
    "names": [
      "radiation equivalent man"
    ],
    "printSymbols": [
      "REM"
    ],
    "properties": [
      "dose equivalent"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[in_i]": {
    "isBase": false,
    "CODE": "[IN_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "inch"
    ],
    "printSymbols": [
      "in"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "2.54",
        "numeric": 2.54
      }
    ]
  },
  "[ft_i]": {
    "isBase": false,
    "CODE": "[FT_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "foot"
    ],
    "printSymbols": [
      "ft"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "12",
        "numeric": 12
      }
    ]
  },
  "[yd_i]": {
    "isBase": false,
    "CODE": "[YD_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "yard"
    ],
    "printSymbols": [
      "yd"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "3",
        "numeric": 3
      }
    ]
  },
  "[mi_i]": {
    "isBase": false,
    "CODE": "[MI_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "statute mile"
    ],
    "printSymbols": [
      "mi"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "5280",
        "numeric": 5280
      }
    ]
  },
  "[fth_i]": {
    "isBase": false,
    "CODE": "[FTH_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "fathom"
    ],
    "printSymbols": [
      "fth"
    ],
    "properties": [
      "depth of water"
    ],
    "values": [
      {
        "printable": "6",
        "numeric": 6
      }
    ]
  },
  "[nmi_i]": {
    "isBase": false,
    "CODE": "[NMI_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "nautical mile"
    ],
    "printSymbols": [
      "n.mi"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1852",
        "numeric": 1852
      }
    ]
  },
  "[kn_i]": {
    "isBase": false,
    "CODE": "[KN_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "knot"
    ],
    "printSymbols": [
      "knot"
    ],
    "properties": [
      "velocity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[sin_i]": {
    "isBase": false,
    "CODE": "[SIN_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "square inch"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[sft_i]": {
    "isBase": false,
    "CODE": "[SFT_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "square foot"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[syd_i]": {
    "isBase": false,
    "CODE": "[SYD_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "square yard"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[cin_i]": {
    "isBase": false,
    "CODE": "[CIN_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "cubic inch"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[cft_i]": {
    "isBase": false,
    "CODE": "[CFT_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "cubic foot"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[cyd_i]": {
    "isBase": false,
    "CODE": "[CYD_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "cubic yard"
    ],
    "printSymbols": [
      "cu.yd"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[bf_i]": {
    "isBase": false,
    "CODE": "[BF_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "board foot"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "144",
        "numeric": 144
      }
    ]
  },
  "[cr_i]": {
    "isBase": false,
    "CODE": "[CR_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "cord"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "128",
        "numeric": 128
      }
    ]
  },
  "[mil_i]": {
    "isBase": false,
    "CODE": "[MIL_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "mil"
    ],
    "printSymbols": [
      "mil"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-3</sup>",
        "numeric": 0.001
      }
    ]
  },
  "[cml_i]": {
    "isBase": false,
    "CODE": "[CML_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "circular mil"
    ],
    "printSymbols": [
      "circ.mil"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[hd_i]": {
    "isBase": false,
    "CODE": "[HD_I]",
    "isMetric": "no",
    "class": "intcust",
    "names": [
      "hand"
    ],
    "printSymbols": [
      "hd"
    ],
    "properties": [
      "height of horses"
    ],
    "values": [
      {
        "printable": "4",
        "numeric": 4
      }
    ]
  },
  "[ft_us]": {
    "isBase": false,
    "CODE": "[FT_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "foot"
    ],
    "printSymbols": [
      "ft<sub>us</sub>"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1200",
        "numeric": 1200
      }
    ]
  },
  "[yd_us]": {
    "isBase": false,
    "CODE": "[YD_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "yard"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "3",
        "numeric": 3
      }
    ]
  },
  "[in_us]": {
    "isBase": false,
    "CODE": "[IN_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "inch"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[rd_us]": {
    "isBase": false,
    "CODE": "[RD_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "rod"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "16.5",
        "numeric": 16.5
      }
    ]
  },
  "[ch_us]": {
    "isBase": false,
    "CODE": "[CH_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "Gunter's chain",
      "Surveyor's chain"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "4",
        "numeric": 4
      }
    ]
  },
  "[lk_us]": {
    "isBase": false,
    "CODE": "[LK_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "link for Gunter's chain"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[rch_us]": {
    "isBase": false,
    "CODE": "[RCH_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "Ramden's chain",
      "Engineer's chain"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "100",
        "numeric": 100
      }
    ]
  },
  "[rlk_us]": {
    "isBase": false,
    "CODE": "[RLK_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "link for Ramden's chain"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[fth_us]": {
    "isBase": false,
    "CODE": "[FTH_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "fathom"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "6",
        "numeric": 6
      }
    ]
  },
  "[fur_us]": {
    "isBase": false,
    "CODE": "[FUR_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "furlong"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "40",
        "numeric": 40
      }
    ]
  },
  "[mi_us]": {
    "isBase": false,
    "CODE": "[MI_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "mile"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "8",
        "numeric": 8
      }
    ]
  },
  "[acr_us]": {
    "isBase": false,
    "CODE": "[ACR_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "acre"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "160",
        "numeric": 160
      }
    ]
  },
  "[srd_us]": {
    "isBase": false,
    "CODE": "[SRD_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "square rod"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[smi_us]": {
    "isBase": false,
    "CODE": "[SMI_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "square mile"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[sct]": {
    "isBase": false,
    "CODE": "[SCT]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "section"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[twp]": {
    "isBase": false,
    "CODE": "[TWP]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "township"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "36",
        "numeric": 36
      }
    ]
  },
  "[mil_us]": {
    "isBase": false,
    "CODE": "[MIL_US]",
    "isMetric": "no",
    "class": "us-lengths",
    "names": [
      "mil"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1 &#215; 10<sup>-3</sup>",
        "numeric": 0.001
      }
    ]
  },
  "[in_br]": {
    "isBase": false,
    "CODE": "[IN_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "inch"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "2.539998",
        "numeric": 2.539998
      }
    ]
  },
  "[ft_br]": {
    "isBase": false,
    "CODE": "[FT_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "foot"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "12",
        "numeric": 12
      }
    ]
  },
  "[rd_br]": {
    "isBase": false,
    "CODE": "[RD_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "rod"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "16.5",
        "numeric": 16.5
      }
    ]
  },
  "[ch_br]": {
    "isBase": false,
    "CODE": "[CH_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "Gunter's chain"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "4",
        "numeric": 4
      }
    ]
  },
  "[lk_br]": {
    "isBase": false,
    "CODE": "[LK_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "link for Gunter's chain"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[fth_br]": {
    "isBase": false,
    "CODE": "[FTH_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "fathom"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "6",
        "numeric": 6
      }
    ]
  },
  "[pc_br]": {
    "isBase": false,
    "CODE": "[PC_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "pace"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "2.5",
        "numeric": 2.5
      }
    ]
  },
  "[yd_br]": {
    "isBase": false,
    "CODE": "[YD_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "yard"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "3",
        "numeric": 3
      }
    ]
  },
  "[mi_br]": {
    "isBase": false,
    "CODE": "[MI_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "mile"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "5280",
        "numeric": 5280
      }
    ]
  },
  "[nmi_br]": {
    "isBase": false,
    "CODE": "[NMI_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "nautical mile"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "6080",
        "numeric": 6080
      }
    ]
  },
  "[kn_br]": {
    "isBase": false,
    "CODE": "[KN_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "knot"
    ],
    "properties": [
      "velocity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[acr_br]": {
    "isBase": false,
    "CODE": "[ACR_BR]",
    "isMetric": "no",
    "class": "brit-length",
    "names": [
      "acre"
    ],
    "properties": [
      "area"
    ],
    "values": [
      {
        "printable": "4840",
        "numeric": 4840
      }
    ]
  },
  "[gal_us]": {
    "isBase": false,
    "CODE": "[GAL_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "Queen Anne's wine gallon"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "231",
        "numeric": 231
      }
    ]
  },
  "[bbl_us]": {
    "isBase": false,
    "CODE": "[BBL_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "barrel"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "42",
        "numeric": 42
      }
    ]
  },
  "[qt_us]": {
    "isBase": false,
    "CODE": "[QT_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "quart"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[pt_us]": {
    "isBase": false,
    "CODE": "[PT_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "pint"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[gil_us]": {
    "isBase": false,
    "CODE": "[GIL_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "gill"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[foz_us]": {
    "isBase": false,
    "CODE": "[FOZ_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "fluid ounce"
    ],
    "printSymbols": [
      "oz fl"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[fdr_us]": {
    "isBase": false,
    "CODE": "[FDR_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "fluid dram"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[min_us]": {
    "isBase": false,
    "CODE": "[MIN_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "minim"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[crd_us]": {
    "isBase": false,
    "CODE": "[CRD_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "cord"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "128",
        "numeric": 128
      }
    ]
  },
  "[bu_us]": {
    "isBase": false,
    "CODE": "[BU_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "bushel"
    ],
    "properties": [
      "dry volume"
    ],
    "values": [
      {
        "printable": "2150.42",
        "numeric": 2150.42
      }
    ]
  },
  "[gal_wi]": {
    "isBase": false,
    "CODE": "[GAL_WI]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "historical winchester gallon"
    ],
    "properties": [
      "dry volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[pk_us]": {
    "isBase": false,
    "CODE": "[PK_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "peck"
    ],
    "properties": [
      "dry volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[dqt_us]": {
    "isBase": false,
    "CODE": "[DQT_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "dry quart"
    ],
    "properties": [
      "dry volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[dpt_us]": {
    "isBase": false,
    "CODE": "[DPT_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "dry pint"
    ],
    "properties": [
      "dry volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[tbs_us]": {
    "isBase": false,
    "CODE": "[TBS_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "tablespoon"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[tsp_us]": {
    "isBase": false,
    "CODE": "[TSP_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "teaspoon"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[cup_us]": {
    "isBase": false,
    "CODE": "[CUP_US]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "cup"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "16",
        "numeric": 16
      }
    ]
  },
  "[foz_m]": {
    "isBase": false,
    "CODE": "[FOZ_M]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "metric fluid ounce"
    ],
    "printSymbols": [
      "oz fl"
    ],
    "properties": [
      "fluid volume"
    ],
    "values": [
      {
        "printable": "30",
        "numeric": 30
      }
    ]
  },
  "[cup_m]": {
    "isBase": false,
    "CODE": "[CUP_M]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "metric cup"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "240",
        "numeric": 240
      }
    ]
  },
  "[tsp_m]": {
    "isBase": false,
    "CODE": "[TSP_M]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "metric teaspoon"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "5",
        "numeric": 5
      }
    ]
  },
  "[tbs_m]": {
    "isBase": false,
    "CODE": "[TBS_M]",
    "isMetric": "no",
    "class": "us-volumes",
    "names": [
      "metric tablespoon"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "15",
        "numeric": 15
      }
    ]
  },
  "[gal_br]": {
    "isBase": false,
    "CODE": "[GAL_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "gallon"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "4.54609",
        "numeric": 4.54609
      }
    ]
  },
  "[pk_br]": {
    "isBase": false,
    "CODE": "[PK_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "peck"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "2",
        "numeric": 2
      }
    ]
  },
  "[bu_br]": {
    "isBase": false,
    "CODE": "[BU_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "bushel"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "4",
        "numeric": 4
      }
    ]
  },
  "[qt_br]": {
    "isBase": false,
    "CODE": "[QT_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "quart"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[pt_br]": {
    "isBase": false,
    "CODE": "[PT_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "pint"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[gil_br]": {
    "isBase": false,
    "CODE": "[GIL_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "gill"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[foz_br]": {
    "isBase": false,
    "CODE": "[FOZ_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "fluid ounce"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[fdr_br]": {
    "isBase": false,
    "CODE": "[FDR_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "fluid dram"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[min_br]": {
    "isBase": false,
    "CODE": "[MIN_BR]",
    "isMetric": "no",
    "class": "brit-volumes",
    "names": [
      "minim"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[gr]": {
    "isBase": false,
    "CODE": "[GR]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "grain"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "64.79891",
        "numeric": 64.79891
      }
    ]
  },
  "[lb_av]": {
    "isBase": false,
    "CODE": "[LB_AV]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "pound"
    ],
    "printSymbols": [
      "lb"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "7000",
        "numeric": 7000
      }
    ]
  },
  "[oz_av]": {
    "isBase": false,
    "CODE": "[OZ_AV]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "ounce"
    ],
    "printSymbols": [
      "oz"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[dr_av]": {
    "isBase": false,
    "CODE": "[DR_AV]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "dram"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[scwt_av]": {
    "isBase": false,
    "CODE": "[SCWT_AV]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "short hundredweight",
      "U.S. hundredweight"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "100",
        "numeric": 100
      }
    ]
  },
  "[lcwt_av]": {
    "isBase": false,
    "CODE": "[LCWT_AV]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "long hundredweight",
      "British hundredweight"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "112",
        "numeric": 112
      }
    ]
  },
  "[ston_av]": {
    "isBase": false,
    "CODE": "[STON_AV]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "short ton",
      "U.S. ton"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "20",
        "numeric": 20
      }
    ]
  },
  "[lton_av]": {
    "isBase": false,
    "CODE": "[LTON_AV]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "long ton",
      "British ton"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "20",
        "numeric": 20
      }
    ]
  },
  "[stone_av]": {
    "isBase": false,
    "CODE": "[STONE_AV]",
    "isMetric": "no",
    "class": "avoirdupois",
    "names": [
      "stone",
      "British stone"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "14",
        "numeric": 14
      }
    ]
  },
  "[pwt_tr]": {
    "isBase": false,
    "CODE": "[PWT_TR]",
    "isMetric": "no",
    "class": "troy",
    "names": [
      "pennyweight"
    ],
    "printSymbols": [
      "dwt"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "24",
        "numeric": 24
      }
    ]
  },
  "[oz_tr]": {
    "isBase": false,
    "CODE": "[OZ_TR]",
    "isMetric": "no",
    "class": "troy",
    "names": [
      "troy ounce"
    ],
    "printSymbols": [
      "oz t"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "20",
        "numeric": 20
      }
    ]
  },
  "[lb_tr]": {
    "isBase": false,
    "CODE": "[LB_TR]",
    "isMetric": "no",
    "class": "troy",
    "names": [
      "troy pound"
    ],
    "printSymbols": [
      "lb t"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "12",
        "numeric": 12
      }
    ]
  },
  "[sc_ap]": {
    "isBase": false,
    "CODE": "[SC_AP]",
    "isMetric": "no",
    "class": "apoth",
    "names": [
      "scruple"
    ],
    "printSymbols": [
      "&#8456;"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "20",
        "numeric": 20
      }
    ]
  },
  "[dr_ap]": {
    "isBase": false,
    "CODE": "[DR_AP]",
    "isMetric": "no",
    "class": "apoth",
    "names": [
      "dram",
      "drachm"
    ],
    "printSymbols": [
      "&#658;"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "3",
        "numeric": 3
      }
    ]
  },
  "[oz_ap]": {
    "isBase": false,
    "CODE": "[OZ_AP]",
    "isMetric": "no",
    "class": "apoth",
    "names": [
      "ounce"
    ],
    "printSymbols": [
      "&#8485;"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "8",
        "numeric": 8
      }
    ]
  },
  "[lb_ap]": {
    "isBase": false,
    "CODE": "[LB_AP]",
    "isMetric": "no",
    "class": "apoth",
    "names": [
      "pound"
    ],
    "printSymbols": [
      "<strike>lb</strike>"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "12",
        "numeric": 12
      }
    ]
  },
  "[oz_m]": {
    "isBase": false,
    "CODE": "[OZ_M]",
    "isMetric": "no",
    "class": "apoth",
    "names": [
      "metric ounce"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "28",
        "numeric": 28
      }
    ]
  },
  "[lne]": {
    "isBase": false,
    "CODE": "[LNE]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "line"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[pnt]": {
    "isBase": false,
    "CODE": "[PNT]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "point"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[pca]": {
    "isBase": false,
    "CODE": "[PCA]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "pica"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "12",
        "numeric": 12
      }
    ]
  },
  "[pnt_pr]": {
    "isBase": false,
    "CODE": "[PNT_PR]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "Printer's point"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "0.013837",
        "numeric": 0.013837
      }
    ]
  },
  "[pca_pr]": {
    "isBase": false,
    "CODE": "[PCA_PR]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "Printer's pica"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "12",
        "numeric": 12
      }
    ]
  },
  "[pied]": {
    "isBase": false,
    "CODE": "[PIED]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "pied",
      "French foot"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "32.48",
        "numeric": 32.48
      }
    ]
  },
  "[pouce]": {
    "isBase": false,
    "CODE": "[POUCE]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "pouce",
      "French inch"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[ligne]": {
    "isBase": false,
    "CODE": "[LIGNE]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "ligne",
      "French line"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[didot]": {
    "isBase": false,
    "CODE": "[DIDOT]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "didot",
      "Didot's point"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[cicero]": {
    "isBase": false,
    "CODE": "[CICERO]",
    "isMetric": "no",
    "class": "typeset",
    "names": [
      "cicero",
      "Didot's pica"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "12",
        "numeric": 12
      }
    ]
  },
  "[degF]": {
    "isBase": false,
    "CODE": "[DEGF]",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "heat",
    "names": [
      "degree Fahrenheit"
    ],
    "printSymbols": [
      "&#176;F"
    ],
    "properties": [
      "temperature"
    ],
    "values": [
      {
        "printable": "<function name=\"degF\" value=\"5\" Unit=\"K/9\"/>",
        "numeric": null
      }
    ]
  },
  "[degR]": {
    "isBase": false,
    "CODE": "[degR]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "degree Rankine"
    ],
    "printSymbols": [
      "&#176;R"
    ],
    "properties": [
      "temperature"
    ],
    "values": [
      {
        "printable": "5",
        "numeric": 5
      }
    ]
  },
  "cal_[15]": {
    "isBase": false,
    "CODE": "CAL_[15]",
    "isMetric": "yes",
    "class": "heat",
    "names": [
      "calorie at 15 °C"
    ],
    "printSymbols": [
      "cal<sub>15&#176;C</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "4.18580",
        "numeric": 4.1858
      }
    ]
  },
  "cal_[20]": {
    "isBase": false,
    "CODE": "CAL_[20]",
    "isMetric": "yes",
    "class": "heat",
    "names": [
      "calorie at 20 °C"
    ],
    "printSymbols": [
      "cal<sub>20&#176;C</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "4.18190",
        "numeric": 4.1819
      }
    ]
  },
  "cal_m": {
    "isBase": false,
    "CODE": "CAL_M",
    "isMetric": "yes",
    "class": "heat",
    "names": [
      "mean calorie"
    ],
    "printSymbols": [
      "cal<sub>m</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "4.19002",
        "numeric": 4.19002
      }
    ]
  },
  "cal_IT": {
    "isBase": false,
    "CODE": "CAL_IT",
    "isMetric": "yes",
    "class": "heat",
    "names": [
      "international table calorie"
    ],
    "printSymbols": [
      "cal<sub>IT</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "4.1868",
        "numeric": 4.1868
      }
    ]
  },
  "cal_th": {
    "isBase": false,
    "CODE": "CAL_TH",
    "isMetric": "yes",
    "class": "heat",
    "names": [
      "thermochemical calorie"
    ],
    "printSymbols": [
      "cal<sub>th</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "4.184",
        "numeric": 4.184
      }
    ]
  },
  "cal": {
    "isBase": false,
    "CODE": "CAL",
    "isMetric": "yes",
    "class": "heat",
    "names": [
      "calorie"
    ],
    "printSymbols": [
      "cal"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[Cal]": {
    "isBase": false,
    "CODE": "[CAL]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "nutrition label Calories"
    ],
    "printSymbols": [
      "Cal"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[Btu_39]": {
    "isBase": false,
    "CODE": "[BTU_39]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "British thermal unit at 39 °F"
    ],
    "printSymbols": [
      "Btu<sub>39&#176;F</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1.05967",
        "numeric": 1.05967
      }
    ]
  },
  "[Btu_59]": {
    "isBase": false,
    "CODE": "[BTU_59]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "British thermal unit at 59 °F"
    ],
    "printSymbols": [
      "Btu<sub>59&#176;F</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1.05480",
        "numeric": 1.0548
      }
    ]
  },
  "[Btu_60]": {
    "isBase": false,
    "CODE": "[BTU_60]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "British thermal unit at 60 °F"
    ],
    "printSymbols": [
      "Btu<sub>60&#176;F</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1.05468",
        "numeric": 1.05468
      }
    ]
  },
  "[Btu_m]": {
    "isBase": false,
    "CODE": "[BTU_M]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "mean British thermal unit"
    ],
    "printSymbols": [
      "Btu<sub>m</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1.05587",
        "numeric": 1.05587
      }
    ]
  },
  "[Btu_IT]": {
    "isBase": false,
    "CODE": "[BTU_IT]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "international table British thermal unit"
    ],
    "printSymbols": [
      "Btu<sub>IT</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1.05505585262",
        "numeric": 1.05505585262
      }
    ]
  },
  "[Btu_th]": {
    "isBase": false,
    "CODE": "[BTU_TH]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "thermochemical British thermal unit"
    ],
    "printSymbols": [
      "Btu<sub>th</sub>"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1.054350",
        "numeric": 1.05435
      }
    ]
  },
  "[Btu]": {
    "isBase": false,
    "CODE": "[BTU]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "British thermal unit"
    ],
    "printSymbols": [
      "btu"
    ],
    "properties": [
      "energy"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[HP]": {
    "isBase": false,
    "CODE": "[HP]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "horsepower"
    ],
    "properties": [
      "power"
    ],
    "values": [
      {
        "printable": "550",
        "numeric": 550
      }
    ]
  },
  "tex": {
    "isBase": false,
    "CODE": "TEX",
    "isMetric": "yes",
    "class": "heat",
    "names": [
      "tex"
    ],
    "printSymbols": [
      "tex"
    ],
    "properties": [
      "linear mass density (of textile thread)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[den]": {
    "isBase": false,
    "CODE": "[DEN]",
    "isMetric": "no",
    "class": "heat",
    "names": [
      "Denier"
    ],
    "printSymbols": [
      "den"
    ],
    "properties": [
      "linear mass density (of textile thread)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "m[H2O]": {
    "isBase": false,
    "CODE": "M[H2O]",
    "isMetric": "yes",
    "class": "clinical",
    "names": [
      "meter of water column"
    ],
    "printSymbols": [
      "m&#160;H<sub>\n            <r>2</r>\n         </sub>O"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "9.80665",
        "numeric": 9.80665
      }
    ]
  },
  "m[Hg]": {
    "isBase": false,
    "CODE": "M[HG]",
    "isMetric": "yes",
    "class": "clinical",
    "names": [
      "meter of mercury column"
    ],
    "printSymbols": [
      "m&#160;Hg"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "133.3220",
        "numeric": 133.322
      }
    ]
  },
  "[in_i'H2O]": {
    "isBase": false,
    "CODE": "[IN_I'H2O]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "inch of water column"
    ],
    "printSymbols": [
      "in&#160;H<sub>\n            <r>2</r>\n         </sub>O"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[in_i'Hg]": {
    "isBase": false,
    "CODE": "[IN_I'HG]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "inch of mercury column"
    ],
    "printSymbols": [
      "in&#160;Hg"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[PRU]": {
    "isBase": false,
    "CODE": "[PRU]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "peripheral vascular resistance unit"
    ],
    "printSymbols": [
      "P.R.U."
    ],
    "properties": [
      "fluid resistance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[wood'U]": {
    "isBase": false,
    "CODE": "[WOOD'U]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "Wood unit"
    ],
    "printSymbols": [
      "Wood U."
    ],
    "properties": [
      "fluid resistance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[diop]": {
    "isBase": false,
    "CODE": "[DIOP]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "diopter"
    ],
    "printSymbols": [
      "dpt"
    ],
    "properties": [
      "refraction of a lens"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[p'diop]": {
    "isBase": false,
    "CODE": "[P'DIOP]",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "clinical",
    "names": [
      "prism diopter"
    ],
    "printSymbols": [
      "PD"
    ],
    "properties": [
      "refraction of a prism"
    ],
    "values": [
      {
        "printable": "<function name=\"tanTimes100\" value=\"1\" Unit=\"deg\"/>",
        "numeric": null
      }
    ]
  },
  "%[slope]": {
    "isBase": false,
    "CODE": "%[SLOPE]",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "clinical",
    "names": [
      "percent of slope"
    ],
    "printSymbols": [
      "%"
    ],
    "properties": [
      "slope"
    ],
    "values": [
      {
        "printable": "<function name=\"100tan\" value=\"1\" Unit=\"deg\"/>",
        "numeric": null
      }
    ]
  },
  "[mesh_i]": {
    "isBase": false,
    "CODE": "[MESH_I]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "mesh"
    ],
    "properties": [
      "lineic number"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[Ch]": {
    "isBase": false,
    "CODE": "[CH]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "Charrière",
      "french"
    ],
    "printSymbols": [
      "Ch"
    ],
    "properties": [
      "gauge of catheters"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[drp]": {
    "isBase": false,
    "CODE": "[DRP]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "drop"
    ],
    "printSymbols": [
      "drp"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[hnsf'U]": {
    "isBase": false,
    "CODE": "[HNSF'U]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "Hounsfield unit"
    ],
    "printSymbols": [
      "HF"
    ],
    "properties": [
      "x-ray attenuation"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[MET]": {
    "isBase": false,
    "CODE": "[MET]",
    "isMetric": "no",
    "class": "clinical",
    "names": [
      "metabolic equivalent"
    ],
    "printSymbols": [
      "MET"
    ],
    "properties": [
      "metabolic cost of physical activity"
    ],
    "values": [
      {
        "printable": "3.5",
        "numeric": 3.5
      }
    ]
  },
  "[hp'_X]": {
    "isBase": false,
    "CODE": "[HP'_X]",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of decimal series (retired)"
    ],
    "printSymbols": [
      "X"
    ],
    "properties": [
      "homeopathic potency (retired)"
    ],
    "values": [
      {
        "printable": "<function name=\"hpX\" value=\"1\" Unit=\"1\"/>",
        "numeric": null
      }
    ]
  },
  "[hp'_C]": {
    "isBase": false,
    "CODE": "[HP'_C]",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of centesimal series (retired)"
    ],
    "printSymbols": [
      "C"
    ],
    "properties": [
      "homeopathic potency (retired)"
    ],
    "values": [
      {
        "printable": "<function name=\"hpC\" value=\"1\" Unit=\"1\"/>",
        "numeric": null
      }
    ]
  },
  "[hp'_M]": {
    "isBase": false,
    "CODE": "[HP'_M]",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of millesimal series (retired)"
    ],
    "printSymbols": [
      "M"
    ],
    "properties": [
      "homeopathic potency (retired)"
    ],
    "values": [
      {
        "printable": "<function name=\"hpM\" value=\"1\" Unit=\"1\"/>",
        "numeric": null
      }
    ]
  },
  "[hp'_Q]": {
    "isBase": false,
    "CODE": "[HP'_Q]",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of quintamillesimal series (retired)"
    ],
    "printSymbols": [
      "Q"
    ],
    "properties": [
      "homeopathic potency (retired)"
    ],
    "values": [
      {
        "printable": "<function name=\"hpQ\" value=\"1\" Unit=\"1\"/>",
        "numeric": null
      }
    ]
  },
  "[hp_X]": {
    "isBase": false,
    "CODE": "[HP_X]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of decimal hahnemannian series"
    ],
    "printSymbols": [
      "X"
    ],
    "properties": [
      "homeopathic potency (Hahnemann)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[hp_C]": {
    "isBase": false,
    "CODE": "[HP_C]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of centesimal hahnemannian series"
    ],
    "printSymbols": [
      "C"
    ],
    "properties": [
      "homeopathic potency (Hahnemann)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[hp_M]": {
    "isBase": false,
    "CODE": "[HP_M]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of millesimal hahnemannian series"
    ],
    "printSymbols": [
      "M"
    ],
    "properties": [
      "homeopathic potency (Hahnemann)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[hp_Q]": {
    "isBase": false,
    "CODE": "[HP_Q]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of quintamillesimal hahnemannian series"
    ],
    "printSymbols": [
      "Q"
    ],
    "properties": [
      "homeopathic potency (Hahnemann)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[kp_X]": {
    "isBase": false,
    "CODE": "[KP_X]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of decimal korsakovian series"
    ],
    "printSymbols": [
      "X"
    ],
    "properties": [
      "homeopathic potency (Korsakov)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[kp_C]": {
    "isBase": false,
    "CODE": "[KP_C]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of centesimal korsakovian series"
    ],
    "printSymbols": [
      "C"
    ],
    "properties": [
      "homeopathic potency (Korsakov)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[kp_M]": {
    "isBase": false,
    "CODE": "[KP_M]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of millesimal korsakovian series"
    ],
    "printSymbols": [
      "M"
    ],
    "properties": [
      "homeopathic potency (Korsakov)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[kp_Q]": {
    "isBase": false,
    "CODE": "[KP_Q]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "clinical",
    "names": [
      "homeopathic potency of quintamillesimal korsakovian series"
    ],
    "printSymbols": [
      "Q"
    ],
    "properties": [
      "homeopathic potency (Korsakov)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "eq": {
    "isBase": false,
    "CODE": "EQ",
    "isMetric": "yes",
    "class": "chemical",
    "names": [
      "equivalents"
    ],
    "printSymbols": [
      "eq"
    ],
    "properties": [
      "amount of substance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "osm": {
    "isBase": false,
    "CODE": "OSM",
    "isMetric": "yes",
    "class": "chemical",
    "names": [
      "osmole"
    ],
    "printSymbols": [
      "osm"
    ],
    "properties": [
      "amount of substance (dissolved particles)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[pH]": {
    "isBase": false,
    "CODE": "[PH]",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "chemical",
    "names": [
      "pH"
    ],
    "printSymbols": [
      "pH"
    ],
    "properties": [
      "acidity"
    ],
    "values": [
      {
        "printable": "<function name=\"pH\" value=\"1\" Unit=\"mol/l\"/>",
        "numeric": null
      }
    ]
  },
  "g%": {
    "isBase": false,
    "CODE": "G%",
    "isMetric": "yes",
    "class": "chemical",
    "names": [
      "gram percent"
    ],
    "printSymbols": [
      "g%"
    ],
    "properties": [
      "mass concentration"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[S]": {
    "isBase": false,
    "CODE": "[S]",
    "isMetric": "no",
    "class": "chemical",
    "names": [
      "Svedberg unit"
    ],
    "printSymbols": [
      "S"
    ],
    "properties": [
      "sedimentation coefficient"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[HPF]": {
    "isBase": false,
    "CODE": "[HPF]",
    "isMetric": "no",
    "class": "chemical",
    "names": [
      "high power field"
    ],
    "printSymbols": [
      "HPF"
    ],
    "properties": [
      "view area in microscope"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[LPF]": {
    "isBase": false,
    "CODE": "[LPF]",
    "isMetric": "no",
    "class": "chemical",
    "names": [
      "low power field"
    ],
    "printSymbols": [
      "LPF"
    ],
    "properties": [
      "view area in microscope"
    ],
    "values": [
      {
        "printable": "100",
        "numeric": 100
      }
    ]
  },
  "kat": {
    "isBase": false,
    "CODE": "KAT",
    "isMetric": "yes",
    "class": "chemical",
    "names": [
      "katal"
    ],
    "printSymbols": [
      "kat"
    ],
    "properties": [
      "catalytic activity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "U": {
    "isBase": false,
    "CODE": "U",
    "isMetric": "yes",
    "class": "chemical",
    "names": [
      "Unit"
    ],
    "printSymbols": [
      "U"
    ],
    "properties": [
      "catalytic activity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[iU]": {
    "isBase": false,
    "CODE": "[IU]",
    "isMetric": "yes",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "international unit"
    ],
    "printSymbols": [
      "IU"
    ],
    "properties": [
      "arbitrary"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[IU]": {
    "isBase": false,
    "CODE": "[IU]",
    "isMetric": "yes",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "international unit"
    ],
    "printSymbols": [
      "i.U."
    ],
    "properties": [
      "arbitrary"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[arb'U]": {
    "isBase": false,
    "CODE": "[ARB'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "arbitary unit"
    ],
    "printSymbols": [
      "arb. U"
    ],
    "properties": [
      "arbitrary"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[USP'U]": {
    "isBase": false,
    "CODE": "[USP'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "United States Pharmacopeia unit"
    ],
    "printSymbols": [
      "U.S.P."
    ],
    "properties": [
      "arbitrary"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[GPL'U]": {
    "isBase": false,
    "CODE": "[GPL'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "GPL unit"
    ],
    "properties": [
      "biologic activity of anticardiolipin IgG"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[MPL'U]": {
    "isBase": false,
    "CODE": "[MPL'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "MPL unit"
    ],
    "properties": [
      "biologic activity of anticardiolipin IgM"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[APL'U]": {
    "isBase": false,
    "CODE": "[APL'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "APL unit"
    ],
    "properties": [
      "biologic activity of anticardiolipin IgA"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[beth'U]": {
    "isBase": false,
    "CODE": "[BETH'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Bethesda unit"
    ],
    "properties": [
      "biologic activity of factor VIII inhibitor"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[anti'Xa'U]": {
    "isBase": false,
    "CODE": "[ANTI'XA'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "anti factor Xa unit"
    ],
    "properties": [
      "biologic activity of factor Xa inhibitor (heparin)"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[todd'U]": {
    "isBase": false,
    "CODE": "[TODD'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Todd unit"
    ],
    "properties": [
      "biologic activity antistreptolysin O"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[dye'U]": {
    "isBase": false,
    "CODE": "[DYE'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Dye unit"
    ],
    "properties": [
      "biologic activity of amylase"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[smgy'U]": {
    "isBase": false,
    "CODE": "[SMGY'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Somogyi unit"
    ],
    "properties": [
      "biologic activity of amylase"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[bdsk'U]": {
    "isBase": false,
    "CODE": "[BDSK'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Bodansky unit"
    ],
    "properties": [
      "biologic activity of phosphatase"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[ka'U]": {
    "isBase": false,
    "CODE": "[KA'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "King-Armstrong unit"
    ],
    "properties": [
      "biologic activity of phosphatase"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[knk'U]": {
    "isBase": false,
    "CODE": "[KNK'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Kunkel unit"
    ],
    "properties": [
      "arbitrary biologic activity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[mclg'U]": {
    "isBase": false,
    "CODE": "[MCLG'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Mac Lagan unit"
    ],
    "properties": [
      "arbitrary biologic activity"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[tb'U]": {
    "isBase": false,
    "CODE": "[TB'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "tuberculin unit"
    ],
    "properties": [
      "biologic activity of tuberculin"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[CCID_50]": {
    "isBase": false,
    "CODE": "[CCID_50]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "50% cell culture infectious dose"
    ],
    "printSymbols": [
      "CCID<sub>50</sub>"
    ],
    "properties": [
      "biologic activity (infectivity) of an infectious agent preparation"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[TCID_50]": {
    "isBase": false,
    "CODE": "[TCID_50]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "50% tissue culture infectious dose"
    ],
    "printSymbols": [
      "TCID<sub>50</sub>"
    ],
    "properties": [
      "biologic activity (infectivity) of an infectious agent preparation"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[EID_50]": {
    "isBase": false,
    "CODE": "[EID_50]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "50% embryo infectious dose"
    ],
    "printSymbols": [
      "EID<sub>50</sub>"
    ],
    "properties": [
      "biologic activity (infectivity) of an infectious agent preparation"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[PFU]": {
    "isBase": false,
    "CODE": "[PFU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "plaque forming units"
    ],
    "printSymbols": [
      "PFU"
    ],
    "properties": [
      "amount of an infectious agent"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[FFU]": {
    "isBase": false,
    "CODE": "[FFU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "focus forming units"
    ],
    "printSymbols": [
      "FFU"
    ],
    "properties": [
      "amount of an infectious agent"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[CFU]": {
    "isBase": false,
    "CODE": "[CFU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "colony forming units"
    ],
    "printSymbols": [
      "CFU"
    ],
    "properties": [
      "amount of a proliferating organism"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[BAU]": {
    "isBase": false,
    "CODE": "[BAU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "bioequivalent allergen unit"
    ],
    "printSymbols": [
      "BAU"
    ],
    "properties": [
      "amount of an allergen callibrated through in-vivo testing based on the ID50EAL method of (intradermal dilution for 50mm sum of erythema diameters"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[AU]": {
    "isBase": false,
    "CODE": "[AU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "allergen unit"
    ],
    "printSymbols": [
      "AU"
    ],
    "properties": [
      "procedure defined amount of an allergen using some reference standard"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[Amb'a'1'U]": {
    "isBase": false,
    "CODE": "[AMB'A'1'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "allergen unit for Ambrosia artemisiifolia"
    ],
    "printSymbols": [
      "Amb a 1 U"
    ],
    "properties": [
      "procedure defined amount of the major allergen of ragweed."
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[PNU]": {
    "isBase": false,
    "CODE": "[PNU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "protein nitrogen unit"
    ],
    "printSymbols": [
      "PNU"
    ],
    "properties": [
      "procedure defined amount of a protein substance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[Lf]": {
    "isBase": false,
    "CODE": "[LF]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Limit of flocculation"
    ],
    "printSymbols": [
      "Lf"
    ],
    "properties": [
      "procedure defined amount of an antigen substance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[D'ag'U]": {
    "isBase": false,
    "CODE": "[D'AG'U]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "D-antigen unit"
    ],
    "printSymbols": [
      ""
    ],
    "properties": [
      "procedure defined amount of a poliomyelitis d-antigen substance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[FEU]": {
    "isBase": false,
    "CODE": "[FEU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "fibrinogen equivalent unit"
    ],
    "printSymbols": [
      ""
    ],
    "properties": [
      "amount of fibrinogen broken down into the measured d-dimers"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[ELU]": {
    "isBase": false,
    "CODE": "[ELU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "ELISA unit"
    ],
    "printSymbols": [
      ""
    ],
    "properties": [
      "arbitrary ELISA unit"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[EU]": {
    "isBase": false,
    "CODE": "[EU]",
    "isMetric": "no",
    "isArbitrary": "yes",
    "class": "chemical",
    "names": [
      "Ehrlich unit"
    ],
    "printSymbols": [
      ""
    ],
    "properties": [
      "Ehrlich unit"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Np": {
    "isBase": false,
    "CODE": "NEP",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "neper"
    ],
    "printSymbols": [
      "Np"
    ],
    "properties": [
      "level"
    ],
    "values": [
      {
        "printable": "<function name=\"ln\" value=\"1\" Unit=\"1\"/>",
        "numeric": null
      }
    ]
  },
  "B": {
    "isBase": false,
    "CODE": "B",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "bel"
    ],
    "printSymbols": [
      "B"
    ],
    "properties": [
      "level"
    ],
    "values": [
      {
        "printable": "<function name=\"lg\" value=\"1\" Unit=\"1\"/>",
        "numeric": null
      }
    ]
  },
  "B[SPL]": {
    "isBase": false,
    "CODE": "B[SPL]",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "bel sound pressure"
    ],
    "printSymbols": [
      "B(SPL)"
    ],
    "properties": [
      "pressure level"
    ],
    "values": [
      {
        "printable": "<function name=\"lgTimes2\" value=\"2\" Unit=\"10*-5.Pa\"/>",
        "numeric": null
      }
    ]
  },
  "B[V]": {
    "isBase": false,
    "CODE": "B[V]",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "bel volt"
    ],
    "printSymbols": [
      "B(V)"
    ],
    "properties": [
      "electric potential level"
    ],
    "values": [
      {
        "printable": "<function name=\"lgTimes2\" value=\"1\" Unit=\"V\"/>",
        "numeric": null
      }
    ]
  },
  "B[mV]": {
    "isBase": false,
    "CODE": "B[MV]",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "bel millivolt"
    ],
    "printSymbols": [
      "B(mV)"
    ],
    "properties": [
      "electric potential level"
    ],
    "values": [
      {
        "printable": "<function name=\"lgTimes2\" value=\"1\" Unit=\"mV\"/>",
        "numeric": null
      }
    ]
  },
  "B[uV]": {
    "isBase": false,
    "CODE": "B[UV]",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "bel microvolt"
    ],
    "printSymbols": [
      "B(&#956;V)"
    ],
    "properties": [
      "electric potential level"
    ],
    "values": [
      {
        "printable": "<function name=\"lgTimes2\" value=\"1\" Unit=\"uV\"/>",
        "numeric": null
      }
    ]
  },
  "B[10.nV]": {
    "isBase": false,
    "CODE": "B[10.NV]",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "bel 10 nanovolt"
    ],
    "printSymbols": [
      "B(10 nV)"
    ],
    "properties": [
      "electric potential level"
    ],
    "values": [
      {
        "printable": "<function name=\"lgTimes2\" value=\"10\" Unit=\"nV\"/>",
        "numeric": null
      }
    ]
  },
  "B[W]": {
    "isBase": false,
    "CODE": "B[W]",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "bel watt"
    ],
    "printSymbols": [
      "B(W)"
    ],
    "properties": [
      "power level"
    ],
    "values": [
      {
        "printable": "<function name=\"lg\" value=\"1\" Unit=\"W\"/>",
        "numeric": null
      }
    ]
  },
  "B[kW]": {
    "isBase": false,
    "CODE": "B[KW]",
    "isMetric": "yes",
    "isSpecial": "yes",
    "class": "levels",
    "names": [
      "bel kilowatt"
    ],
    "printSymbols": [
      "B(kW)"
    ],
    "properties": [
      "power level"
    ],
    "values": [
      {
        "printable": "<function name=\"lg\" value=\"1\" Unit=\"kW\"/>",
        "numeric": null
      }
    ]
  },
  "st": {
    "isBase": false,
    "CODE": "STR",
    "isMetric": "yes",
    "class": "misc",
    "names": [
      "stere"
    ],
    "printSymbols": [
      "st"
    ],
    "properties": [
      "volume"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "Ao": {
    "isBase": false,
    "CODE": "AO",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "Ångström"
    ],
    "printSymbols": [
      "&#197;"
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "0.1",
        "numeric": 0.1
      }
    ]
  },
  "b": {
    "isBase": false,
    "CODE": "BRN",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "barn"
    ],
    "printSymbols": [
      "b"
    ],
    "properties": [
      "action area"
    ],
    "values": [
      {
        "printable": "100",
        "numeric": 100
      }
    ]
  },
  "att": {
    "isBase": false,
    "CODE": "ATT",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "technical atmosphere"
    ],
    "printSymbols": [
      "at"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "mho": {
    "isBase": false,
    "CODE": "MHO",
    "isMetric": "yes",
    "class": "misc",
    "names": [
      "mho"
    ],
    "printSymbols": [
      "mho"
    ],
    "properties": [
      "electric conductance"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[psi]": {
    "isBase": false,
    "CODE": "[PSI]",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "pound per sqare inch"
    ],
    "printSymbols": [
      "psi"
    ],
    "properties": [
      "pressure"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "circ": {
    "isBase": false,
    "CODE": "CIRC",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "circle"
    ],
    "printSymbols": [
      "circ"
    ],
    "properties": [
      "plane angle"
    ],
    "values": [
      {
        "printable": "2",
        "numeric": 2
      }
    ]
  },
  "sph": {
    "isBase": false,
    "CODE": "SPH",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "spere"
    ],
    "printSymbols": [
      "sph"
    ],
    "properties": [
      "solid angle"
    ],
    "values": [
      {
        "printable": "4",
        "numeric": 4
      }
    ]
  },
  "[car_m]": {
    "isBase": false,
    "CODE": "[CAR_M]",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "metric carat"
    ],
    "printSymbols": [
      "ct<sub>m</sub>"
    ],
    "properties": [
      "mass"
    ],
    "values": [
      {
        "printable": "0.2",
        "numeric": 0.2
      }
    ]
  },
  "[car_Au]": {
    "isBase": false,
    "CODE": "[CAR_AU]",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "carat of gold alloys"
    ],
    "printSymbols": [
      "ct<sub>\n            <r>Au</r>\n         </sub>"
    ],
    "properties": [
      "mass fraction"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "[smoot]": {
    "isBase": false,
    "CODE": "[SMOOT]",
    "isMetric": "no",
    "class": "misc",
    "names": [
      "Smoot"
    ],
    "printSymbols": [
      ""
    ],
    "properties": [
      "length"
    ],
    "values": [
      {
        "printable": "67",
        "numeric": 67
      }
    ]
  },
  "bit_s": {
    "isBase": false,
    "CODE": "BIT_S",
    "isMetric": "no",
    "isSpecial": "yes",
    "class": "infotech",
    "names": [
      "bit"
    ],
    "printSymbols": [
      "bit<sub>s</sub>"
    ],
    "properties": [
      "amount of information"
    ],
    "values": [
      {
        "printable": "<function name=\"ld\" value=\"1\" Unit=\"1\"/>",
        "numeric": null
      }
    ]
  },
  "bit": {
    "isBase": false,
    "CODE": "BIT",
    "isMetric": "yes",
    "class": "infotech",
    "names": [
      "bit"
    ],
    "printSymbols": [
      "bit"
    ],
    "properties": [
      "amount of information"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "By": {
    "isBase": false,
    "CODE": "BY",
    "isMetric": "yes",
    "class": "infotech",
    "names": [
      "byte"
    ],
    "printSymbols": [
      "B"
    ],
    "properties": [
      "amount of information"
    ],
    "values": [
      {
        "printable": "8",
        "numeric": 8
      }
    ]
  },
  "Bd": {
    "isBase": false,
    "CODE": "BD",
    "isMetric": "yes",
    "class": "infotech",
    "names": [
      "baud"
    ],
    "printSymbols": [
      "Bd"
    ],
    "properties": [
      "signal transmission rate"
    ],
    "values": [
      {
        "printable": "1",
        "numeric": 1
      }
    ]
  },
  "m": {
    "isBase": true,
    "CODE": "M",
    "dim": "L",
    "names": [
      "meter"
    ],
    "printSymbols": [
      "m"
    ],
    "properties": [
      "length"
    ]
  },
  "s": {
    "isBase": true,
    "CODE": "S",
    "dim": "T",
    "names": [
      "second"
    ],
    "printSymbols": [
      "s"
    ],
    "properties": [
      "time"
    ]
  },
  "g": {
    "isBase": true,
    "CODE": "G",
    "dim": "M",
    "names": [
      "gram"
    ],
    "printSymbols": [
      "g"
    ],
    "properties": [
      "mass"
    ]
  },
  "rad": {
    "isBase": true,
    "CODE": "RAD",
    "dim": "A",
    "names": [
      "radian"
    ],
    "printSymbols": [
      "rad"
    ],
    "properties": [
      "plane angle"
    ]
  },
  "K": {
    "isBase": true,
    "CODE": "K",
    "dim": "C",
    "names": [
      "Kelvin"
    ],
    "printSymbols": [
      "K"
    ],
    "properties": [
      "temperature"
    ]
  },
  "C": {
    "isBase": true,
    "CODE": "C",
    "dim": "Q",
    "names": [
      "Coulomb"
    ],
    "printSymbols": [
      "C"
    ],
    "properties": [
      "electric charge"
    ]
  },
  "cd": {
    "isBase": true,
    "CODE": "CD",
    "dim": "F",
    "names": [
      "candela"
    ],
    "printSymbols": [
      "cd"
    ],
    "properties": [
      "luminous intensity"
    ]
  }
}

},{}],56:[function(require,module,exports){
module.exports = {

  multiply: function multiply(t, ms) {
    //console.log("Multiply: ", JSON.stringify(t), JSON.stringify(ms));
    if (ms.length == 0) return t;

    var ret = t;
    ms.forEach(function (mterm) {

      var sign = mterm[0] == "." ? 1 : -1;
      var b = mterm[1];

      ret.value *= Math.pow(b.value, sign);
      //console.log("b = ", JSON.stringify(b));
      //console.log("ret = ", JSON.stringify(ret));
      Object.keys(b.units).forEach(function (u) {
        ret.units[u] = ret.units[u] || 0;
        ret.units[u] = ret.units[u] + sign * b.units[u];

        if (!ret.metadata && b.metadata) {
          ret.metadata = {};
          ret.metadata[u] = b.metadata[u];
        } else if (ret.metadata && b.metadata) {
          ret.metadata[u] = b.metadata[u];
        }

        if (ret.units[u] == 0) {
          delete ret.units[u];
          if (ret.metadata) {
            delete ret.metadata[u];
          }
        }
      });
    });

    //console.log("Multiply ret: ", ret);
    return ret;
  },

  topower: function topower(e, exp) {
    if (!exp) {
      exp = 1;
    }
    var ret = e;
    ret.value = Math.pow(ret.value, exp);
    Object.keys(e.units).forEach(function (u) {
      ret.units[u] = e.units[u] * exp;
    });

    return ret;
  },

  cleanup: function cleanup(e) {
    ["10^", "10*"].forEach(function (k) {
      if (e.units[k]) {
        e.value *= Math.pow(10, e.units[k]);
        delete e.units[k];
      }
    });
    return e;
  },

  ismetric: function (metrics) {
    return function (u) {
      return metrics[Object.keys(u.units)[0]] !== undefined;
    };
  }
};

},{}],57:[function(require,module,exports){
parser = require('./generated/ucum-parser.js');
equivalents = require('./generated/equivalents.json');
helpers = require('./lib/helpers.js');
unitMetadata = require('./generated/unitMetadata.json');

module.exports = {
  parse: parse,
  canonicalize: canonicalize,
  convert: convert,
  format: format,
  unitQuery: unitQuery
};

function parse(value, units) {

  if (arguments.length === 1 || units === undefined) {
    units = value;
    value = 1;
  }

  if (units.match(/^\//)) {
    units = '1' + units;
  }

  if (units === '') units = '1';

  var ret = parser.parse(units);
  ret.value *= value;
  return ret;
}

function nonBaseUnit(u) {
  return equivalents[u] !== undefined;
}

function remainingNonBaseUnits(value) {
  return Object.keys(value.units).filter(nonBaseUnit);
}

function canonicalize(value, units) {

  value = parse(value, units);

  var remaining = remainingNonBaseUnits(value);

  while (remaining.length) {
    if (remaining.length === 0) {
      return false;
    }

    remaining.forEach(function (u) {
      var sub = parse(equivalents[u].ucum);
      sub.value *= equivalents[u].value;
      sub = helpers.topower(sub, value.units[u]);
      value = helpers.multiply(value, [['.', sub]]);
      delete value.units[u];
    });

    remaining = remainingNonBaseUnits(value);
  }

  // we should remove any prefix metadata that exists at this point
  // because it represents residual artifacts of the above process
  if (value.metadata) {
    Object.keys(value.metadata).forEach(function (u) {
      if (value.metadata[u]) {
        if (value.metadata[u].prefix) {
          delete value.metadata[u].prefix;
        }

        // if it's not in the final array of units we should delete this metadata as well
        if (Object.keys(value.units).indexOf(u) == -1) {
          delete value.metadata[u];
        }
      }
    });
  }

  return value;
}

function conformant(a, b) {
  var ret = true;
  Object.keys(a.units).concat(Object.keys(b.units)).forEach(function (k) {
    if (a.units[k] !== b.units[k]) {
      ret = false;
    }
  });

  return ret;
}

function convert(fromValue, fromUnits, toUnits) {
  fromc = canonicalize(fromValue, fromUnits);
  toc = canonicalize(toUnits);

  if (!conformant(fromc, toc)) {
    throw "Non-conformant units; can't convert from " + fromUnits + " to " + toUnits;
  }

  return fromc.value / toc.value;
}

// format returns a printable representation of the value
// the resulting units are a single-line html rendering of the resultant units
// can be invoked in the following supported ways, by example:
// 1. ucum.format('[in_i]') -> 'in'
// 2. ucum.format('[in_i]', true) -> '1 in'
// 3. ucum.format(3, '[in_i]', true) -> '3 in'
// 4. var x = ucum.parse(3, '[in_i]'); ucum.format(x) -> 'in'
// 5. var x = ucum.parse(3, '[in_i]'); ucum.format(x, true) -> '3 in'
function format(value, units, includeValue) {
  var obj;

  if (typeof value === 'string') {
    includeValue = units;
    units = value;
    value = 1;
  }

  if (typeof value === 'object') {
    // treat it like a UCUM parse output
    obj = value;
    includeValue = units; // you would never provide units in this case, but you might provide includeValue
  } else {
    // parse it first
    obj = parse(value, units);
  }

  var units = Object.keys(obj.units);
  var metadata = obj.metadata;
  var numUnits = units.length;
  var numeratorUnits = [];
  var denominatorUnits = [];
  var printableUnits = "";

  units.forEach(function (unit, index) {
    var exponent = obj.units[unit];
    var absExponent = Math.abs(exponent);
    var printable = metadata[unit].printSymbols ? metadata[unit].printSymbols[0] : metadata[unit].names[0];
    var prefix = metadata[unit].prefix ? metadata[unit].prefix.printSymbols[0] : "";
    pUnit = prefix + printable;
    if (absExponent !== 1) {
      pUnit += "<sup>";
      pUnit += Math.abs(exponent);
      pUnit += "</sup>";
    }

    if (exponent > 0) {
      numeratorUnits.push(pUnit);
    } else {
      denominatorUnits.push(pUnit);
    }
  });

  if (numeratorUnits.length == 0) {
    printableUnits = "1";
  } else if (numeratorUnits.length > 0) {
    printableUnits = numeratorUnits.join("*");
  }

  if (denominatorUnits.length > 0) {
    printableUnits += "/";
  }

  printableUnits += denominatorUnits.join("/");

  if (includeValue) {
    printableUnits = obj.value + " " + printableUnits;
  }

  return printableUnits;
}

// searches the unit metadata for all unit metadata
// criteria is an object like
//   { properties: 'area', isMetric: 'yes' }
// where the key/value pairs form a logical intersection, i.e. all criteria must be met
// resultFields is an array to pre-reduce the result set fields
function unitQuery(criteria, resultFields) {
  return Object.keys(unitMetadata).filter(function (unit) {
    var keys = Object.keys(criteria);
    for (var ii = 0; ii < keys.length; ii++) {
      var key = keys[ii];
      var val = unitMetadata[unit][key];
      var value = criteria[key];
      if (val && typeof val === 'object') {
        // it's a list of values, it's a match if the target value occurs in the list
        if (val.indexOf(value) === -1) {
          return false;
        }
      } else {
        // it's a non-object, make a direct comparison
        if (unitMetadata[unit][key] !== value) {
          return false;
        }
      }
    }
    return true;
  }).map(function (key) {
    var obj = {};
    if (resultFields) {
      if (resultFields.length) {
        obj[key] = {};
        resultFields.forEach(function (field) {
          if (unitMetadata[key][field] !== undefined) {
            obj[key][field] = JSON.parse(JSON.stringify(unitMetadata[key][field]));
          }
        });
      } else {
        // just return the keys if an empty array gets passed for resultSet
        obj = key;
      }
    } else {
      obj[key] = JSON.parse(JSON.stringify(unitMetadata[key]));
    }
    return obj;
  });
}

},{"./generated/equivalents.json":50,"./generated/ucum-parser.js":54,"./generated/unitMetadata.json":55,"./lib/helpers.js":56}],58:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],59:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],60:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":59,"_process":49,"inherits":58}]},{},[40]);
