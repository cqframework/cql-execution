// Generated by CoffeeScript 1.12.7
(function() {
  var DateTime, Exception, MAX_DATE_VALUE, MAX_FLOAT_VALUE, MAX_INT_VALUE, MAX_TIME_VALUE, MIN_DATE_VALUE, MIN_FLOAT_PRECISION_VALUE, MIN_FLOAT_VALUE, MIN_INT_VALUE, MIN_TIME_VALUE, OverFlowException, Uncertainty, isValidDecimal, isValidInteger, predecessor, successor,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Exception = require('../datatypes/exception').Exception;

  DateTime = require('../datatypes/datetime').DateTime;

  Uncertainty = require('../datatypes/uncertainty').Uncertainty;

  module.exports.MAX_INT_VALUE = MAX_INT_VALUE = Math.pow(2, 31) - 1;

  module.exports.MIN_INT_VALUE = MIN_INT_VALUE = Math.pow(-2, 31);

  module.exports.MAX_FLOAT_VALUE = MAX_FLOAT_VALUE = 99999999999999999999999999999.99999999;

  module.exports.MIN_FLOAT_VALUE = MIN_FLOAT_VALUE = -99999999999999999999999999999.99999999;

  module.exports.MIN_FLOAT_PRECISION_VALUE = MIN_FLOAT_PRECISION_VALUE = Math.pow(10, -8);

  module.exports.MIN_DATE_VALUE = MIN_DATE_VALUE = DateTime.parse("0001-01-01T00:00:00.000");

  module.exports.MAX_DATE_VALUE = MAX_DATE_VALUE = DateTime.parse("9999-12-31T23:59:59.999");

  module.exports.MIN_TIME_VALUE = MIN_TIME_VALUE = DateTime.parse("0000-01-01T00:00:00.000");

  module.exports.MAX_TIME_VALUE = MAX_TIME_VALUE = DateTime.parse("0000-01-01T23:59:59.999");

  module.exports.isValidInteger = isValidInteger = function(integer) {
    if (isNaN(integer)) {
      return false;
    }
    if (integer > MAX_INT_VALUE) {
      return false;
    }
    if (integer < MIN_INT_VALUE) {
      return false;
    }
    return true;
  };

  module.exports.isValidDecimal = isValidDecimal = function(decimal) {
    if (isNaN(decimal)) {
      return false;
    }
    if (decimal > MAX_FLOAT_VALUE) {
      return false;
    }
    if (decimal < MIN_FLOAT_VALUE) {
      return false;
    }
    return true;
  };

  module.exports.limitDecimalPrecision = function(decimal) {
    var decimalPoints, decimalString, splitDecimalString;
    decimalString = decimal.toString();
    if (decimalString.indexOf('e') !== -1) {
      return decimal;
    }
    splitDecimalString = decimalString.split('.');
    decimalPoints = splitDecimalString[1];
    if ((decimalPoints != null) && decimalPoints.length > 8) {
      decimalString = splitDecimalString[0] + '.' + splitDecimalString[1].substring(0, 8);
    }
    return parseFloat(decimalString);
  };

  module.exports.OverFlowException = OverFlowException = OverFlowException = (function(superClass) {
    extend(OverFlowException, superClass);

    function OverFlowException() {
      return OverFlowException.__super__.constructor.apply(this, arguments);
    }

    return OverFlowException;

  })(Exception);

  module.exports.successor = successor = function(val) {
    var e, high, succ;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        if (val === MAX_INT_VALUE) {
          throw new OverFlowException();
        } else {
          return val + 1;
        }
      } else {
        return val + MIN_FLOAT_PRECISION_VALUE;
      }
    } else if (val instanceof DateTime) {
      if (val.sameAs(MAX_DATE_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.successor();
      }
    } else if (val instanceof Uncertainty) {
      high = (function() {
        try {
          return successor(val.high);
        } catch (error) {
          e = error;
          return val.high;
        }
      })();
      return new Uncertainty(successor(val.low), high);
    } else if (val != null ? val.isQuantity : void 0) {
      succ = val.clone();
      succ.value = successor(val.value);
      return succ;
    } else if (val == null) {
      return null;
    }
  };

  module.exports.predecessor = predecessor = function(val) {
    var e, low, pred;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        if (val === MIN_INT_VALUE) {
          throw new OverFlowException();
        } else {
          return val - 1;
        }
      } else {
        return val - MIN_FLOAT_PRECISION_VALUE;
      }
    } else if (val instanceof DateTime) {
      if (val.sameAs(MIN_DATE_VALUE)) {
        throw new OverFlowException();
      } else {
        return val.predecessor();
      }
    } else if (val instanceof Uncertainty) {
      low = (function() {
        try {
          return predecessor(val.low);
        } catch (error) {
          e = error;
          return val.low;
        }
      })();
      return new Uncertainty(low, predecessor(val.high));
    } else if (val != null ? val.isQuantity : void 0) {
      pred = val.clone();
      pred.value = predecessor(val.value);
      return pred;
    } else if (val == null) {
      return null;
    }
  };

  module.exports.maxValueForInstance = function(val) {
    var val2;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        return MAX_INT_VALUE;
      } else {
        return MAX_FLOAT_VALUE;
      }
    } else if (val instanceof DateTime) {
      return MAX_DATE_VALUE;
    } else if (val != null ? val.isQuantity : void 0) {
      val2 = val.clone();
      val2.value = maxValueForInstance(val2.value);
      return val2;
    } else {
      return null;
    }
  };

  module.exports.minValueForInstance = function(val) {
    var val2;
    if (typeof val === "number") {
      if (parseInt(val) === val) {
        return MIN_INT_VALUE;
      } else {
        return MIN_FLOAT_VALUE;
      }
    } else if (val instanceof DateTime) {
      return MIN_DATE_VALUE;
    } else if (val != null ? val.isQuantity : void 0) {
      val2 = val.clone();
      val2.value = minValueForInstance(val2.value);
      return val2;
    } else {
      return null;
    }
  };

  module.exports.decimalAdjust = function(type, value, exp) {
    var v;
    if (typeof exp === 'undefined' || +exp === 0) {
      return Math[type](value);
    }
    value = +value;
    exp = +exp;
    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
      return 0/0;
    }
    value = value.toString().split('e');
    v = value[1] ? +value[1] - exp : -exp;
    value = Math[type](+(value[0] + 'e' + v));
    value = value.toString().split('e');
    v = value[1] ? +value[1] + exp : exp;
    return +(value[0] + 'e' + v);
  };

}).call(this);

//# sourceMappingURL=math.js.map
