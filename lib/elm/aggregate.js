// Generated by CoffeeScript 1.12.7
(function() {
  var AggregateExpression, AllTrue, AnyTrue, Avg, Count, Exception, Expression, GeometricMean, Max, Median, Min, Mode, PopulationStdDev, PopulationVariance, Product, Quantity, StdDev, Sum, Variance, allTrue, anyTrue, build, compact, numerical_sort, productValue, quantitiesOrArg, quantityOrValue, ref, typeIsArray,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Expression = require('./expression').Expression;

  ref = require('../util/util'), typeIsArray = ref.typeIsArray, allTrue = ref.allTrue, anyTrue = ref.anyTrue, compact = ref.compact, numerical_sort = ref.numerical_sort;

  build = require('./builder').build;

  Exception = require('../datatypes/exception').Exception;

  Quantity = require('./quantity');

  quantitiesOrArg = function(arr) {
    var allQs, i, j, len, someQs, unit, values;
    arr = compact(arr);
    if (arr.length === 0) {
      return arr;
    }
    allQs = arr.every(function(x) {
      return x.isQuantity;
    });
    someQs = arr.some(function(x) {
      return x.isQuantity;
    });
    if (allQs) {
      unit = arr[0].unit;
      values = [];
      for (j = 0, len = arr.length; j < len; j++) {
        i = arr[j];
        values.push(i.convertUnits(unit));
      }
      return values;
    } else if (someQs) {
      throw new Exception("Cannot perform aggregate operations on mixed values of Quantities and non Quantities");
    } else {
      return arr;
    }
  };

  quantityOrValue = function(value, arr) {
    var ref1;
    if (arr != null ? (ref1 = arr[0]) != null ? ref1.unit : void 0 : void 0) {
      return Quantity.createQuantity(value, arr[0].unit);
    } else {
      return value;
    }
  };

  AggregateExpression = (function(superClass) {
    extend(AggregateExpression, superClass);

    function AggregateExpression(json) {
      AggregateExpression.__super__.constructor.apply(this, arguments);
      this.source = build(json.source);
    }

    return AggregateExpression;

  })(Expression);

  module.exports.Count = Count = (function(superClass) {
    extend(Count, superClass);

    function Count(json) {
      Count.__super__.constructor.apply(this, arguments);
    }

    Count.prototype.exec = function(ctx) {
      var arg;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        return compact(arg).length;
      }
    };

    return Count;

  })(AggregateExpression);

  module.exports.Sum = Sum = (function(superClass) {
    extend(Sum, superClass);

    function Sum(json) {
      Sum.__super__.constructor.apply(this, arguments);
    }

    Sum.prototype.exec = function(ctx) {
      var arg, filtered, val;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        filtered = quantitiesOrArg(arg);
        val = filtered.length === 0 ? null : filtered.reduce(function(x, y) {
          return x + y;
        });
        return quantityOrValue(val, arg);
      }
    };

    return Sum;

  })(AggregateExpression);

  module.exports.Min = Min = (function(superClass) {
    extend(Min, superClass);

    function Min(json) {
      Min.__super__.constructor.apply(this, arguments);
    }

    Min.prototype.exec = function(ctx) {
      var arg, filtered;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        filtered = numerical_sort(quantitiesOrArg(arg), "asc");
        return quantityOrValue(filtered[0], arg);
      }
    };

    return Min;

  })(AggregateExpression);

  module.exports.Max = Max = (function(superClass) {
    extend(Max, superClass);

    function Max(json) {
      Max.__super__.constructor.apply(this, arguments);
    }

    Max.prototype.exec = function(ctx) {
      var arg, filtered;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        filtered = numerical_sort(quantitiesOrArg(arg), "desc");
        return quantityOrValue(filtered[0], arg);
      }
    };

    return Max;

  })(AggregateExpression);

  module.exports.Avg = Avg = (function(superClass) {
    extend(Avg, superClass);

    function Avg(json) {
      Avg.__super__.constructor.apply(this, arguments);
    }

    Avg.prototype.exec = function(ctx) {
      var arg, filtered, sum;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        filtered = quantitiesOrArg(arg);
        if (filtered.length === 0) {
          return null;
        }
        sum = filtered.reduce(function(x, y) {
          return x + y;
        });
        return quantityOrValue(sum / filtered.length, arg);
      }
    };

    return Avg;

  })(AggregateExpression);

  module.exports.Median = Median = (function(superClass) {
    extend(Median, superClass);

    function Median(json) {
      Median.__super__.constructor.apply(this, arguments);
    }

    Median.prototype.exec = function(ctx) {
      var arg, filtered, v;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        filtered = numerical_sort(quantitiesOrArg(arg), "asc");
        if (filtered.length === 0) {
          return null;
        } else if (filtered.length % 2 === 1) {
          return quantityOrValue(filtered[(filtered.length - 1) / 2], arg);
        } else {
          v = (filtered[(filtered.length / 2) - 1] + filtered[filtered.length / 2]) / 2;
          return quantityOrValue(v, arg);
        }
      }
    };

    return Median;

  })(AggregateExpression);

  module.exports.Mode = Mode = (function(superClass) {
    extend(Mode, superClass);

    function Mode(json) {
      Mode.__super__.constructor.apply(this, arguments);
    }

    Mode.prototype.exec = function(ctx) {
      var arg, filtered, mode;
      arg = this.source.execute(ctx);
      if (typeIsArray(arg)) {
        filtered = compact(arg);
        mode = this.mode(filtered);
        if (mode.length === 1) {
          return mode[0];
        } else {
          return mode;
        }
      }
    };

    Mode.prototype.mode = function(arr) {
      var cnt, counts, elem, j, len, max, ref1, results;
      max = 0;
      counts = {};
      results = [];
      for (j = 0, len = arr.length; j < len; j++) {
        elem = arr[j];
        cnt = counts[elem] = ((ref1 = counts[elem]) != null ? ref1 : 0) + 1;
        if (cnt === max && indexOf.call(results, elem) < 0) {
          results.push(elem);
        } else if (cnt > max) {
          results = [elem];
          max = cnt;
        }
      }
      return results;
    };

    return Mode;

  })(AggregateExpression);

  module.exports.StdDev = StdDev = (function(superClass) {
    extend(StdDev, superClass);

    function StdDev(json) {
      StdDev.__super__.constructor.apply(this, arguments);
      this.type = "standard_deviation";
    }

    StdDev.prototype.exec = function(ctx) {
      var args, val;
      args = this.source.execute(ctx);
      if (typeIsArray(args)) {
        val = quantitiesOrArg(args);
        if (val.length > 0) {
          return quantityOrValue(this.calculate(val), args);
        } else {
          return null;
        }
      }
    };

    StdDev.prototype.calculate = function(list) {
      var val;
      val = this.stats(list);
      if (val) {
        return val[this.type];
      }
    };

    StdDev.prototype.stats = function(list) {
      var j, len, mean, pop_dev, pop_var, sq, std_dev, std_var, sum, sumOfSquares;
      sum = list.reduce(function(x, y) {
        return x + y;
      });
      mean = sum / list.length;
      sumOfSquares = 0;
      for (j = 0, len = list.length; j < len; j++) {
        sq = list[j];
        sumOfSquares += Math.pow(sq - mean, 2);
      }
      std_var = (1 / list.length) * sumOfSquares;
      pop_var = (1 / (list.length - 1)) * sumOfSquares;
      std_dev = Math.sqrt(std_var);
      pop_dev = Math.sqrt(pop_var);
      return {
        standard_variance: std_var,
        population_variance: pop_var,
        standard_deviation: std_dev,
        population_deviation: pop_dev
      };
    };

    return StdDev;

  })(AggregateExpression);

  module.exports.Product = Product = (function(superClass) {
    extend(Product, superClass);

    function Product(json) {
      Product.__super__.constructor.apply(this, arguments);
    }

    Product.prototype.exec = function(ctx) {
      var filtered, listOfValues, product, ref1;
      listOfValues = this.source.execute(ctx);
      if (listOfValues === null) {
        return null;
      }
      ref1 = productValue(listOfValues), product = ref1[0], filtered = ref1[1];
      if (product === null) {
        return null;
      }
      return quantityOrValue(product, listOfValues);
    };

    return Product;

  })(AggregateExpression);

  module.exports.GeometricMean = GeometricMean = (function(superClass) {
    extend(GeometricMean, superClass);

    function GeometricMean(json) {
      GeometricMean.__super__.constructor.apply(this, arguments);
    }

    GeometricMean.prototype.exec = function(ctx) {
      var filtered, geoMean, listOfValues, product, ref1;
      listOfValues = this.source.execute(ctx);
      if (listOfValues === null) {
        return null;
      }
      ref1 = productValue(listOfValues), product = ref1[0], filtered = ref1[1];
      if (product === null) {
        return null;
      }
      geoMean = Math.pow(product, 1.0 / filtered.length);
      return geoMean;
    };

    return GeometricMean;

  })(AggregateExpression);

  productValue = function(list) {
    var filtered, item, j, len, product;
    product = 1;
    if (typeIsArray(list)) {
      filtered = compact(list);
      if (filtered.length === 0) {
        return [null, null];
      }
      for (j = 0, len = filtered.length; j < len; j++) {
        item = filtered[j];
        if (item.isQuantity) {
          product = Quantity.doMultiplication(product, item);
        } else {
          product = product * item;
        }
      }
      return [product, filtered];
    } else {
      return [null, null];
    }
  };

  module.exports.PopulationStdDev = PopulationStdDev = (function(superClass) {
    extend(PopulationStdDev, superClass);

    function PopulationStdDev(json) {
      PopulationStdDev.__super__.constructor.apply(this, arguments);
      this.type = "population_deviation";
    }

    return PopulationStdDev;

  })(StdDev);

  module.exports.Variance = Variance = (function(superClass) {
    extend(Variance, superClass);

    function Variance(json) {
      Variance.__super__.constructor.apply(this, arguments);
      this.type = "standard_variance";
    }

    return Variance;

  })(StdDev);

  module.exports.PopulationVariance = PopulationVariance = (function(superClass) {
    extend(PopulationVariance, superClass);

    function PopulationVariance(json) {
      PopulationVariance.__super__.constructor.apply(this, arguments);
      this.type = "population_variance";
    }

    return PopulationVariance;

  })(StdDev);

  module.exports.AllTrue = AllTrue = (function(superClass) {
    extend(AllTrue, superClass);

    function AllTrue(json) {
      AllTrue.__super__.constructor.apply(this, arguments);
    }

    AllTrue.prototype.exec = function(ctx) {
      var args;
      args = this.source.execute(ctx);
      return allTrue(args);
    };

    return AllTrue;

  })(AggregateExpression);

  module.exports.AnyTrue = AnyTrue = (function(superClass) {
    extend(AnyTrue, superClass);

    function AnyTrue(json) {
      AnyTrue.__super__.constructor.apply(this, arguments);
    }

    AnyTrue.prototype.exec = function(ctx) {
      var args;
      args = this.source.execute(ctx);
      return anyTrue(args);
    };

    return AnyTrue;

  })(AggregateExpression);

}).call(this);

//# sourceMappingURL=aggregate.js.map
