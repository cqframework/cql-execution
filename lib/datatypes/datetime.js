// Generated by CoffeeScript 1.12.7
(function() {
  var Date, DateTime, Uncertainty, cqlFormatStringToMomentFormatString, daysInMonth, getTimezoneSeparatorFromString, isValidDateStringFormat, isValidDateTimeStringFormat, jsDate, moment, normalizeMillisecondsField, normalizeMillisecondsFieldInString, ref,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Uncertainty = require('./uncertainty').Uncertainty;

  ref = require('../util/util'), jsDate = ref.jsDate, normalizeMillisecondsField = ref.normalizeMillisecondsField, normalizeMillisecondsFieldInString = ref.normalizeMillisecondsFieldInString, getTimezoneSeparatorFromString = ref.getTimezoneSeparatorFromString;

  moment = require('moment');

  DateTime = (function() {
    DateTime.Unit = {
      YEAR: 'year',
      MONTH: 'month',
      WEEK: 'week',
      DAY: 'day',
      HOUR: 'hour',
      MINUTE: 'minute',
      SECOND: 'second',
      MILLISECOND: 'millisecond'
    };

    DateTime.FIELDS = [DateTime.Unit.YEAR, DateTime.Unit.MONTH, DateTime.Unit.DAY, DateTime.Unit.HOUR, DateTime.Unit.MINUTE, DateTime.Unit.SECOND, DateTime.Unit.MILLISECOND];

    DateTime.parse = function(string) {
      var arg, args, days, hours, matches, milliseconds, minutes, months, num, seconds, years;
      if (string === null) {
        return null;
      }
      matches = /(\d{4})(-(\d{2}))?(-(\d{2}))?(T((\d{2})(\:(\d{2})(\:(\d{2})(\.(\d+))?)?)?)?(Z|(([+-])(\d{2})(\:?(\d{2}))?))?)?/.exec(string);
      if (matches == null) {
        return null;
      }
      years = matches[1];
      months = matches[3];
      days = matches[5];
      hours = matches[8];
      minutes = matches[10];
      seconds = matches[12];
      milliseconds = matches[14];
      if (milliseconds != null) {
        milliseconds = normalizeMillisecondsField(milliseconds);
      }
      if (milliseconds != null) {
        string = normalizeMillisecondsFieldInString(string, matches[14]);
      }
      if (!isValidDateTimeStringFormat(string)) {
        return null;
      }
      args = [years, months, days, hours, minutes, seconds, milliseconds];
      args = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          results.push(arg != null ? parseInt(arg, 10) : void 0);
        }
        return results;
      })();
      if (matches[18] != null) {
        num = parseInt(matches[18], 10) + (matches[20] != null ? parseInt(matches[20], 10) / 60 : 0);
        args.push(matches[17] === '+' ? num : num * -1);
      } else if (matches[15] === 'Z') {
        args.push(0);
      }
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(DateTime, args, function(){});
    };

    DateTime.fromJSDate = function(date, timezoneOffset) {
      if (date instanceof DateTime) {
        return date;
      }
      if (timezoneOffset != null) {
        date = new jsDate(date.getTime() + (timezoneOffset * 60 * 60 * 1000));
        return new DateTime(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds(), timezoneOffset);
      } else {
        return new DateTime(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
      }
    };

    function DateTime(year1, month1, day, hour, minute, second, millisecond, timezoneOffset1) {
      this.year = year1 != null ? year1 : null;
      this.month = month1 != null ? month1 : null;
      this.day = day != null ? day : null;
      this.hour = hour != null ? hour : null;
      this.minute = minute != null ? minute : null;
      this.second = second != null ? second : null;
      this.millisecond = millisecond != null ? millisecond : null;
      this.timezoneOffset = timezoneOffset1;
      if (this.timezoneOffset == null) {
        this.timezoneOffset = (new jsDate()).getTimezoneOffset() / 60 * -1;
      }
    }

    Object.defineProperties(DateTime.prototype, {
      isDateTime: {
        get: function() {
          return true;
        }
      }
    });

    DateTime.prototype.copy = function() {
      return new DateTime(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond, this.timezoneOffset);
    };

    DateTime.prototype.successor = function() {
      if (this.millisecond != null) {
        return this.add(1, DateTime.Unit.MILLISECOND);
      } else if (this.second != null) {
        return this.add(1, DateTime.Unit.SECOND);
      } else if (this.minute != null) {
        return this.add(1, DateTime.Unit.MINUTE);
      } else if (this.hour != null) {
        return this.add(1, DateTime.Unit.HOUR);
      } else if (this.day != null) {
        return this.add(1, DateTime.Unit.DAY);
      } else if (this.month != null) {
        return this.add(1, DateTime.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(1, DateTime.Unit.YEAR);
      }
    };

    DateTime.prototype.predecessor = function() {
      if (this.millisecond != null) {
        return this.add(-1, DateTime.Unit.MILLISECOND);
      } else if (this.second != null) {
        return this.add(-1, DateTime.Unit.SECOND);
      } else if (this.minute != null) {
        return this.add(-1, DateTime.Unit.MINUTE);
      } else if (this.hour != null) {
        return this.add(-1, DateTime.Unit.HOUR);
      } else if (this.day != null) {
        return this.add(-1, DateTime.Unit.DAY);
      } else if (this.month != null) {
        return this.add(-1, DateTime.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(-1, DateTime.Unit.YEAR);
      }
    };

    DateTime.prototype.convertToTimezoneOffset = function(timezoneOffset) {
      var d;
      if (timezoneOffset == null) {
        timezoneOffset = 0;
      }
      d = DateTime.fromJSDate(this.toJSDate(), timezoneOffset);
      return d.reducedPrecision(this.getPrecision());
    };

    DateTime.prototype.differenceBetween = function(other, unitField) {
      var a, aHighMoment, aJS, aLowMoment, aUncertainty, b, bHighMoment, bJS, bLowMoment, bUncertainty, tzDiff;
      other = this._implicitlyConvert(other);
      if (!(other instanceof DateTime)) {
        return null;
      }
      a = this.copy();
      b = other.copy();
      if (unitField === DateTime.Unit.MONTH || unitField === DateTime.Unit.YEAR || unitField === DateTime.Unit.WEEK || unitField === DateTime.Unit.DAY) {
        if (a.timezoneOffset !== b.timezoneOffset) {
          b = b.convertToTimezoneOffset(a.timezoneOffset);
        }
        aJS = a.toJSDate(true);
        bJS = b.toJSDate(true);
        tzDiff = a.isUTC() && b.isUTC() ? 0 : aJS.getTimezoneOffset() - bJS.getTimezoneOffset();
        if (tzDiff !== 0) {
          if ((b.year != null) && (b.month != null) && (b.day != null) && (b.hour != null) && (b.minute != null)) {
            b = b.add(tzDiff, DateTime.Unit.MINUTE);
          } else if ((b.year != null) && (b.month != null) && (b.day != null) && (b.hour != null)) {
            b = b.add(tzDiff / 60, DateTime.Unit.HOUR);
          } else {
            b.timezoneOffset = b.timezoneOffset + (tzDiff / 60);
          }
        }
      }
      if (unitField === DateTime.Unit.YEAR) {
        a = new DateTime(a.year, 1, 1, 12, 0, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, 1, 1, 12, 0, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.MONTH) {
        a = new DateTime(a.year, a.month, 1, 12, 0, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, 1, 12, 0, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.WEEK) {
        a = this._floorWeek(a);
        b = this._floorWeek(b);
      } else if (unitField === DateTime.Unit.DAY) {
        a = new DateTime(a.year, a.month, a.day, 12, 0, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, b.day, 12, 0, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.HOUR) {
        a = new DateTime(a.year, a.month, a.day, a.hour, 30, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, b.day, b.hour, 30, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.MINUTE) {
        a = new DateTime(a.year, a.month, a.day, a.hour, a.minute, 0, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, b.day, b.hour, b.minute, 0, 0, b.timezoneOffset);
      } else if (unitField === DateTime.Unit.SECOND) {
        a = new DateTime(a.year, a.month, a.day, a.hour, a.minute, a.second, 0, a.timezoneOffset);
        b = new DateTime(b.year, b.month, b.day, b.hour, b.minute, b.second, 0, b.timezoneOffset);
      }
      if (unitField === DateTime.Unit.YEAR || unitField === DateTime.Unit.MONTH) {
        return a.durationBetween(b, unitField);
      } else {
        aUncertainty = a.toUncertainty();
        bUncertainty = b.toUncertainty();
        aLowMoment = moment(aUncertainty.low).utc();
        aHighMoment = moment(aUncertainty.high).utc();
        bLowMoment = moment(bUncertainty.low).utc();
        bHighMoment = moment(bUncertainty.high).utc();
        return new Uncertainty(bLowMoment.diff(aHighMoment, unitField + 's'), bHighMoment.diff(aLowMoment, unitField + 's'));
      }
    };

    DateTime.prototype._floorWeek = function(d) {
      var floored;
      if (d.day == null) {
        return d;
      }
      floored = new jsDate(d.year, d.month - 1, d.day);
      while (floored.getDay() > 0) {
        floored.setDate(floored.getDate() - 1);
      }
      return new DateTime(floored.getFullYear(), floored.getMonth() + 1, floored.getDate(), 12, 0, 0, 0, d.timezoneOffset);
    };

    DateTime.prototype.durationBetween = function(other, unitField) {
      var a, b;
      other = this._implicitlyConvert(other);
      if (!(other instanceof DateTime)) {
        return null;
      }
      a = this.toUncertainty();
      b = other.toUncertainty();
      return new Uncertainty(this._durationBetweenDates(a.high, b.low, unitField), this._durationBetweenDates(a.low, b.high, unitField));
    };

    DateTime.prototype._durationBetweenDates = function(a, b, unitField) {
      var aInMonth, aInMonthOriginalOffset, months, msDiff, truncFunc;
      msDiff = b.getTime() - a.getTime();
      if (msDiff === 0) {
        return 0;
      }
      truncFunc = msDiff > 0 ? Math.floor : Math.ceil;
      if (unitField === DateTime.Unit.MILLISECOND) {
        return msDiff;
      } else if (unitField === DateTime.Unit.SECOND) {
        return truncFunc(msDiff / 1000);
      } else if (unitField === DateTime.Unit.MINUTE) {
        return truncFunc(msDiff / (60 * 1000));
      } else if (unitField === DateTime.Unit.HOUR) {
        return truncFunc(msDiff / (60 * 60 * 1000));
      } else if (unitField === DateTime.Unit.DAY) {
        return truncFunc(msDiff / (24 * 60 * 60 * 1000));
      } else if (unitField === DateTime.Unit.WEEK) {
        return truncFunc(msDiff / (7 * 24 * 60 * 60 * 1000));
      } else if (unitField === DateTime.Unit.MONTH || unitField === DateTime.Unit.YEAR) {
        months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
        aInMonth = new jsDate(a.getTime());
        aInMonthOriginalOffset = aInMonth.getTimezoneOffset();
        aInMonth.setMonth(a.getMonth() + months);
        if (aInMonthOriginalOffset !== aInMonth.getTimezoneOffset()) {
          aInMonth.setMinutes(aInMonth.getMinutes() + (aInMonthOriginalOffset - aInMonth.getTimezoneOffset()));
        }
        if (msDiff > 0 && aInMonth > b) {
          months = months - 1;
        } else if (msDiff < 0 && aInMonth < b) {
          months = months + 1;
        }
        if (unitField === DateTime.Unit.MONTH) {
          return months;
        } else {
          return truncFunc(months / 12);
        }
      } else {
        return null;
      }
    };

    DateTime.prototype.isUTC = function() {
      return !this.timezoneOffset;
    };

    DateTime.prototype.getPrecision = function() {
      var result;
      result = null;
      if (this.year != null) {
        result = DateTime.Unit.YEAR;
      } else {
        return result;
      }
      if (this.month != null) {
        result = DateTime.Unit.MONTH;
      } else {
        return result;
      }
      if (this.day != null) {
        result = DateTime.Unit.DAY;
      } else {
        return result;
      }
      if (this.hour != null) {
        result = DateTime.Unit.HOUR;
      } else {
        return result;
      }
      if (this.minute != null) {
        result = DateTime.Unit.MINUTE;
      } else {
        return result;
      }
      if (this.second != null) {
        result = DateTime.Unit.SECOND;
      } else {
        return result;
      }
      if (this.millisecond != null) {
        result = DateTime.Unit.MILLISECOND;
      }
      return result;
    };

    DateTime.prototype.toUncertainty = function(ignoreTimezone) {
      var high, low, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      if (ignoreTimezone == null) {
        ignoreTimezone = false;
      }
      low = this.toJSDate(ignoreTimezone);
      high = (new DateTime(this.year, (ref1 = this.month) != null ? ref1 : 12, (ref2 = this.day) != null ? ref2 : (new jsDate(this.year, (ref3 = this.month) != null ? ref3 : 12, 0)).getDate(), (ref4 = this.hour) != null ? ref4 : 23, (ref5 = this.minute) != null ? ref5 : 59, (ref6 = this.second) != null ? ref6 : 59, (ref7 = this.millisecond) != null ? ref7 : 999, this.timezoneOffset)).toJSDate(ignoreTimezone);
      return new Uncertainty(low, high);
    };

    DateTime.prototype.toJSDate = function(ignoreTimezone) {
      var d, h, mi, mo, ms, ref1, ref2, ref3, ref4, ref5, ref6, s, y;
      if (ignoreTimezone == null) {
        ignoreTimezone = false;
      }
      ref6 = [this.year, (this.month != null ? this.month - 1 : 0), (ref1 = this.day) != null ? ref1 : 1, (ref2 = this.hour) != null ? ref2 : 0, (ref3 = this.minute) != null ? ref3 : 0, (ref4 = this.second) != null ? ref4 : 0, (ref5 = this.millisecond) != null ? ref5 : 0], y = ref6[0], mo = ref6[1], d = ref6[2], h = ref6[3], mi = ref6[4], s = ref6[5], ms = ref6[6];
      if ((this.timezoneOffset != null) && !ignoreTimezone) {
        return new jsDate(jsDate.UTC(y, mo, d, h, mi, s, ms) - (this.timezoneOffset * 60 * 60 * 1000));
      } else {
        return new jsDate(y, mo, d, h, mi, s, ms);
      }
    };

    DateTime.prototype.toJSON = function() {
      return this.toString();
    };

    DateTime.prototype._pad = function(num) {
      return String("0" + num).slice(-2);
    };

    DateTime.prototype.toString = function() {
      if (this.isTime()) {
        return this.toStringTime();
      } else {
        return this.toStringDateTime();
      }
    };

    DateTime.prototype.toStringTime = function() {
      var str;
      str = 'T';
      if (this.hour != null) {
        str += +this._pad(this.hour);
        if (this.minute != null) {
          str += ':' + this._pad(this.minute);
          if (this.second != null) {
            str += ':' + this._pad(this.second);
            if (this.millisecond != null) {
              str += '.' + String("00" + this.millisecond).slice(-3);
            }
          }
        }
      }
      return str;
    };

    DateTime.prototype.toStringDateTime = function() {
      var offsetHours, offsetMin, str;
      str = '';
      if (this.year != null) {
        str += this.year;
        if (this.month != null) {
          str += '-' + this._pad(this.month);
          if (this.day != null) {
            str += '-' + this._pad(this.day);
            if (this.hour != null) {
              str += 'T' + this._pad(this.hour);
              if (this.minute != null) {
                str += ':' + this._pad(this.minute);
                if (this.second != null) {
                  str += ':' + this._pad(this.second);
                  if (this.millisecond != null) {
                    str += '.' + String("00" + this.millisecond).slice(-3);
                  }
                }
              }
            }
          }
        }
      }
      if (str.indexOf('T') !== -1 && (this.timezoneOffset != null)) {
        str += this.timezoneOffset < 0 ? '-' : '+';
        offsetHours = Math.floor(Math.abs(this.timezoneOffset));
        str += this._pad(offsetHours);
        offsetMin = (Math.abs(this.timezoneOffset) - offsetHours) * 60;
        str += ':' + this._pad(offsetMin);
      }
      return str;
    };

    DateTime.prototype.getDateTime = function() {
      return this;
    };

    DateTime.prototype.getDate = function() {
      return new Date(this.year, this.month, this.day);
    };

    DateTime.prototype.getTime = function() {
      return new DateTime(0, 1, 1, this.hour, this.minute, this.second, this.millisecond, this.timezoneOffset);
    };

    DateTime.prototype.isTime = function() {
      return this.year === 0 && this.month === 1 && this.day === 1;
    };

    DateTime.prototype._implicitlyConvert = function(other) {
      if (other instanceof Date) {
        return other.getDateTime();
      }
      return other;
    };

    DateTime.prototype.reducedPrecision = function(unitField) {
      var field, fieldIndex, fieldsToRemove, i, len, reduced;
      if (unitField == null) {
        unitField = DateTime.Unit.MILLISECOND;
      }
      reduced = this.copy();
      if (unitField !== DateTime.Unit.MILLISECOND) {
        fieldIndex = DateTime.FIELDS.indexOf(unitField);
        fieldsToRemove = DateTime.FIELDS.slice(fieldIndex + 1);
        for (i = 0, len = fieldsToRemove.length; i < len; i++) {
          field = fieldsToRemove[i];
          reduced[field] = null;
        }
      }
      return reduced;
    };

    return DateTime;

  })();

  Date = (function() {
    Date.Unit = {
      YEAR: 'year',
      MONTH: 'month',
      WEEK: 'week',
      DAY: 'day'
    };

    Date.FIELDS = [Date.Unit.YEAR, Date.Unit.MONTH, Date.Unit.DAY];

    Date.parse = function(string) {
      var arg, args, days, matches, months, years;
      if (string === null) {
        return null;
      }
      matches = /(\d{4})(-(\d{2}))?(-(\d{2}))?/.exec(string);
      if (matches == null) {
        return null;
      }
      years = matches[1];
      months = matches[3];
      days = matches[5];
      if (!isValidDateStringFormat(string)) {
        return null;
      }
      args = [years, months, days];
      args = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          results.push(arg != null ? parseInt(arg, 10) : void 0);
        }
        return results;
      })();
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Date, args, function(){});
    };

    function Date(year1, month1, day) {
      this.year = year1 != null ? year1 : null;
      this.month = month1 != null ? month1 : null;
      this.day = day != null ? day : null;
      return;
    }

    Object.defineProperties(Date.prototype, {
      isDate: {
        get: function() {
          return true;
        }
      }
    });

    Date.prototype.copy = function() {
      return new Date(this.year, this.month, this.day);
    };

    Date.prototype.successor = function() {
      if (this.day != null) {
        return this.add(1, Date.Unit.DAY);
      } else if (this.month != null) {
        return this.add(1, Date.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(1, Date.Unit.YEAR);
      }
    };

    Date.prototype.predecessor = function() {
      if (this.day != null) {
        return this.add(-1, Date.Unit.DAY);
      } else if (this.month != null) {
        return this.add(-1, Date.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(-1, Date.Unit.YEAR);
      }
    };

    Date.prototype.differenceBetween = function(other, unitField) {
      var a, b;
      if (other instanceof DateTime) {
        return this.getDateTime().differenceBetween(other, unitField);
      }
      if (!(other instanceof Date)) {
        return null;
      }
      a = this;
      b = other;
      if (unitField === Date.Unit.YEAR) {
        a = new Date(a.year, 1, 1);
        b = new Date(b.year, 1, 1);
      } else if (unitField === Date.Unit.MONTH) {
        a = new Date(a.year, a.month, 1);
        b = new Date(b.year, b.month, 1);
      } else if (unitField === Date.Unit.WEEK) {
        a = this._floorWeek(a);
        b = this._floorWeek(b);
      }
      return a.durationBetween(b, unitField);
    };

    Date.prototype._floorWeek = function(d) {
      var floored;
      if (d.day == null) {
        return d;
      }
      floored = new jsDate(d.year, d.month - 1, d.day);
      while (floored.getDay() > 0) {
        floored.setDate(floored.getDate() - 1);
      }
      return new Date(floored.getFullYear(), floored.getMonth() + 1, floored.getDate());
    };

    Date.prototype.durationBetween = function(other, unitField) {
      var a, b;
      if (other instanceof DateTime) {
        return this.getDateTime().durationBetween(other, unitField);
      }
      if (!(other instanceof Date)) {
        return null;
      }
      a = this.toUncertainty();
      b = other.toUncertainty();
      return new Uncertainty(this._durationBetweenDates(a.high, b.low, unitField), this._durationBetweenDates(a.low, b.high, unitField));
    };

    Date.prototype._durationBetweenDates = function(a, b, unitField) {
      var aInMonth, aInMonthOriginalOffset, months, msDiff, truncFunc, tzdiff;
      a.setTime(a.getTime() + (12 * 60 * 60 * 1000));
      b.setTime(b.getTime() + (12 * 60 * 60 * 1000));
      tzdiff = a.getTimezoneOffset() - b.getTimezoneOffset();
      b.setTime(b.getTime() + (tzdiff * 60 * 1000));
      msDiff = b.getTime() - a.getTime();
      if (msDiff === 0) {
        return 0;
      }
      truncFunc = msDiff > 0 ? Math.floor : Math.ceil;
      if (unitField === Date.Unit.DAY) {
        return truncFunc(msDiff / (24 * 60 * 60 * 1000));
      } else if (unitField === Date.Unit.WEEK) {
        return truncFunc(msDiff / (7 * 24 * 60 * 60 * 1000));
      } else if (unitField === Date.Unit.MONTH || unitField === Date.Unit.YEAR) {
        months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
        aInMonth = new jsDate(a.getTime());
        aInMonthOriginalOffset = aInMonth.getTimezoneOffset();
        aInMonth.setMonth(a.getMonth() + months);
        if (aInMonthOriginalOffset !== aInMonth.getTimezoneOffset()) {
          aInMonth.setMinutes(aInMonth.getMinutes() + (aInMonthOriginalOffset - aInMonth.getTimezoneOffset()));
        }
        if (msDiff > 0 && aInMonth > b) {
          months = months - 1;
        } else if (msDiff < 0 && aInMonth < b) {
          months = months + 1;
        }
        if (unitField === Date.Unit.MONTH) {
          return months;
        } else {
          return truncFunc(months / 12);
        }
      } else {
        return null;
      }
    };

    Date.prototype.getPrecision = function() {
      var result;
      result = null;
      if (this.year != null) {
        result = Date.Unit.YEAR;
      } else {
        return result;
      }
      if (this.month != null) {
        result = Date.Unit.MONTH;
      } else {
        return result;
      }
      if (this.day != null) {
        result = Date.Unit.DAY;
      } else {
        return result;
      }
      return result;
    };

    Date.prototype.toUncertainty = function() {
      var high, low, ref1, ref2, ref3;
      low = this.toJSDate();
      high = new Date(this.year, (ref1 = this.month) != null ? ref1 : 12, (ref2 = this.day) != null ? ref2 : (new jsDate(this.year, (ref3 = this.month) != null ? ref3 : 12, 0)).getDate()).toJSDate();
      return new Uncertainty(low, high);
    };

    Date.prototype.toJSDate = function() {
      var d, mo, ref1, ref2, y;
      ref2 = [this.year, (this.month != null ? this.month - 1 : 0), (ref1 = this.day) != null ? ref1 : 1], y = ref2[0], mo = ref2[1], d = ref2[2];
      return new jsDate(y, mo, d);
    };

    Date.fromJSDate = function(date) {
      if (date instanceof Date) {
        return date;
      }
      return new Date(date.getFullYear(), date.getMonth() + 1, date.getDate());
    };

    Date.prototype.toJSON = function() {
      return this.toString();
    };

    Date.prototype.toString = function() {
      var str;
      str = '';
      if (this.year != null) {
        str += this.year.toString();
        if (this.month != null) {
          str += '-' + this.month.toString().padStart(2, "0");
          if (this.day != null) {
            str += '-' + this.day.toString().padStart(2, "0");
          }
        }
      }
      return str;
    };

    Date.prototype.getDateTime = function() {
      if ((this.year != null) && (this.month != null) && (this.day != null)) {
        return new DateTime(this.year, this.month, this.day, 0, 0, 0, 0);
      } else {
        return new DateTime(this.year, this.month, this.day);
      }
    };

    Date.prototype.reducedPrecision = function(unitField) {
      var field, fieldIndex, fieldsToRemove, i, len, reduced;
      if (unitField == null) {
        unitField = Date.Unit.DAY;
      }
      reduced = this.copy();
      if (unitField !== Date.Unit.DAY) {
        fieldIndex = Date.FIELDS.indexOf(unitField);
        fieldsToRemove = Date.FIELDS.slice(fieldIndex + 1);
        for (i = 0, len = fieldsToRemove.length; i < len; i++) {
          field = fieldsToRemove[i];
          reduced[field] = null;
        }
      }
      return reduced;
    };

    return Date;

  })();

  DateTime.prototype.isPrecise = Date.prototype.isPrecise = function() {
    return this.constructor.FIELDS.every((function(_this) {
      return function(field) {
        return _this[field] != null;
      };
    })(this));
  };

  DateTime.prototype.isImprecise = Date.prototype.isImprecise = function() {
    return !this.isPrecise();
  };

  DateTime.prototype.isMorePrecise = Date.prototype.isMorePrecise = function(other) {
    var field, i, len, ref1;
    if (typeof other === 'string' && indexOf.call(this.constructor.FIELDS, other) >= 0) {
      if (this[other] == null) {
        return false;
      }
    } else {
      ref1 = this.constructor.FIELDS;
      for (i = 0, len = ref1.length; i < len; i++) {
        field = ref1[i];
        if ((other[field] != null) && (this[field] == null)) {
          return false;
        }
      }
    }
    return !this.isSamePrecision(other);
  };

  DateTime.prototype.isLessPrecise = Date.prototype.isLessPrecise = function(other) {
    return !this.isSamePrecision(other) && !this.isMorePrecise(other);
  };

  DateTime.prototype.isSamePrecision = Date.prototype.isSamePrecision = function(other) {
    var field, i, len, ref1;
    if (typeof other === 'string' && indexOf.call(this.constructor.FIELDS, other) >= 0) {
      return other === this.getPrecision();
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] == null)) {
        return false;
      }
      if ((this[field] == null) && (other[field] != null)) {
        return false;
      }
    }
    return true;
  };

  DateTime.prototype.equals = Date.prototype.equals = function(other) {
    var field, i, len, ref1;
    if (!((this.isDate && other.isDate) || (this.isDateTime && other.isDateTime))) {
      return false;
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] !== other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        return true;
      } else {
        return null;
      }
    }
    return true;
  };

  DateTime.prototype.sameAs = Date.prototype.sameAs = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().sameAs(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] !== other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return true;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return true;
  };

  DateTime.prototype.sameOrBefore = Date.prototype.sameOrBefore = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().sameOrBefore(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] < other[field]) {
          return true;
        } else if (this[field] > other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return true;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return true;
  };

  DateTime.prototype.sameOrAfter = Date.prototype.sameOrAfter = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().sameOrAfter(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] > other[field]) {
          return true;
        } else if (this[field] < other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return true;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return true;
  };

  DateTime.prototype.before = Date.prototype.before = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().before(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] < other[field]) {
          return true;
        } else if (this[field] > other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return false;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return false;
  };

  DateTime.prototype.after = Date.prototype.after = function(other, precision) {
    var field, i, len, ref1;
    if (!(other.isDate || other.isDateTime)) {
      return null;
    } else if (this.isDate && other.isDateTime) {
      return this.getDateTime().after(other, precision);
    } else if (this.isDateTime && other.isDate) {
      other = other.getDateTime();
    }
    if ((precision != null) && this.constructor.FIELDS.indexOf(precision) < 0) {
      throw new Error("Invalid precision: " + precision);
    }
    if (this.timezoneOffset !== other.timezoneOffset) {
      other = other.convertToTimezoneOffset(this.timezoneOffset);
    }
    ref1 = this.constructor.FIELDS;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      if ((this[field] != null) && (other[field] != null)) {
        if (this[field] > other[field]) {
          return true;
        } else if (this[field] < other[field]) {
          return false;
        }
      } else if ((this[field] == null) && (other[field] == null)) {
        if (precision == null) {
          return false;
        } else {
          return null;
        }
      } else {
        return null;
      }
      if ((precision != null) && precision === field) {
        break;
      }
    }
    return false;
  };

  DateTime.prototype.add = Date.prototype.add = function(offset, field) {
    var f, fieldFloorOrCiel, i, j, k, len, len1, len2, normalized, offsetIsMorePrecise, ref1, ref2, ref3, ref4, result;
    result = this.copy();
    if (offset === 0) {
      return result;
    }
    if (field === this.constructor.Unit.WEEK) {
      offset = offset * 7;
      field = this.constructor.Unit.DAY;
    }
    offsetIsMorePrecise = result[field] == null;
    if (offsetIsMorePrecise) {
      if (!this.year) {
        result.year = new jsDate().getFullYear();
      }
      fieldFloorOrCiel = offset >= 0 ? this.getFieldFloor : this.getFieldCieling;
      ref1 = this.constructor.FIELDS;
      for (i = 0, len = ref1.length; i < len; i++) {
        f = ref1[i];
        result[f] = (ref2 = result[f]) != null ? ref2 : fieldFloorOrCiel.call(result, f);
        if (result[field] != null) {
          break;
        }
      }
    }
    result[field] = result[field] + offset;
    normalized = this.constructor.fromJSDate(result.toJSDate(), this.timezoneOffset);
    ref3 = this.constructor.FIELDS;
    for (j = 0, len1 = ref3.length; j < len1; j++) {
      field = ref3[j];
      if (result[field] != null) {
        result[field] = normalized[field];
      }
    }
    if (offsetIsMorePrecise) {
      ref4 = this.constructor.FIELDS;
      for (k = 0, len2 = ref4.length; k < len2; k++) {
        f = ref4[k];
        if (this[f] == null) {
          result[f] = null;
        }
      }
    }
    return result;
  };

  DateTime.prototype.getFieldFloor = Date.prototype.getFieldFloor = function(field) {
    if (field === 'month') {
      return 1;
    }
    if (field === 'day') {
      return 1;
    }
    if (field === 'hour') {
      return 0;
    }
    if (field === 'minute') {
      return 0;
    }
    if (field === 'second') {
      return 0;
    }
    if (field === 'millisecond') {
      return 0;
    }
    throw new Error('Tried to floor a field that has no floor value: ' + field);
  };

  DateTime.prototype.getFieldCieling = Date.prototype.getFieldCieling = function(field) {
    if (field === 'month') {
      return 12;
    }
    if (field === 'day') {
      return daysInMonth(this.year, this.month);
    }
    if (field === 'hour') {
      return 23;
    }
    if (field === 'minute') {
      return 59;
    }
    if (field === 'second') {
      return 59;
    }
    if (field === 'millisecond') {
      return 999;
    }
    throw new Error('Tried to clieling a field that has no cieling value: ' + field);
  };

  daysInMonth = function(year, month) {
    if (!((year != null) && (month != null))) {
      throw new Error('daysInMonth requires year and month as arguments');
    }
    return new jsDate(year, month, 0).getDate();
  };

  normalizeMillisecondsField = function(msString) {
    return msString = (msString + "00").substring(0, 3);
  };

  isValidDateStringFormat = function(string) {
    var cqlFormatStringWithLength, cqlFormats, format, i, len, strict;
    if (typeof string !== 'string') {
      return false;
    }
    cqlFormats = ['YYYY', 'YYYY-MM', 'YYYY-MM-DD'];
    cqlFormatStringWithLength = {};
    for (i = 0, len = cqlFormats.length; i < len; i++) {
      format = cqlFormats[i];
      cqlFormatStringWithLength[format.length] = format;
    }
    if (cqlFormatStringWithLength[string.length] == null) {
      return false;
    }
    strict = true;
    return moment(string, cqlFormatStringWithLength[string.length], strict).isValid();
  };

  isValidDateTimeStringFormat = function(string) {
    var cqlFormatStringWithLength, cqlFormats, format, i, len, strict;
    if (typeof string !== 'string') {
      return false;
    }
    cqlFormats = ['YYYY', 'YYYY-MM', 'YYYY-MM-DD', 'YYYY-MM-DDTZ', 'YYYY-MM-DDT+hh', 'YYYY-MM-DDT+hh:mm', 'YYYY-MM-DDT-hh', 'YYYY-MM-DDT-hh:mm', 'YYYY-MM-DDThh', 'YYYY-MM-DDThhZ', 'YYYY-MM-DDThh+hh', 'YYYY-MM-DDThh+hh:mm', 'YYYY-MM-DDThh-hh', 'YYYY-MM-DDThh-hh:mm', 'YYYY-MM-DDThh:mm', 'YYYY-MM-DDThh:mmZ', 'YYYY-MM-DDThh:mm+hh', 'YYYY-MM-DDThh:mm+hh:mm', 'YYYY-MM-DDThh:mm-hh', 'YYYY-MM-DDThh:mm-hh:mm', 'YYYY-MM-DDThh:mm:ss', 'YYYY-MM-DDThh:mm:ssZ', 'YYYY-MM-DDThh:mm:ss+hh', 'YYYY-MM-DDThh:mm:ss+hh:mm', 'YYYY-MM-DDThh:mm:ss-hh', 'YYYY-MM-DDThh:mm:ss-hh:mm', 'YYYY-MM-DDThh:mm:ss.fff', 'YYYY-MM-DDThh:mm:ss.fffZ', 'YYYY-MM-DDThh:mm:ss.fff+hh', 'YYYY-MM-DDThh:mm:ss.fff+hh:mm', 'YYYY-MM-DDThh:mm:ss.fff-hh', 'YYYY-MM-DDThh:mm:ss.fff-hh:mm'];
    cqlFormatStringWithLength = {};
    for (i = 0, len = cqlFormats.length; i < len; i++) {
      format = cqlFormats[i];
      cqlFormatStringWithLength[format.length] = format;
    }
    if (cqlFormatStringWithLength[string.length] == null) {
      return false;
    }
    strict = false;
    return moment(string, cqlFormatStringToMomentFormatString(cqlFormatStringWithLength[string.length]), strict).isValid();
  };

  cqlFormatStringToMomentFormatString = function(string) {
    var momentString, ref1, timeAndTimeZoneOffset, timezoneSeparator, yearMonthDay;
    ref1 = string.split('T'), yearMonthDay = ref1[0], timeAndTimeZoneOffset = ref1[1];
    if (timeAndTimeZoneOffset != null) {
      timezoneSeparator = getTimezoneSeparatorFromString(timeAndTimeZoneOffset);
    }
    momentString = yearMonthDay;
    if (string.match(/T/) != null) {
      momentString += '[T]';
    }
    if (!!timezoneSeparator) {
      momentString += timeAndTimeZoneOffset.substring(0, timeAndTimeZoneOffset.search(timezoneSeparator)) + '[Z]';
    } else {
      momentString += timeAndTimeZoneOffset;
    }
    return momentString = momentString.replace(/f/g, 'S');
  };

  module.exports.DateTime = DateTime;

  module.exports.Date = Date;

}).call(this);

//# sourceMappingURL=datetime.js.map
