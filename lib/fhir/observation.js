// Generated by CoffeeScript 1.12.7
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Observation, ObservationReferenceRangeComponent, ObservationRelatedComponent, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class ObservationReferenceRangeComponent
  @exports  ObservationReferenceRangeComponent as ObservationReferenceRangeComponent
   */

  ObservationReferenceRangeComponent = (function(superClass) {
    extend(ObservationReferenceRangeComponent, superClass);

    function ObservationReferenceRangeComponent(json) {
      this.json = json;
      ObservationReferenceRangeComponent.__super__.constructor.call(this, this.json);
    }


    /**
    The value of the low bound of the reference range. If this is omitted, the low bound of the reference range is assumed to be meaningless. E.g. <2.3.
    @returns {Quantity}
     */

    ObservationReferenceRangeComponent.prototype.low = function() {
      if (this.json['low']) {
        return new Quantity(this.json['low']);
      }
    };


    /**
    The value of the high bound of the reference range. If this is omitted, the high bound of the reference range is assumed to be meaningless. E.g. >5.
    @returns {Quantity}
     */

    ObservationReferenceRangeComponent.prototype.high = function() {
      if (this.json['high']) {
        return new Quantity(this.json['high']);
      }
    };


    /**
    Code for the meaning of the reference range.
    @returns {CodeableConcept}
     */

    ObservationReferenceRangeComponent.prototype.meaning = function() {
      if (this.json['meaning']) {
        return new CodeableConcept(this.json['meaning']);
      }
    };


    /**
    The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    @returns {Range}
     */

    ObservationReferenceRangeComponent.prototype.age = function() {
      if (this.json['age']) {
        return new Range(this.json['age']);
      }
    };


    /**
    Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
    @returns {Array} an array of {@link String} objects
     */

    ObservationReferenceRangeComponent.prototype.text = function() {
      return this.json['text'];
    };

    return ObservationReferenceRangeComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class ObservationRelatedComponent
  @exports  ObservationRelatedComponent as ObservationRelatedComponent
   */

  ObservationRelatedComponent = (function(superClass) {
    extend(ObservationRelatedComponent, superClass);

    function ObservationRelatedComponent(json) {
      this.json = json;
      ObservationRelatedComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A code specifying the kind of relationship that exists with the target observation.
    @returns {Array} an array of {@link String} objects
     */

    ObservationRelatedComponent.prototype.type = function() {
      return this.json['type'];
    };


    /**
    A reference to the observation that is related to this observation.
    @returns {Reference}
     */

    ObservationRelatedComponent.prototype.target = function() {
      if (this.json['target']) {
        return new Reference(this.json['target']);
      }
    };

    return ObservationRelatedComponent;

  })(BackboneElement);


  /**
  Measurements and simple assertions made about a patient, device or other subject.
  @class Observation
  @exports Observation as Observation
   */

  Observation = (function(superClass) {
    extend(Observation, superClass);

    function Observation(json) {
      this.json = json;
      Observation.__super__.constructor.call(this, this.json);
    }


    /**
    Describes what was observed. Sometimes this is called the observation "code".
    @returns {CodeableConcept}
     */

    Observation.prototype.name = function() {
      if (this.json['name']) {
        return new CodeableConcept(this.json['name']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Quantity}
     */

    Observation.prototype.valueQuantity = function() {
      if (this.json['valueQuantity']) {
        return new Quantity(this.json['valueQuantity']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {CodeableConcept}
     */

    Observation.prototype.valueCodeableConcept = function() {
      if (this.json['valueCodeableConcept']) {
        return new CodeableConcept(this.json['valueCodeableConcept']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Attachment}
     */

    Observation.prototype.valueAttachment = function() {
      if (this.json['valueAttachment']) {
        return new Attachment(this.json['valueAttachment']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Ratio}
     */

    Observation.prototype.valueRatio = function() {
      if (this.json['valueRatio']) {
        return new Ratio(this.json['valueRatio']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Array} an array of {@link Date} objects
     */

    Observation.prototype.valueDateTime = function() {
      if (this.json['valueDateTime']) {
        return DT.DateTime.parse(this.json['valueDateTime']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Period}
     */

    Observation.prototype.valuePeriod = function() {
      if (this.json['valuePeriod']) {
        return new Period(this.json['valuePeriod']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {SampledData}
     */

    Observation.prototype.valueSampledData = function() {
      if (this.json['valueSampledData']) {
        return new SampledData(this.json['valueSampledData']);
      }
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.valueString = function() {
      return this.json['valueString'];
    };


    /**
    The information determined as a result of making the observation, if the information has a simple value.
    @returns {time}
     */

    Observation.prototype.valueTime = function() {
      if (this.json['valueTime']) {
        return new time(this.json['valueTime']);
      }
    };


    /**
    Provides a reason why the expected value in the element Observation.value[x] is missing.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.dataAbsentReason = function() {
      return this.json['dataAbsentReason'];
    };


    /**
    The assessment made based on the result of the observation.
    @returns {CodeableConcept}
     */

    Observation.prototype.interpretation = function() {
      if (this.json['interpretation']) {
        return new CodeableConcept(this.json['interpretation']);
      }
    };


    /**
    May include statements about significant, unexpected or unreliable values, or information about the source of the value where this may be relevant to the interpretation of the result.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.comments = function() {
      return this.json['comments'];
    };


    /**
    The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself.
    @returns {Array} an array of {@link Date} objects
     */

    Observation.prototype.appliesDateTime = function() {
      if (this.json['appliesDateTime']) {
        return DT.DateTime.parse(this.json['appliesDateTime']);
      }
    };


    /**
    The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself.
    @returns {Period}
     */

    Observation.prototype.appliesPeriod = function() {
      if (this.json['appliesPeriod']) {
        return new Period(this.json['appliesPeriod']);
      }
    };


    /**
    The date and time this observation was made available.
    @returns {Array} an array of {@link Date} objects
     */

    Observation.prototype.issued = function() {
      if (this.json['issued']) {
        return DT.DateTime.parse(this.json['issued']);
      }
    };


    /**
    The status of the result value.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.status = function() {
      return this.json['status'];
    };


    /**
    An estimate of the degree to which quality issues have impacted on the value reported.
    @returns {Array} an array of {@link String} objects
     */

    Observation.prototype.reliability = function() {
      return this.json['reliability'];
    };


    /**
    Indicates the site on the subject's body where the observation was made ( i.e. the target site).
    @returns {CodeableConcept}
     */

    Observation.prototype.bodySite = function() {
      if (this.json['bodySite']) {
        return new CodeableConcept(this.json['bodySite']);
      }
    };


    /**
    Indicates the mechanism used to perform the observation.
    @returns {CodeableConcept}
     */

    Observation.prototype.method = function() {
      if (this.json['method']) {
        return new CodeableConcept(this.json['method']);
      }
    };


    /**
    A unique identifier for the simple observation.
    @returns {Identifier}
     */

    Observation.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The thing the observation is being made about.
    @returns {Reference}
     */

    Observation.prototype.subject = function() {
      if (this.json['subject']) {
        return new Reference(this.json['subject']);
      }
    };


    /**
    The specimen that was used when this observation was made.
    @returns {Reference}
     */

    Observation.prototype.specimen = function() {
      if (this.json['specimen']) {
        return new Reference(this.json['specimen']);
      }
    };


    /**
    Who was responsible for asserting the observed value as "true".
    @returns {Array} an array of {@link Reference} objects
     */

    Observation.prototype.performer = function() {
      var i, item, len, ref, results;
      if (this.json['performer']) {
        ref = this.json['performer'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Reference(item));
        }
        return results;
      }
    };


    /**
    The healthcare event  ( e.g. a patient and healthcare provider interaction ) that relates to this observation.
    @returns {Reference}
     */

    Observation.prototype.encounter = function() {
      if (this.json['encounter']) {
        return new Reference(this.json['encounter']);
      }
    };


    /**
    Guidance on how to interpret the value by comparison to a normal or recommended range.
    @returns {Array} an array of {@link ObservationReferenceRangeComponent} objects
     */

    Observation.prototype.referenceRange = function() {
      var i, item, len, ref, results;
      if (this.json['referenceRange']) {
        ref = this.json['referenceRange'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ObservationReferenceRangeComponent(item));
        }
        return results;
      }
    };


    /**
    Related observations - either components, or previous observations, or statements of derivation.
    @returns {Array} an array of {@link ObservationRelatedComponent} objects
     */

    Observation.prototype.related = function() {
      var i, item, len, ref, results;
      if (this.json['related']) {
        ref = this.json['related'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ObservationRelatedComponent(item));
        }
        return results;
      }
    };

    return Observation;

  })(DomainResource);

  module.exports.Observation = Observation;

}).call(this);

//# sourceMappingURL=observation.js.map
