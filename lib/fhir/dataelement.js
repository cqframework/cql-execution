// Generated by CoffeeScript 1.12.7
(function() {
  var Address, Attachment, BackboneElement, CORE, CodeableConcept, Coding, ContactPoint, DT, DataElement, DataElementBindingComponent, DataElementMappingComponent, DomainResource, Element, ElementDefinition, Extension, HumanName, Identifier, Narrative, Parameters, Period, Quantity, Range, Ratio, Reference, Resource, SampledData, Timing,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DT = require('../cql-datatypes');

  CORE = require('./core');

  Element = CORE.Element;

  Resource = CORE.Resource;

  Timing = CORE.Timing;

  Period = CORE.Period;

  Parameters = CORE.Parameters;

  Coding = CORE.Coding;

  Resource = CORE.Resource;

  Range = CORE.Range;

  Quantity = CORE.Quantity;

  Attachment = CORE.Attachment;

  BackboneElement = CORE.BackboneElement;

  DomainResource = CORE.DomainResource;

  ContactPoint = CORE.ContactPoint;

  ElementDefinition = CORE.ElementDefinition;

  Extension = CORE.Extension;

  HumanName = CORE.HumanName;

  Address = CORE.Address;

  Ratio = CORE.Ratio;

  SampledData = CORE.SampledData;

  Reference = CORE.Reference;

  CodeableConcept = CORE.CodeableConcept;

  Identifier = CORE.Identifier;

  Narrative = CORE.Narrative;

  Element = CORE.Element;


  /** 
  Embedded class
  @class DataElementBindingComponent
  @exports  DataElementBindingComponent as DataElementBindingComponent
   */

  DataElementBindingComponent = (function(superClass) {
    extend(DataElementBindingComponent, superClass);

    function DataElementBindingComponent(json) {
      this.json = json;
      DataElementBindingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    @returns {Array} an array of {@link boolean} objects
     */

    DataElementBindingComponent.prototype.isExtensible = function() {
      return this.json['isExtensible'];
    };


    /**
    Indicates the degree of conformance expectations associated with this binding.
    @returns {Array} an array of {@link String} objects
     */

    DataElementBindingComponent.prototype.conformance = function() {
      return this.json['conformance'];
    };


    /**
    Describes the intended use of this particular set of codes.
    @returns {Array} an array of {@link String} objects
     */

    DataElementBindingComponent.prototype.description = function() {
      return this.json['description'];
    };


    /**
    Points to the value set that identifies the set of codes to be used.
    @returns {Reference}
     */

    DataElementBindingComponent.prototype.valueSet = function() {
      if (this.json['valueSet']) {
        return new Reference(this.json['valueSet']);
      }
    };

    return DataElementBindingComponent;

  })(BackboneElement);


  /** 
  Embedded class
  @class DataElementMappingComponent
  @exports  DataElementMappingComponent as DataElementMappingComponent
   */

  DataElementMappingComponent = (function(superClass) {
    extend(DataElementMappingComponent, superClass);

    function DataElementMappingComponent(json) {
      this.json = json;
      DataElementMappingComponent.__super__.constructor.call(this, this.json);
    }


    /**
    A URI that identifies the specification that this mapping is expressed to.
    @returns {Array} an array of {@link String} objects
     */

    DataElementMappingComponent.prototype.uri = function() {
      return this.json['uri'];
    };


    /**
    If true, indicates that the official meaning of the data element is exactly equivalent to the mapped element.
    @returns {Array} an array of {@link boolean} objects
     */

    DataElementMappingComponent.prototype.definitional = function() {
      return this.json['definitional'];
    };


    /**
    A name for the specification that is being mapped to.
    @returns {Array} an array of {@link String} objects
     */

    DataElementMappingComponent.prototype.name = function() {
      return this.json['name'];
    };


    /**
    Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    @returns {Array} an array of {@link String} objects
     */

    DataElementMappingComponent.prototype.comments = function() {
      return this.json['comments'];
    };


    /**
    Expresses what part of the target specification corresponds to this element.
    @returns {Array} an array of {@link String} objects
     */

    DataElementMappingComponent.prototype.map = function() {
      return this.json['map'];
    };

    return DataElementMappingComponent;

  })(BackboneElement);


  /**
  The formal description of a single piece of information that can be gathered and reported.
  @class DataElement
  @exports DataElement as DataElement
   */

  DataElement = (function(superClass) {
    extend(DataElement, superClass);

    function DataElement(json) {
      this.json = json;
      DataElement.__super__.constructor.call(this, this.json);
    }


    /**
    The identifier that is used to identify this data element when it is referenced in a Profile, Questionnaire or an instance.
    @returns {Identifier}
     */

    DataElement.prototype.identifier = function() {
      if (this.json['identifier']) {
        return new Identifier(this.json['identifier']);
      }
    };


    /**
    The identifier that is used to identify this version of the data element when it is referenced in a Profile, Questionnaire or instance. This is an arbitrary value managed by the definition author manually.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.version = function() {
      return this.json['version'];
    };


    /**
    Details of the individual or organization who accepts responsibility for publishing the data element.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.publisher = function() {
      return this.json['publisher'];
    };


    /**
    Contact details to assist a user in finding and communicating with the publisher.
    @returns {Array} an array of {@link ContactPoint} objects
     */

    DataElement.prototype.telecom = function() {
      var i, item, len, ref, results;
      if (this.json['telecom']) {
        ref = this.json['telecom'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new ContactPoint(item));
        }
        return results;
      }
    };


    /**
    The status of the data element.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.status = function() {
      return this.json['status'];
    };


    /**
    The date that this version of the data element was published.
    @returns {Array} an array of {@link Date} objects
     */

    DataElement.prototype.date = function() {
      if (this.json['date']) {
        return DT.DateTime.parse(this.json['date']);
      }
    };


    /**
    The term used by humans to refer to the data element.  Should ideally be unique within the context in which the data element is expected to be used.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.name = function() {
      return this.json['name'];
    };


    /**
    A set of terms from external terminologies that may be used to assist with indexing and searching of data element definitions.
    @returns {Array} an array of {@link CodeableConcept} objects
     */

    DataElement.prototype.category = function() {
      var i, item, len, ref, results;
      if (this.json['category']) {
        ref = this.json['category'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new CodeableConcept(item));
        }
        return results;
      }
    };


    /**
    A code that provides the meaning for a data element according to a particular terminology.
    @returns {Array} an array of {@link Coding} objects
     */

    DataElement.prototype.code = function() {
      var i, item, len, ref, results;
      if (this.json['code']) {
        ref = this.json['code'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new Coding(item));
        }
        return results;
      }
    };


    /**
    The default/suggested phrasing to use when prompting a human to capture the data element.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.question = function() {
      return this.json['question'];
    };


    /**
    Provides a complete explanation of the meaning of the data element for human readability.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.definition = function() {
      return this.json['definition'];
    };


    /**
    Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.comments = function() {
      return this.json['comments'];
    };


    /**
    Explains why this element is needed and why it's been constrained as it has.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.requirements = function() {
      return this.json['requirements'];
    };


    /**
    Identifies additional names by which this element might also be known.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.synonym = function() {
      return this.json['synonym'];
    };


    /**
    The FHIR data type that is the type for this element.
    @returns {Array} an array of {@link String} objects
     */

    DataElement.prototype.type = function() {
      return this.json['type'];
    };


    /**
    An sample value for this element demonstrating the type of information that would typically be captured.
    @returns {Array} an array of {@link } objects
     */

    DataElement.prototype.example = function() {
      return this.json['example'];
    };


    /**
    Indicates the shortest length that SHALL be supported by conformant instances without truncation.
    @returns {Array} an array of {@link Number} objects
     */

    DataElement.prototype.maxLength = function() {
      return this.json['maxLength'];
    };


    /**
    Identifies the units of measure in which the data element should be captured or expressed.
    @returns {CodeableConcept}
     */

    DataElement.prototype.units = function() {
      if (this.json['units']) {
        return new CodeableConcept(this.json['units']);
      }
    };


    /**
    Binds to a value set if this element is coded (code, Coding, CodeableConcept).
    @returns {DataElementBindingComponent}
     */

    DataElement.prototype.binding = function() {
      if (this.json['binding']) {
        return new DataElementBindingComponent(this.json['binding']);
      }
    };


    /**
    Identifies a concept from an external specification that roughly corresponds to this element.
    @returns {Array} an array of {@link DataElementMappingComponent} objects
     */

    DataElement.prototype.mapping = function() {
      var i, item, len, ref, results;
      if (this.json['mapping']) {
        ref = this.json['mapping'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(new DataElementMappingComponent(item));
        }
        return results;
      }
    };

    return DataElement;

  })(DomainResource);

  module.exports.DataElement = DataElement;

}).call(this);

//# sourceMappingURL=dataelement.js.map
